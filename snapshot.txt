================  DIRECTORY TREE  ================
SAP-BOT - Currency
├── core
│   ├── __init__.py
│   └── base.py
├── pages
│   ├── CurrencyExchangeRates
│   │   ├── __init__.py
│   │   ├── page.py
│   │   └── selectors.py
│   ├── Index
│   │   ├── ProcurementOverviewTile
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── PurchasingTab
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── __init__.py
│   │   └── page.py
│   ├── Login
│   │   ├── elements
│   │   │   ├── Password
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Submit
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Username
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   └── __init__.py
│   │   ├── __init__.py
│   │   └── page.py
│   ├── Shell
│   │   ├── Search
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   └── __init__.py
│   └── __init__.py
├── routes
│   ├── __init__.py
│   ├── auth.py
│   └── currency.py
├── services
│   ├── __init__.py
│   ├── auth.py
│   ├── config.py
│   ├── driver.py
│   ├── safe.py
│   └── ui.py
├── .env
├── .gitignore
├── main.py
├── README.md
├── requirements.txt
├── run_demo.py
├── snapshot.txt
└── temp.ipynb

================  FILE CONTENTS  =================

# .env

SAP_URL=https://my413369.s4hana.cloud.sap/ui#Shell-home
SAP_USERNAME=y.ghanem@esnadinternational.com
SAP_PASSWORD=Esnadinternational020

HEADLESS=false
EXPLICIT_WAIT_SECONDS=15
PAGELOAD_TIMEOUT_SECONDS=90
KEEP_BROWSER=true
SCREENSHOT_PATH=after_click.png


# .gitignore

__pycache__/
*.py[cod]
.env
.venv/
venv/
env/
.chromedriver/
chrome_profile/
.DS_Store
*.log
*.png


# main.py

from fastapi import FastAPI
from routes import router as api_router

app = FastAPI(title="AIP-BOT API", version="1.0")
app.include_router(api_router)


# README.md



# run_demo.py

# run_demo.py
from services.config import config
from services.driver import get_driver
from services.auth import login
from services.ui import wait_for_shell_home, wait_ui5_idle, wait_url_contains
from pages.Index.page import IndexPage

def main():
    cfg = config()
    driver = get_driver(headless=cfg["HEADLESS"])
    try:
        print("[1/3] Logging in …")
        login(driver)

        print("[2/3] Waiting for Fiori Shell …")
        ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
        print(f"Shell-home detected: {ok}")
        wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

        print("[3/3] Opening Purchasing → Procurement Overview …")
        idx = IndexPage(driver, root=cfg["SAP_URL"])
        idx.to_purchasing()
        idx.open_procurement_overview()
        wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

        # confirm navigation by hash
        if not wait_url_contains(driver, "#Procurement-displayOverviewPage", cfg["EXPLICIT_WAIT_SECONDS"]):
            print("[WARN] Did not see target hash yet; UI might still be loading.")
        input("\n✅ Navigated. Press Enter to close…")
    finally:
        if not cfg["KEEP_BROWSER"]:
            driver.quit()

if __name__ == "__main__":
    main()


# temp.ipynb  (code cells only)

# ── cell 1 ──
from pathlib import Path, PurePosixPath
import json

MAX_READ_BYTES = 200_000
SKIP_DIRS      = {'__pycache__', '.git', '.vscode', 'node_modules', 'venv', 'env', 'tmp_streamlit'}
IGNORED_EXTS   = {
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', '.svg',
    '.pdf', '.joblib'
}
PATHS_ONLY_EXT = {'.txt', '.csv', '.json'}         # list names, no content

def _tree(root: Path) -> str:
    """ASCII tree of *root*, skipping SKIP_DIRS and IGNORED_EXTS files."""
    lines, stack = [root.name], []

    def walk(cur: Path):
        kids = [
            p for p in cur.iterdir()
            if p.name not in SKIP_DIRS
            and not (p.is_file() and p.suffix.lower() in IGNORED_EXTS)
        ]
        kids.sort(key=lambda p: (p.is_file(), p.name.lower()))
        for i, kid in enumerate(kids):
            connector = "└── " if i == len(kids) - 1 else "├── "
            lines.append(''.join(stack) + connector + kid.name)
            if kid.is_dir():
                stack.append('    ' if i == len(kids) - 1 else '│   ')
                walk(kid)
                stack.pop()
    walk(root)
    return '\n'.join(lines)

def _extract_ipynb_code(nb_path: Path) -> str:
    """Return concatenated source of code cells from a notebook."""
    try:
        nb_json = json.loads(nb_path.read_text(encoding='utf‑8'))
        cells   = nb_json.get('cells', [])
        code_blocks = []
        for idx, cell in enumerate(cells, 1):
            if cell.get('cell_type') == 'code':
                src = ''.join(cell.get('source', ''))
                code_blocks.append(f"# ── cell {idx} ──\n{src}")
        return '\n\n'.join(code_blocks) or '[Notebook contains no code cells]'
    except Exception as exc:
        return f"[Could not read notebook: {exc}]"

def _dump(root: Path) -> str:
    out_lines, listed_only = [], []

    for path in root.rglob('*'):
        if path.is_dir() or any(p.name in SKIP_DIRS for p in path.parents):
            continue
        ext = path.suffix.lower()
        if ext in IGNORED_EXTS:
            continue                      # ignore images/PDFs/etc.

        rel = path.relative_to(root)

        # .txt / .csv / .json  → list name only
        if ext in PATHS_ONLY_EXT:
            listed_only.append(rel)
            continue

        # .ipynb  → dump only code cells
        if ext == '.ipynb':
            out_lines.append(f"\n# {rel}  (code cells only)\n")
            out_lines.append(_extract_ipynb_code(path))
            continue

        # everything else → dump file content
        out_lines.append(f"\n# {rel}\n")
        try:
            text = path.read_text('utf‑8', errors='replace')
            if len(text) > MAX_READ_BYTES:
                text = text[:MAX_READ_BYTES] + "\n[...TRUNCATED...]"
            out_lines.append(text)
        except Exception as exc:
            out_lines.append(f"[Could not read file: {exc}]")

    if listed_only:
        out_lines.append("\n## .txt / .csv / .json files (names only)\n")
        out_lines.extend(map(str, listed_only))

    return '\n'.join(out_lines)

def build_dir_report(root='.', out_file='dir_report.txt', show=True) -> str:
    root = Path(root or '.').expanduser().resolve()
    if not root.is_dir():
        raise NotADirectoryError(root)

    report = (
        "================  DIRECTORY TREE  ================\n"
        + _tree(root)
        + "\n\n================  FILE CONTENTS  =================\n"
        + _dump(root)
    )

    Path(out_file).write_text(report, encoding='utf‑8')
    if show:
        print(report)
        print(f"\nReport saved to {out_file}")
    return report


rep_text = build_dir_report(out_file="snapshot.txt", show=False)


# core\base.py

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Tuple

from selenium.webdriver.common.by import By
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from services.config import config

def _all_frames(driver: WebDriver):
    try:
        return driver.find_elements(By.CSS_SELECTOR, "iframe, frame")
    except Exception:
        return []

def _scan_frames_for(driver: WebDriver, locator: Tuple[str, str], timeout: int):
    """
    Fast path: look in default content first (with a very short wait).
    Only then peek into iframes with a tiny per-frame cap.
    """
    # 1) Default content (quick)
    driver.switch_to.default_content()
    try:
        return WebDriverWait(driver, min(3, timeout)).until(
            EC.presence_of_element_located(locator)
        )
    except Exception:
        pass

    # 2) Light iframe sweep (FLP typically doesn't need this)
    frames = _all_frames(driver)
    per_frame = 1.5  # seconds max per frame
    for f in frames:
        try:
            driver.switch_to.default_content()
            driver.switch_to.frame(f)
            el = WebDriverWait(driver, per_frame).until(
                EC.presence_of_element_located(locator)
            )
            return el
        except Exception:
            continue

    driver.switch_to.default_content()
    raise TimeoutError(f"Element not found for {locator}")

@dataclass
class Element:
    driver: WebDriver
    timeout: Optional[int] = None

    def __post_init__(self):
        if self.timeout is None:
            try:
                self.timeout = config()["EXPLICIT_WAIT_SECONDS"]
            except Exception:
                self.timeout = 30

    @property
    def _timeout(self) -> int:
        return self.timeout or config()["EXPLICIT_WAIT_SECONDS"]

    def find(self, by: By, value: str):
        return _scan_frames_for(self.driver, (by, value), self._timeout)

    def wait_visible(self, by: By, value: str):
        el = _scan_frames_for(self.driver, (by, value), self._timeout)
        return WebDriverWait(self.driver, self._timeout).until(EC.visibility_of(el))

    def wait_clickable(self, by: By, value: str):
        _ = _scan_frames_for(self.driver, (by, value), self._timeout)
        return WebDriverWait(self.driver, self._timeout).until(EC.element_to_be_clickable((by, value)))

    def js_click(self, el) -> None:
        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
        self.driver.execute_script("arguments[0].click();", el)

class Page:
    def __init__(self, driver: WebDriver, root: Optional[str] = None):
        self.driver = driver
        self.root = root

    def open(self, url: str):
        if self.root and not url.lower().startswith(("http://", "https://")):
            url = self.root.rstrip("/") + "/" + url.lstrip("/")
        self.driver.get(url)

    def ensure_url_contains(self, needle: str, timeout: Optional[int] = None):
        t = timeout or config()["EXPLICIT_WAIT_SECONDS"]
        WebDriverWait(self.driver, t).until(
            lambda d: needle.lower() in (d.current_url or "").lower()
        )


# core\__init__.py



# pages\__init__.py



# routes\auth.py

from fastapi import APIRouter
from services.driver import get_driver
from services.auth import login
from services.config import config
from services.ui import wait_for_shell_home

router = APIRouter()

@router.get("/auth/test-login")
async def test_login():
    cfg = config()
    driver = get_driver(headless=cfg["HEADLESS"])
    try:
        login(driver)
        ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
        driver.save_screenshot("login_test_after.png")
        return {
            "ok": ok,
            "current_url": driver.current_url,
            "screenshot": "login_test_after.png",
        }
    except Exception as e:
        try:
            driver.save_screenshot("login_test_error.png")
        except Exception:
            pass
        return {"ok": False, "error": str(e), "screenshot": "login_test_error.png"}
    finally:
        if not cfg["KEEP_BROWSER"]:
            driver.quit()


# routes\currency.py

# routes/currency.py
from fastapi import APIRouter
from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Optional
from decimal import Decimal, ROUND_HALF_UP
from datetime import datetime
import time

from services.config import config
from services.driver import get_driver
from services.auth import login
from services.ui import (
    wait_for_shell_home,
    wait_ui5_idle,
    wait_url_contains,
    wait_shell_search_ready,
)
from pages.Shell.Search.element import ShellSearch
from pages.CurrencyExchangeRates.page import CurrencyExchangeRatesPage

router = APIRouter()

class ExchangeRateItem(BaseModel):
    ExchangeRateType: str = Field(..., description="e.g. M")
    FromCurrency: str = Field(..., description="e.g. USD")
    ToCurrency: str = Field(..., description="e.g. JOD")
    ValidFrom: str = Field(..., description="Date like 12/31/2025 or 2025-12-31")
    Quotation: Optional[str] = Field("Direct", description="Direct or Indirect")
    ExchangeRate: str | float | Decimal = Field(..., description="> 0; rounded to 5 dp")

    @validator("ExchangeRateType", "FromCurrency", "ToCurrency")
    def _up(cls, v: str): return (v or "").strip().upper()

    @validator("Quotation", always=True)
    def _q(cls, v: Optional[str]):
        s = (v or "Direct").strip().capitalize()
        return "Indirect" if s.startswith("Ind") else "Direct"

    @validator("ValidFrom")
    def _datefmt(cls, v: str):
        s = (v or "").strip()
        fmts = ["%m/%d/%Y","%Y-%m-%d","%Y/%m/%d","%d/%m/%Y","%Y%m%d"]
        for f in fmts:
            try:
                return datetime.strptime(s, f).strftime("%m/%d/%Y")
            except Exception:
                pass
        raise ValueError(f"Unrecognized date: {v}")

    @validator("ExchangeRate")
    def _5dp(cls, v):
        q = Decimal(str(v))
        if q <= 0: raise ValueError("ExchangeRate must be > 0")
        q = q.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
        return f"{q:.5f}"

@router.post("/currency/exchange-rates/batch")
async def create_exchange_rates(items: List[ExchangeRateItem]) -> Dict[str, Any]:
    cfg = config()
    drv = get_driver(headless=cfg["HEADLESS"])
    results: List[Dict[str, Any]] = []

    try:
        # login and open app
        login(drv)
        if not wait_for_shell_home(drv, timeout=40):
            return {"ok": False, "error": "Shell home not detected"}
        wait_ui5_idle(drv, timeout=30)
        wait_shell_search_ready(drv, timeout=30)

        ShellSearch(drv).open_search().type_and_choose_app("Currency Exchange Rates")
        wait_ui5_idle(drv, timeout=30)
        wait_url_contains(drv, "#Currency-maintainExchangeRates", 30)

        page = CurrencyExchangeRatesPage(drv)
        page.ensure_in_app()

        for idx, it in enumerate(items, start=1):
            res = page.create_rate(
                exch_type=it.ExchangeRateType,
                from_ccy=it.FromCurrency,
                to_ccy=it.ToCurrency,
                valid_from_mmddyyyy=it.ValidFrom,
                quotation=it.Quotation,
                rate_value=it.ExchangeRate
            )
            results.append({"index": idx, "payload": it.dict(), **res})

            # If a dialog is open, DO NOT close it and DO NOT navigate away.
            if res.get("status") == "dialog_open":
                return {
                    "ok": False,
                    "interrupted_by_dialog": True,
                    "message": "A dialog is open. Leaving it visible for you to read.",
                    "result": results[-1],
                    "results_so_far": results
                }

            # If created, return to list to prep for next item
            if res.get("status") == "created" or res.get("at_list"):
                try:
                    page.back_to_list()
                except Exception:
                    pass

            time.sleep(0.3)

        return {
            "ok": all(r.get("status") in ("created","unknown") for r in results),
            "total": len(items),
            "created": sum(1 for r in results if r.get("status") == "created"),
            "failed": sum(1 for r in results if r.get("status") == "validation_error"),
            "results": results
        }
    finally:
        if not cfg.get("KEEP_BROWSER"):
            drv.quit()


# routes\__init__.py

from fastapi import APIRouter
from . import auth
from . import currency

router = APIRouter()
router.include_router(auth.router, tags=["auth"])
router.include_router(currency.router, tags=["currency"])


# services\auth.py

from services.config import config
from pages.Login.page import LoginPage
from services.ui import wait_for_shell_home

def login(driver) -> None:
    cfg = config()
    LoginPage(driver).login(cfg["SAP_USERNAME"], cfg["SAP_PASSWORD"])
    # Let caller verify with wait_for_shell_home
    wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])


# services\config.py

# services/config.py
from dotenv import load_dotenv
import os

load_dotenv()

_BOOL = {"1", "true", "yes", "on", "y", "t"}

def _as_bool(v: str, default=False) -> bool:
    if v is None:
        return default
    return v.strip().lower() in _BOOL

def _as_int(v: str, default: int) -> int:
    try:
        return int(v)
    except Exception:
        return default

def config():
    sap_url = os.getenv("SAP_URL", "https://my413369.s4hana.cloud.sap/ui#Shell-home")
    return {
        "SAP_URL": sap_url,
        "ROOT_URL": sap_url,  # alias to avoid KeyErrors in callers
        "SAP_USERNAME": os.getenv("SAP_USERNAME", ""),
        "SAP_PASSWORD": os.getenv("SAP_PASSWORD", ""),

        "HEADLESS": _as_bool(os.getenv("HEADLESS", "false")),
        "EXPLICIT_WAIT_SECONDS": _as_int(os.getenv("EXPLICIT_WAIT_SECONDS", "30"), 30),
        "PAGELOAD_TIMEOUT_SECONDS": _as_int(os.getenv("PAGELOAD_TIMEOUT_SECONDS", "90"), 90),
        "KEEP_BROWSER": _as_bool(os.getenv("KEEP_BROWSER", "true")),
        "SCREENSHOT_PATH": os.getenv("SCREENSHOT_PATH", "after_click.png"),
    }

# Legacy convenience
ROOT_URL = config()["ROOT_URL"]
EXPLICIT_WAIT_SEC = config()["EXPLICIT_WAIT_SECONDS"]


# services\driver.py

# services/driver.py
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from services.config import config

def get_driver(headless: bool = True) -> webdriver.Chrome:
    cfg = config()

    options = Options()
    if headless:
        options.add_argument("--headless=new")
    else:
        options.add_argument("--start-maximized")  # open full screen if not headless

    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-extensions")
    options.add_argument("--log-level=3")
    options.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
    options.add_experimental_option("useAutomationExtension", False)
    options.add_experimental_option("prefs", {
        "credentials_enable_service": False,
        "profile.password_manager_enabled": False
    })

    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)
    driver.set_page_load_timeout(cfg["PAGELOAD_TIMEOUT_SECONDS"])

    # force maximize in case --start-maximized didn’t take effect
    if not headless:
        try:
            driver.maximize_window()
        except Exception:
            pass

    # reduce automation fingerprinting noise
    try:
        driver.execute_cdp_cmd(
            "Page.addScriptToEvaluateOnNewDocument",
            {"source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"}
        )
    except Exception:
        pass

    return driver


# services\safe.py

from selenium.webdriver.support.ui import WebDriverWait

def wait_js(driver, predicate_js: str, timeout: int) -> bool:
    try:
        WebDriverWait(driver, timeout).until(lambda d: bool(d.execute_script(predicate_js)))
        return True
    except Exception:
        return False


# services\ui.py

# services/ui.py
from selenium.webdriver.support.ui import WebDriverWait
from services.config import EXPLICIT_WAIT_SEC

def _wait_js(driver, script: str, timeout: int) -> bool:
    try:
        WebDriverWait(driver, timeout).until(lambda d: bool(d.execute_script(script)))
        return True
    except Exception:
        return False

def wait_for_shell_home(driver, timeout: int | None = None) -> bool:
    """
    Ready when:
      - URL contains '#Shell-home', OR
      - UI5 core is initialized and ushell container is present.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    try:
        WebDriverWait(driver, t).until(
            lambda d: "shell-home" in (d.current_url or "").lower()
        )
        return True
    except Exception:
        pass

    js = """
    try {
      if (!window.sap || !sap.ui) return false;
      if (sap.ushell && sap.ushell.Container) return true;
      var core = sap.ui.getCore && sap.ui.getCore();
      if (!core) return false;
      if (core.isInitialized && !core.isInitialized()) return false;
      return true;
    } catch (e) { return false; }
    """
    return _wait_js(driver, js, t)

def wait_ui5_idle(driver, timeout: int | None = None) -> bool:
    """
    Lightweight 'settled' check for UI5 renderer and DOM idle enough to interact.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    js = """
    try {
      if (document.readyState !== 'complete') return false;
      if (window.sap && sap.ui && sap.ui.getCore) {
        var core = sap.ui.getCore();
        if (core && core.isInitialized && !core.isInitialized()) return false;
        if (core && core.getUIDirty && core.getUIDirty()) return false;
      }
      return true;
    } catch (e) { return true; }
    """
    return _wait_js(driver, js, t)

def wait_url_contains(driver, needle: str, timeout: int | None = None) -> bool:
    t = timeout or EXPLICIT_WAIT_SEC
    try:
        WebDriverWait(driver, t).until(
            lambda d: needle.lower() in (d.current_url or "").lower()
        )
        return True
    except Exception:
        return False

# ---------- NEW: robust shell search readiness + JS fallback ----------

def wait_shell_search_ready(driver, timeout: int | None = None) -> bool:
    """
    Wait until the FLP header search control is available OR the renderer exists.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    js = """
    try {
      var hasSearch = !!document.querySelector('a#sf.sapUshellShellHeadItm')
                   || !!document.querySelector("a.sapUshellShellHeadItm[data-help-id='shellHeader-search']")
                   || !!document.querySelector("a.sapUshellShellHeadItm[role='button'][aria-label*='Search']");
      if (hasSearch) return true;
      if (window.sap && sap.ushell && sap.ushell.Container) {
         var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
         if (r) return true;
      }
      return false;
    } catch(e){ return false; }
    """
    return _wait_js(driver, js, t)

def open_shell_search_via_js(driver) -> bool:
    """
    Ask the FLP renderer to open the global search.
    Returns True if we could call an API; False otherwise.
    """
    js = """
    try {
      if (window.sap && sap.ushell && sap.ushell.Container){
         var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
         if (r){
            if (typeof r.showSearch === 'function'){ r.showSearch(true); return true; }
            if (typeof r.openSearch === 'function'){ r.openSearch(); return true; }
         }
      }
    } catch(e){}
    return false;
    """
    try:
        return bool(driver.execute_script(js))
    except Exception:
        return False


# services\__init__.py

from .config import config
from .driver import get_driver
from .auth import login

__all__ = ["config", "get_driver", "login"]


# pages\CurrencyExchangeRates\page.py

# pages/CurrencyExchangeRates/page.py
from urllib.parse import urlparse
from datetime import datetime
import os
import time

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Page, Element
from services.ui import wait_ui5_idle
from .selectors import (
    APP_HASH,
    CREATE_BUTTON_XPATH,
    EXCH_TYPE_INPUT_XPATH,
    FROM_CCY_INPUT_XPATH,
    TO_CCY_INPUT_XPATH,
    VALID_FROM_INPUT_XPATH,
    QUOTATION_INNER_INPUT_XPATH,
    QUOTATION_ARROW_BTN_XPATH,
    QUOTATION_OPTION_BY_TEXT_XPATH,
    EXCH_RATE_INPUT_XPATH,
    FORM_CREATE_OR_SAVE_BTN_XPATH,
    ACTIVATE_CREATE_BTN_XPATH,
    MESSAGE_TOAST_CSS,
    ANY_INVALID_INPUT_XPATH,
    ANY_ERROR_WRAPPER_XPATH,
    DIALOG_ROOT_CSS,
)

class CurrencyExchangeRatesPage(Page):
    def _el(self) -> Element:
        return Element(self.driver)

    # -------- Utilities --------
    def _origin(self) -> str:
        try:
            return self.driver.execute_script("return location.origin;")
        except Exception:
            parsed = urlparse(self.driver.current_url or "")
            return f"{parsed.scheme}://{parsed.netloc}"

    def _app_root_url(self) -> str:
        return f"{self._origin()}/ui?sap-ushell-config=lean{APP_HASH}"

    def _screenshot(self, tag: str) -> str:
        ts = datetime.now().strftime("%Y%m%d-%H%M%S-%f")
        path = os.path.join("logs", f"rates_{tag}_{ts}.png")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        try:
            self.driver.save_screenshot(path)
            return path
        except Exception:
            return ""

    def _wait_not_busy(self, timeout: int) -> bool:
        """
        Wait until UI5 is not busy (renderer idle, no BusyIndicator).
        """
        end = time.time() + max(1, timeout)
        while time.time() < end:
            try:
                busy = self.driver.execute_script(
                    """
                    try{
                      var core=sap && sap.ui && sap.ui.getCore ? sap.ui.getCore():null;
                      if(core && core.isInitialized && !core.isInitialized()) return true;
                      if(core && core.getUIDirty && core.getUIDirty()) return true;
                      var BI=sap && sap.ui && sap.ui.core && sap.ui.core.BusyIndicator;
                      if(BI && BI.oPopup && BI.oPopup.getOpenState && BI.oPopup.getOpenState() === 'OPEN'){return true;}
                      return false;
                    }catch(e){return false;}
                    """
                )
                if not busy:
                    return True
            except Exception:
                return True
            time.sleep(0.15)
        return False

    # -------- Dialog detection (read only; never close) --------
    def _dialog_open(self) -> bool:
        try:
            return bool(self.driver.execute_script(
                "var a=document.querySelectorAll(arguments[0]);"
                "for(var i=a.length-1;i>=0;i--){var el=a[i];"
                "var s=window.getComputedStyle(el);"
                "if(s && s.display!=='none' && s.visibility!=='hidden' && el.offsetWidth>0 && el.offsetHeight>0){return true;}}"
                "return false;", DIALOG_ROOT_CSS
            ))
        except Exception:
            return False

    def _capture_dialog_text(self) -> str:
        try:
            txt = self.driver.execute_script(
                "var a=document.querySelectorAll(arguments[0]);"
                "for(var i=a.length-1;i>=0;i--){var el=a[i];"
                "var s=window.getComputedStyle(el);"
                "if(s && s.display!=='none' && s.visibility!=='hidden' && el.offsetWidth>0 && el.offsetHeight>0){"
                "  return (el.innerText||el.textContent||'').trim();}}"
                "return '';", DIALOG_ROOT_CSS
            )
            return (txt or "").strip()
        except Exception:
            return ""

    # -------- App navigation --------
    def ensure_in_app(self):
        if APP_HASH.lower() not in (self.driver.current_url or "").lower():
            self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
            wait_ui5_idle(self.driver, timeout=Element(self.driver)._timeout)
        el = self._el()
        WebDriverWait(self.driver, max(el._timeout, 20)).until(
            EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
        )

    def back_to_list(self):
        self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
        el = self._el()
        wait_ui5_idle(self.driver, timeout=max(el._timeout, 20))
        WebDriverWait(self.driver, max(el._timeout, 20)).until(
            EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
        )

    # -------- Low-level interactions --------
    def _click_list_create(self, timeout: int | None = None):
        el = self._el()
        btn = el.wait_clickable(By.XPATH, CREATE_BUTTON_XPATH)
        try:
            btn.click()
        except Exception:
            el.js_click(btn)
        wait_ui5_idle(self.driver, timeout=timeout or el._timeout)
        self._wait_not_busy(timeout or el._timeout)

    def _set_value(self, xpath: str, value: str, press_enter: bool = False):
        el = self._el()
        inp = el.wait_visible(By.XPATH, xpath)
        inp.clear()
        inp.send_keys(value)
        if press_enter:
            inp.send_keys(Keys.ENTER)

    def _set_quotation_value(self, value: str):
        el = self._el()
        wait = WebDriverWait(self.driver, max(el._timeout, 20))
        inp = el.wait_visible(By.XPATH, QUOTATION_INNER_INPUT_XPATH)
        try:
            inp.click()
        except Exception:
            el.js_click(inp)

        # Force-clear existing value
        try:
            inp.clear()
        except Exception:
            pass
        try:
            inp.send_keys(Keys.CONTROL, 'a'); inp.send_keys(Keys.DELETE)
            inp.send_keys(Keys.BACK_SPACE);   inp.send_keys(Keys.BACK_SPACE)
        except Exception:
            pass
        try:
            self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));",
                inp
            )
        except Exception:
            pass

        # Type & commit
        inp.send_keys(value)
        inp.send_keys(Keys.ENTER)
        inp.send_keys(Keys.TAB)
        wait_ui5_idle(self.driver, timeout=el._timeout)

        # Verify; if not matched, open popup and click exact option
        cur = (inp.get_attribute("value") or "").strip()
        if cur.lower() != value.strip().lower():
            try:
                arrow = wait.until(EC.element_to_be_clickable((By.XPATH, QUOTATION_ARROW_BTN_XPATH)))
                try: arrow.click()
                except Exception: el.js_click(arrow)
            except Exception:
                try: inp.send_keys(Keys.ALT, Keys.DOWN)
                except Exception: pass
            wait_ui5_idle(self.driver, timeout=el._timeout)
            opt_xpath = QUOTATION_OPTION_BY_TEXT_XPATH.format(TEXT=value.strip())
            option = wait.until(EC.element_to_be_clickable((By.XPATH, opt_xpath)))
            try: option.click()
            except Exception: el.js_click(option)
            wait_ui5_idle(self.driver, timeout=el._timeout)

    # ---- Strict UI5 setter for Exchange Rate (binding + 5dp + >0) ----
    def _set_rate_value_ui5(self, xpath: str, rate_val: str | float):
        el = self._el()
        inp = el.wait_visible(By.XPATH, xpath)
        inner_id = inp.get_attribute("id")
        if not inner_id:
            raise RuntimeError("Exchange Rate input has no DOM id")

        res = self.driver.execute_script(
            """
            try{
              var innerId=arguments[0], num=Number(String(arguments[1]).replace(',','.'));
              if(!isFinite(num) || num<=0){ return {ok:false, reason:'nonpositive'}; }
              var ctrlId = innerId.endsWith('-inner') ? innerId.slice(0,-6) : innerId;
              var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(ctrlId) : null;
              // Format with UI5 to 5 fractional digits
              var fmt = (sap && sap.ui && sap.ui.core && sap.ui.core.format && sap.ui.core.format.NumberFormat)
                        ? sap.ui.core.format.NumberFormat.getFloatInstance({maxFractionDigits:5,minFractionDigits:5,groupingEnabled:false})
                        : null;
              var s = fmt ? fmt.format(num) : num.toFixed(5);

              // Set on control (if exist) and also on DOM to ensure events fire
              if(ctrl && ctrl.setValue){
                  ctrl.setValue(s);
                  if (ctrl.fireLiveChange) ctrl.fireLiveChange({ value: s });
                  if (ctrl.fireChange)     ctrl.fireChange({ value: s });
              }
              var el = document.getElementById(innerId);
              if(el){
                  el.focus();
                  el.value = s;
                  el.dispatchEvent(new Event('input',{bubbles:true}));
                  el.dispatchEvent(new Event('change',{bubbles:true}));
              }

              // Parse back via UI5 formatter to confirm
              var parsed = fmt ? fmt.parse(s) : Number(s.replace(',','.'));
              return {ok:(typeof parsed==='number' && parsed>0), shown:s, parsed:parsed};
            }catch(e){
              return {ok:false, reason:String(e)};
            }
            """,
            inner_id, rate_val
        )

        wait_ui5_idle(self.driver, timeout=el._timeout)
        self._wait_not_busy(el._timeout)

        if not res or not res.get("ok"):
            snap = self._screenshot("rate_set_failed")
            raise RuntimeError(f"Could not set Exchange Rate (>0) via UI5. Result={res}. Screenshot: {snap}")

    # -------- Observability helpers --------
    def _has_validation_errors(self) -> str | None:
        try:
            bad_inputs = self.driver.find_elements(By.XPATH, ANY_INVALID_INPUT_XPATH)
            if bad_inputs:
                messages = []
                for el_ in bad_inputs:
                    try:
                        err_id = el_.get_attribute("aria-errormessage") or ""
                        msg = self.driver.execute_script(
                            "var id=arguments[0];"
                            "var n=id?document.getElementById(id):null;"
                            "return n? (n.innerText || n.textContent || '').trim():'';", err_id)
                        if msg: messages.append(msg)
                    except Exception:
                        continue
                if messages: return "; ".join(sorted(set(messages)))
                return f"{len(bad_inputs)} invalid field(s)."
            wrappers = self.driver.find_elements(By.XPATH, ANY_ERROR_WRAPPER_XPATH)
            if wrappers: return f"{len(wrappers)} field wrapper(s) in error state."
        except Exception:
            pass
        return None

    def _wait_for_success_toast_or_list(self, timeout: int) -> dict:
        """
        Wait for either:
         - a message toast text, OR
         - being back on the list page (Create button clickable), OR
         - a dialog opening (stop there, don't close).
        """
        el = self._el()
        end = time.time() + max(timeout, el._timeout)
        info = {"toast": "", "dialog": "", "at_list": False}
        while time.time() < end:
            # Dialog has priority — stop and return it
            if self._dialog_open():
                info["dialog"] = self._capture_dialog_text() or "Dialog open (no text captured)."
                return info

            # Toast?
            try:
                txt = self.driver.execute_script(
                    "var nodes=document.querySelectorAll(arguments[0]);"
                    "if(!nodes||nodes.length===0) return '';"
                    "var t=nodes[nodes.length-1];"
                    "return (t.innerText||t.textContent||'').trim();",
                    MESSAGE_TOAST_CSS,
                )
                if isinstance(txt, str) and txt:
                    info["toast"] = txt
                    # keep looping a bit more in case we navigate back
            except Exception:
                pass

            # Back on list?
            try:
                _ = WebDriverWait(self.driver, 0.8).until(
                    EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
                )
                info["at_list"] = True
                return info
            except Exception:
                pass

            time.sleep(0.2)

        return info

    # -------- Footer Create clicks (never closes dialog) --------
    def _click_footer_create(self, clicks: int = 1) -> dict:
        """
        Click the OBJECT PAGE footer 'Create' multiple times.
        - Waits for the button to be clickable each time.
        - Captures intermediate toast messages.
        - If a dialog appears, STOP (do NOT auto-close).
        """
        el = self._el()
        info = {"clicks": 0, "dialogs": [], "toasts": []}
        for _ in range(max(1, clicks)):
            if self._dialog_open():
                info["dialogs"].append(self._capture_dialog_text() or "")
                break

            btn = WebDriverWait(self.driver, max(el._timeout, 25)).until(
                EC.element_to_be_clickable((By.XPATH, ACTIVATE_CREATE_BTN_XPATH))
            )
            try:
                btn.click()
            except Exception:
                el.js_click(btn)

            info["clicks"] += 1

            wait_ui5_idle(self.driver, timeout=max(el._timeout, 25))
            self._wait_not_busy(max(el._timeout, 25))

            # Toast sampling
            try:
                txt = self.driver.execute_script(
                    "var nodes=document.querySelectorAll(arguments[0]);"
                    "if(!nodes||nodes.length===0) return '';"
                    "var t=nodes[nodes.length-1];"
                    "return (t.innerText||t.textContent||'').trim();",
                    MESSAGE_TOAST_CSS,
                )
                if isinstance(txt, str) and txt:
                    info["toasts"].append(txt)
            except Exception:
                pass

            time.sleep(0.25)

        return info

    # -------- Public: create + submit with verification --------
    def create_entry_and_submit(
        self,
        exch_type: str,
        from_ccy: str,
        to_ccy: str,
        valid_from_mmddyyyy: str,
        quotation: str,
        rate_str: str,
    ) -> dict:
        el = self._el()
        self.ensure_in_app()

        # 1) LIST → click Create, then wait until object page is ready
        self._click_list_create(timeout=el._timeout)
        self._screenshot("before_fill")

        # 2) Fill fields on the OBJECT PAGE
        self._set_value(EXCH_TYPE_INPUT_XPATH, exch_type)
        self._set_value(FROM_CCY_INPUT_XPATH, from_ccy)
        self._set_value(TO_CCY_INPUT_XPATH, to_ccy)

        self._set_value(VALID_FROM_INPUT_XPATH, valid_from_mmddyyyy)
        try:
            date_inp = el.find(By.XPATH, VALID_FROM_INPUT_XPATH)
            date_inp.send_keys(Keys.TAB)
        except Exception:
            pass

        # Quotation (force-clear then set)
        self._set_quotation_value(quotation)

        # Exchange Rate — strict UI5 setter (5dp, >0)
        self._set_rate_value_ui5(EXCH_RATE_INPUT_XPATH, rate_str)
        try:
            rate_inp = el.find(By.XPATH, EXCH_RATE_INPUT_XPATH)
            rate_inp.send_keys(Keys.TAB)
        except Exception:
            pass

        wait_ui5_idle(self.driver, timeout=el._timeout)
        self._wait_not_busy(el._timeout)

        # 3) Pre-submit validation
        err = self._has_validation_errors()
        if err:
            snap = self._screenshot("validation_error")
            return {
                "status": "validation_error",
                "error": err,
                "screenshot": snap,
                "dialog_open": self._dialog_open(),
                "dialog_text": self._capture_dialog_text() if self._dialog_open() else "",
            }

        # 4) OBJECT PAGE footer Create — click it twice (do NOT close any dialog)
        first_phase = self._click_footer_create(clicks=2)

        # If dialog popped during clicks, stop here and expose it
        if first_phase.get("dialogs"):
            snap = self._screenshot("dialog_open_after_click")
            return {
                "status": "dialog_open",
                "footer_clicks": first_phase.get("clicks", 0),
                "intermediate_toasts": first_phase.get("toasts", []),
                "dialog_open": True,
                "dialog_text": first_phase["dialogs"][-1],
                "screenshot": snap,
            }

        # 5) Wait for toast or return to list or dialog
        final_phase = self._wait_for_success_toast_or_list(timeout=max(el._timeout, 25))
        snap = self._screenshot("after_create")

        # If a dialog is open now, do NOT close it; return immediately
        if final_phase.get("dialog"):
            return {
                "status": "dialog_open",
                "footer_clicks": first_phase.get("clicks", 0),
                "intermediate_toasts": first_phase.get("toasts", []),
                "toast": final_phase.get("toast", ""),
                "dialog_open": True,
                "dialog_text": final_phase["dialog"],
                "screenshot": snap,
            }

        # Final validation check (still on object page)
        err2 = self._has_validation_errors()
        info = {
            "status": "created" if final_phase.get("at_list") or final_phase.get("toast") else "unknown",
            "footer_clicks": first_phase.get("clicks", 0),
            "intermediate_toasts": first_phase.get("toasts", []),
            "toast": final_phase.get("toast", ""),
            "at_list": final_phase.get("at_list", False),
            "dialog_open": False,
            "dialog_text": "",
            "screenshot": snap,
        }
        if err2:
            info["status"] = "validation_error"
            info["validation_after"] = err2
        return info


# pages\CurrencyExchangeRates\selectors.py

# pages/CurrencyExchangeRates/selectors.py

# App root hash (used to deep-link back to the list)
APP_HASH = "#Currency-maintainExchangeRates"

# LIST PAGE: Create button in the list report toolbar (robust locator by BDI text)
CREATE_BUTTON_XPATH = "//bdi[normalize-space()='Create']/ancestor::button[1]"

# Object Page fields – match by stable tail fragments in IDs.
EXCH_TYPE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateTypeForEdit::Field-input-inner')+1)="
    "'ExchangeRateTypeForEdit::Field-input-inner']"
)

FROM_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('SourceCurrencyForEdit::Field-input-inner')+1)="
    "'SourceCurrencyForEdit::Field-input-inner']"
)

TO_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('TargetCurrencyForEdit::Field-input-inner')+1)="
    "'TargetCurrencyForEdit::Field-input-inner']"
)

VALID_FROM_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')+1)="
    "'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner']"
)

# Quotation combobox (inner input)
QUOTATION_INNER_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-inner')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-inner']"
)

# Quotation dropdown arrow (to open popup)
QUOTATION_ARROW_BTN_XPATH = (
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']/ancestor::button[1] | "
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']"
)

# Quotation option in the popup by visible text (Direct/Indirect)
# Use `{TEXT}` placeholder with .format(TEXT=...)
QUOTATION_OPTION_BY_TEXT_XPATH = (
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//bdi[normalize-space()='{TEXT}']/ancestor::li[1] | "
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//span[normalize-space()='{TEXT}']/ancestor::li[1]"
)

EXCH_RATE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('AbsoluteExchangeRate::Field-input-inner')+1)="
    "'AbsoluteExchangeRate::Field-input-inner']"
)

# OBJECT PAGE footer "Create" (…--activate) button
ACTIVATE_CREATE_BTN_XPATH = (
    "//button[substring(@id,string-length(@id)-string-length('--activate')+1)='--activate' "
    " and .//bdi[normalize-space()='Create']]"
)

# Fallback form action buttons
FORM_CREATE_OR_SAVE_BTN_XPATH = (
    "("
    "//bdi[normalize-space()='Create']/ancestor::button[1] | "
    "//bdi[normalize-space()='Save']/ancestor::button[1]"
    ")[1]"
)

# Message toast (transient) and validation/error detection
MESSAGE_TOAST_CSS = ".sapMMessageToast"
ANY_INVALID_INPUT_XPATH = "//*[(@aria-invalid='true') and (self::input or self::textarea)]"
ANY_ERROR_WRAPPER_XPATH = "//*[contains(@class,'sapMInputBaseContentWrapperError')]"

# Generic dialog detection (we will NOT close it automatically)
DIALOG_ROOT_CSS = "div[role='dialog']"
DIALOG_OK_BTN_XPATH = (
    "("
    "//div[@role='dialog']//bdi[normalize-space()='OK']/ancestor::button[1] | "
    "//div[@role='dialog']//bdi[normalize-space()='Create']/ancestor::button[1] | "
    "//div[@role='dialog']//bdi[normalize-space()='Save']/ancestor::button[1]"
    ")[1]"
)


# pages\CurrencyExchangeRates\__init__.py



# pages\Index\page.py

# pages/Index/page.py
from core.base import Page
from services.ui import wait_ui5_idle
from .PurchasingTab.element import PurchasingTab
from .ProcurementOverviewTile.element import ProcurementOverviewTile

class IndexPage(Page):
    """Fiori Launchpad 'Shell-home' landing."""

    def ensure_home(self):
        wait_ui5_idle(self.driver)

    def to_purchasing(self):
        PurchasingTab(self.driver).click()
        wait_ui5_idle(self.driver)

    def open_procurement_overview(self):
        ProcurementOverviewTile(self.driver).click()
        wait_ui5_idle(self.driver)


# pages\Index\__init__.py



# pages\Login\page.py

from core.base import Page
from services.config import config
from .elements.Username.element import Username
from .elements.Password.element import Password
from .elements.Submit.element import Submit

class LoginPage(Page):
    def go(self):
        self.open(config()["SAP_URL"])

    def login(self, username: str, password: str):
        self.go()
        Username(self.driver).set(username)
        Password(self.driver).set(password)
        Submit(self.driver).click()
        # Post-click, S/4HANA may keep same URL but replace DOM; verification is in services.ui


# pages\Login\__init__.py



# pages\Shell\__init__.py



# pages\Index\ProcurementOverviewTile\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import GRID_READY_XPATH, BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH

class ProcurementOverviewTile(Element):
    def _find_tile_quick(self, timeout_s: float):
        wait = WebDriverWait(self.driver, timeout_s)
        # Ensure tiles grid exists
        wait.until(EC.presence_of_element_located((By.XPATH, GRID_READY_XPATH)))

        # Try a few reliable selectors with short caps
        for xp in (BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH):
            try:
                return WebDriverWait(self.driver, timeout_s).until(
                    EC.presence_of_element_located((By.XPATH, xp))
                )
            except Exception:
                continue
        return None

    def click(self):
        # Keep things brisk
        short = min(self._timeout, 6)
        wait_ui5_idle(self.driver, timeout=short)

        el = self._find_tile_quick(timeout_s=short)
        if el:
            href = (el.get_attribute("href") or "").strip()
            # Try normal click → JS click
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                WebDriverWait(self.driver, short).until(EC.element_to_be_clickable((By.XPATH, BY_TITLE_TEXT_XPATH)))
                el.click()
                wait_ui5_idle(self.driver, timeout=short)
                return
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", el)
                    wait_ui5_idle(self.driver, timeout=short)
                    return
                except Exception:
                    if href:
                        self.driver.execute_script("window.location.href = arguments[0];", href)
                        wait_ui5_idle(self.driver, timeout=self._timeout)
                        return
                    raise RuntimeError("Found tile but could not activate it.")
        else:
            # Hard fallback: navigate directly by hash (fastest)
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Procurement-displayOverviewPage';"
            )
            wait_ui5_idle(self.driver, timeout=self._timeout)


# pages\Index\ProcurementOverviewTile\selectors.py

# pages/Index/elements/ProcurementOverviewTile/selectors.py

# Grid container (ensures tiles were rendered)
GRID_READY_XPATH = ("//div[starts-with(@id,'__section') and "
                    "contains(@id,'-defaultArea-listUl') and @role='list']")

# Primary: match by the hash target in the href (most stable between tenants)
BY_HREF_XPATH = ("//a[contains(@class,'sapMGT') and "
                 "contains(@href, '#Procurement-displayOverviewPage')]")

# Secondary: visible title text (from your HTML)
BY_TITLE_TEXT_XPATH = ("//a[contains(@class,'sapMGT')]"
                       "[.//span[normalize-space()='Procurement Overview']]")

# Tertiary: aria-label starts with title
BY_ARIA_LABEL_XPATH = ("//a[contains(@class,'sapMGT') and "
                       "starts-with(normalize-space(@aria-label),'Procurement Overview')]")


# pages\Index\ProcurementOverviewTile\__init__.py



# pages\Index\PurchasingTab\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import PURCHASING_TAB_XPATH

class PurchasingTab(Element):
    def click(self):
        wait_ui5_idle(self.driver, timeout=self._timeout)
        el = self.wait_clickable(By.XPATH, PURCHASING_TAB_XPATH)
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
            el.click()
        except Exception:
            self.js_click(el)


# pages\Index\PurchasingTab\selectors.py

# pages/Index/elements/PurchasingTab/selectors.py
PURCHASING_TAB_XPATH = (
    "//div[contains(@class,'sapMITBFilterWrapper')]"
    "[.//span[normalize-space()='Purchasing']]"
)


# pages\Index\PurchasingTab\__init__.py



# pages\Login\elements\__init__.py



# pages\Login\elements\Password\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import PASSWORD_INPUT

class Password(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, PASSWORD_INPUT)
        el.clear()
        el.send_keys(value)


# pages\Login\elements\Password\selectors.py

PASSWORD_INPUT = "#j_password"


# pages\Login\elements\Password\__init__.py



# pages\Login\elements\Submit\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import SUBMIT_BTN

class Submit(Element):
    def click(self):
        el = self.wait_clickable(By.CSS_SELECTOR, SUBMIT_BTN)
        try:
            el.click()
        except Exception:
            self.js_click(el)


# pages\Login\elements\Submit\selectors.py

SUBMIT_BTN = "#logOnFormSubmit"


# pages\Login\elements\Submit\__init__.py



# pages\Login\elements\Username\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import USERNAME_INPUT

class Username(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, USERNAME_INPUT)
        el.clear()
        el.send_keys(value)


# pages\Login\elements\Username\selectors.py

USERNAME_INPUT = "#j_username"


# pages\Login\elements\Username\__init__.py



# pages\Shell\Search\element.py

# pages/Shell/Search/element.py
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import InvalidElementStateException, TimeoutException

from core.base import Element
from services.ui import wait_ui5_idle, wait_shell_search_ready, open_shell_search_via_js
from .selectors import (
    SEARCH_TOGGLE_CSS_PRIMARY,
    SEARCH_TOGGLE_CSS_ALT_HELP,
    SEARCH_TOGGLE_CSS_ALT_ARIA,
    SEARCH_INPUT_INNER_CSS,
    SUGGEST_TABLE_XPATH,
    APP_ROW_BY_TEXT_XPATH,
    APP_ROW_BY_TEXT_ALT_XPATH,
)

class ShellSearch(Element):
    def _wait_input_interactable(self):
        """
        Wait until the shell search input is present, visible, and not disabled/readOnly.
        Also ensure it has non-zero size (animation finished).
        """
        wait = WebDriverWait(self.driver, max(self._timeout, 25))
        inp = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Visible
        inp = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Enabled + not readOnly + has size
        wait.until(lambda d: d.execute_script(
            "var el=arguments[0];"
            "if(!el) return false;"
            "var cs=window.getComputedStyle(el);"
            "var ok=!!(el.offsetParent) && cs.visibility!=='hidden' && cs.display!=='none' && "
            "!el.disabled && !el.readOnly && el.clientWidth>0 && el.clientHeight>0;"
            "return ok;", inp))
        # Focus it
        try:
            inp.click()
        except Exception:
            self.js_click(inp)
        try:
            self.driver.execute_script("arguments[0].focus();", inp)
        except Exception:
            pass
        return inp

    def open_search(self):
        # Give UI5/FLP time to render the header/search
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        wait_shell_search_ready(self.driver, timeout=max(self._timeout, 25))

        # Try clicking toggle; else JS renderer fallback
        candidates = (SEARCH_TOGGLE_CSS_PRIMARY, SEARCH_TOGGLE_CSS_ALT_HELP, SEARCH_TOGGLE_CSS_ALT_ARIA)
        clicked = False
        for css in candidates:
            try:
                el = WebDriverWait(self.driver, max(self._timeout, 25)).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, css))
                )
                try:
                    el.click()
                except Exception:
                    self.js_click(el)
                clicked = True
                break
            except Exception:
                continue

        if not clicked:
            if not open_shell_search_via_js(self.driver):
                raise TimeoutError("Shell search toggle not found and JS fallback failed.")

        # Wait until input is truly interactable (not just present)
        self._wait_input_interactable()
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        return self

    def type_and_choose_app(self, query_text: str):
        inp = self._wait_input_interactable()

        # Clear safely
        try:
            inp.clear()
        except InvalidElementStateException:
            # JS clear fallback
            self.driver.execute_script(
                "arguments[0].value=''; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp
            )

        # Type the query; if Selenium send_keys bounces, use JS then send ENTER to trigger suggestions
        try:
            inp.send_keys(query_text)
        except InvalidElementStateException:
            self.driver.execute_script(
                "arguments[0].value=arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp, query_text
            )
            inp.send_keys(Keys.ENTER)

        # Wait for suggestions table to show up
        wait = WebDriverWait(self.driver, max(self._timeout, 25))
        try:
            wait.until(EC.presence_of_element_located((By.XPATH, SUGGEST_TABLE_XPATH)))
        except TimeoutException:
            # If suggestions didn't appear, fallback: open the app directly by intent hash
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
            )
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
            return self

        # Click the suggestion row (exact text), else fallback to contains()
        for xp in (APP_ROW_BY_TEXT_XPATH, APP_ROW_BY_TEXT_ALT_XPATH):
            try:
                row = wait.until(EC.element_to_be_clickable((By.XPATH, xp)))
                try:
                    row.click()
                except Exception:
                    self.js_click(row)
                wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
                return self
            except TimeoutException:
                continue

        # Last resort: deep-link by hash
        self.driver.execute_script(
            "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
        )
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        return self


# pages\Shell\Search\selectors.py

# pages/Shell/Search/selectors.py

# Shell search toggle (try a few stable variants)
SEARCH_TOGGLE_CSS_PRIMARY = "a#sf.sapUshellShellHeadItm"
SEARCH_TOGGLE_CSS_ALT_HELP = "a.sapUshellShellHeadItm[data-help-id='shellHeader-search']"
SEARCH_TOGGLE_CSS_ALT_ARIA = "a.sapUshellShellHeadItm[role='button'][aria-label*='Search']"

# The input that appears after opening search (robust id pattern)
SEARCH_INPUT_INNER_CSS = "input[id*='searchFieldInShell'][id$='-inner']"

# Suggestion table + target row
SUGGEST_TABLE_XPATH = "//table[contains(@id,'searchFieldInShell-input-popup-table-listUl')]"
# Prefer exact text; fall back to contains if localized slightly
APP_ROW_BY_TEXT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[normalize-space()='Currency Exchange Rates']/ancestor::*[self::tr or self::li][1]"
)
APP_ROW_BY_TEXT_ALT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[contains(normalize-space(),'Currency Exchange Rate')]/ancestor::*[self::tr or self::li][1]"
)


# pages\Shell\Search\__init__.py



## .txt / .csv / .json files (names only)

requirements.txt
snapshot.txt