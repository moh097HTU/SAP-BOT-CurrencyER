    ================  DIRECTORY TREE  ================
    SAP-BOT - Currency - Test
    ├── core
    │   ├── __init__.py
    │   └── base.py
    ├── downloads
    │   └── fallback-1758975352
    │       └── Exchange Rates.xlsx
    ├── pages
    │   ├── CurrencyExchangeRates
    │   │   ├── elements
    │   │   │   ├── Dialog
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── DraftFinder
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── ExcelExport
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Factors
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Fields
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Footer
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Header
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── ListToolbar
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Messages
    │   │   │   │   └── element.py
    │   │   │   ├── Quotation
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Rate
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── SideColumn
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Status
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Toast
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Validation
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   └── __init__.py
    │   │   ├── __init__.py
    │   │   ├── page.py
    │   │   └── selectors.py
    │   ├── Index
    │   │   ├── ProcurementOverviewTile
    │   │   │   ├── __init__.py
    │   │   │   ├── element.py
    │   │   │   └── selectors.py
    │   │   ├── PurchasingTab
    │   │   │   ├── __init__.py
    │   │   │   ├── element.py
    │   │   │   └── selectors.py
    │   │   ├── __init__.py
    │   │   └── page.py
    │   ├── Login
    │   │   ├── elements
    │   │   │   ├── Password
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Submit
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   ├── Username
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── element.py
    │   │   │   │   └── selectors.py
    │   │   │   └── __init__.py
    │   │   ├── __init__.py
    │   │   └── page.py
    │   ├── Shell
    │   │   ├── Search
    │   │   │   ├── __init__.py
    │   │   │   ├── element.py
    │   │   │   └── selectors.py
    │   │   └── __init__.py
    │   ├── __init__.py
    │   └── snapshot.txt
    ├── routes
    │   ├── __init__.py
    │   ├── auth.py
    │   ├── currency.py
    │   ├── drafts.py
    │   └── fallback.py
    ├── services
    │   ├── __init__.py
    │   ├── auth.py
    │   ├── commit.py
    │   ├── config.py
    │   ├── daily.py
    │   ├── drafts_service.py
    │   ├── driver.py
    │   ├── fallback_service.py
    │   ├── notify.py
    │   ├── reporting.py
    │   ├── runner.py
    │   ├── safe.py
    │   ├── schemas.py
    │   ├── tracking.py
    │   ├── ui.py
    │   └── worker.py
    ├── .env
    ├── .gitignore
    ├── main.py
    ├── README.md
    ├── requirements.txt
    ├── run_demo.py
    └── snapshot.txt

    ================  FILE CONTENTS  =================

    # .env

    #SAP_URL=https://my413369.s4hana.cloud.sap/ui#Shell-home
    #SAP_USERNAME=y.ghanem@esnadinternational.com
    #SAP_PASSWORD=Esnadinternational020

    SAP_URL=https://my417424.s4hana.cloud.sap/ui#Shell-home
    SAP_USERNAME=SAP10000
    SAP_PASSWORD=+-*/321zxc

    HEADLESS=False
    EXPLICIT_WAIT_SECONDS=7
    PAGELOAD_TIMEOUT_SECONDS=60
    KEEP_BROWSER=False
    SCREENSHOT_PATH=after_click.png

    # How many parallel browsers to run
    NUM_WORKERS=2

    # How many workers may login at the same time (protect IdP)
    LOGIN_CONCURRENCY=2

    # Where to store per-worker Chrome profiles
    CHROME_USER_DATA_BASE=chrome_profile

    # Kill-and-recover if a single item takes longer than this
    WATCHDOG_SECONDS=4000

    COMMIT_CONCURRENCY=1

    ################ EMAIL SETTINGS ################
    EMAIL_ENABLED=true
    OUTLOOK_TENANT_ID=mail.alghanem.com.jo
    OUTLOOK_CLIENT_ID=al-ghanem.com\m.almasri
    OUTLOOK_CLIENT_SECRET=MKI*UJmki8uj
    OUTLOOK_SENDER=m.almasri@alghanem.com.jo
    OUTLOOK_TO=m.almasri@alghanem.com.jo
    OUTLOOK_CC=
    EMAIL_MAX_ATTACH_MB=5
    REPORTS_DIR=reports
    ###################################################
    LOCK_RETRY_MAX=3
    LOCK_RETRY_DELAY_SEC=8

    TRACK_DIR=WebService/TrackDrivers
    TRACK_FINISHED_DIR=WebService/TrackFinished
    TRACK_LIVE_MAX=10


    # .gitignore

    __pycache__/
    *.py[cod]
    .env
    .venv/
    venv/
    env/
    .chromedriver/
    chrome_profile/
    .DS_Store
    *.log
    *.png
    reports/
    TrackDrivers/

    # main.py

    from fastapi import FastAPI
    from routes import router as api_router

    app = FastAPI(title="AIP-BOT API", version="1.0")
    app.include_router(api_router)


    # README.md

    uvicorn main:app --host 0.0.0.0 --port 8000 --timeout-keep-alive 1200 --log-level info




    # Force pull repo steps
    ## Make sure you’re on the branch you want (e.g. main)
    git checkout main

    ## Fetch latest from remote
    git fetch origin

    ## Reset local branch to be identical to remote
    git reset --hard origin/main

    ## Clean up untracked files & dirs (optional but ensures exact match)
    git clean -fd


    # run_demo.py

    # run_demo.py
    from services.config import config
    from services.driver import get_driver
    from services.auth import login
    from services.ui import wait_for_shell_home, wait_ui5_idle, wait_url_contains
    from pages.Index.page import IndexPage

    def main():
        cfg = config()
        driver = get_driver(headless=cfg["HEADLESS"])
        try:
            print("[1/3] Logging in …")
            login(driver)

            print("[2/3] Waiting for Fiori Shell …")
            ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
            print(f"Shell-home detected: {ok}")
            wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

            print("[3/3] Opening Purchasing → Procurement Overview …")
            idx = IndexPage(driver, root=cfg["SAP_URL"])
            idx.to_purchasing()
            idx.open_procurement_overview()
            wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

            # confirm navigation by hash
            if not wait_url_contains(driver, "#Procurement-displayOverviewPage", cfg["EXPLICIT_WAIT_SECONDS"]):
                print("[WARN] Did not see target hash yet; UI might still be loading.")
            input("\n✅ Navigated. Press Enter to close…")
        finally:
            if not cfg["KEEP_BROWSER"]:
                driver.quit()

    if __name__ == "__main__":
        main()


    # core\base.py

    from __future__ import annotations
    from dataclasses import dataclass
    from typing import Optional, Tuple

    from selenium.webdriver.common.by import By
    from selenium.webdriver.remote.webdriver import WebDriver
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    from services.config import config

    def fluent_wait(driver: WebDriver, timeout: float, poll: float = 0.25, ignored_exceptions: tuple = ()):
        """
        Thin helper for Selenium's fluent wait (custom poll interval + ignored exceptions).
        """
        return WebDriverWait(driver, timeout, poll_frequency=poll, ignored_exceptions=ignored_exceptions)

    def _all_frames(driver: WebDriver):
        try:
            return driver.find_elements(By.CSS_SELECTOR, "iframe, frame")
        except Exception:
            return []

    def _scan_frames_for(driver: WebDriver, locator: Tuple[str, str], timeout: int):
        """
        Fast path: look in default content first (with a very short wait).
        Only then peek into iframes with a tiny per-frame cap.
        """
        # 1) Default content (quick)
        driver.switch_to.default_content()
        try:
            return WebDriverWait(driver, min(3, timeout)).until(
                EC.presence_of_element_located(locator)
            )
        except Exception:
            pass

        # 2) Light iframe sweep (FLP typically doesn't need this)
        frames = _all_frames(driver)
        per_frame = 1.5  # seconds max per frame
        for f in frames:
            try:
                driver.switch_to.default_content()
                driver.switch_to.frame(f)
                el = WebDriverWait(driver, per_frame).until(
                    EC.presence_of_element_located(locator)
                )
                return el
            except Exception:
                continue

        driver.switch_to.default_content()
        raise TimeoutError(f"Element not found for {locator}")

    @dataclass
    class Element:
        driver: WebDriver
        timeout: Optional[int] = None

        def __post_init__(self):
            if self.timeout is None:
                try:
                    self.timeout = config()["EXPLICIT_WAIT_SECONDS"]
                except Exception:
                    self.timeout = 30

        @property
        def _timeout(self) -> int:
            return self.timeout or config()["EXPLICIT_WAIT_SECONDS"]

        def find(self, by: By, value: str):
            return _scan_frames_for(self.driver, (by, value), self._timeout)

        def wait_visible(self, by: By, value: str):
            el = _scan_frames_for(self.driver, (by, value), self._timeout)
            return WebDriverWait(self.driver, self._timeout).until(EC.visibility_of(el))

        def wait_clickable(self, by: By, value: str):
            _ = _scan_frames_for(self.driver, (by, value), self._timeout)
            return WebDriverWait(self.driver, self._timeout).until(EC.element_to_be_clickable((by, value)))

        def js_click(self, el) -> None:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
            self.driver.execute_script("arguments[0].click();", el)

    class Page:
        def __init__(self, driver: WebDriver, root: Optional[str] = None):
            self.driver = driver
            self.root = root

        def open(self, url: str):
            if self.root and not url.lower().startswith(("http://", "https://")):
                url = self.root.rstrip("/") + "/" + url.lstrip("/")
            self.driver.get(url)

        def ensure_url_contains(self, needle: str, timeout: Optional[int] = None):
            t = timeout or config()["EXPLICIT_WAIT_SECONDS"]
            WebDriverWait(self.driver, t).until(
                lambda d: needle.lower() in (d.current_url or "").lower()
            )


    # core\__init__.py



    # pages\__init__.py



    # routes\auth.py

    from fastapi import APIRouter
    from services.driver import get_driver
    from services.auth import login
    from services.config import config
    from services.ui import wait_for_shell_home

    router = APIRouter()

    @router.get("/auth/test-login")
    async def test_login():
        cfg = config()
        driver = get_driver(headless=cfg["HEADLESS"])
        try:
            login(driver)
            ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
            return {
                "ok": ok,
                "current_url": driver.current_url,
            }
        except Exception as e:
            return {"ok": False, "error": str(e)}
        finally:
            if not cfg["KEEP_BROWSER"]:
                driver.quit()


    # routes\currency.py

    # routes/currency.py
    from __future__ import annotations

    import logging
    import time
    import uuid
    from datetime import datetime
    from pathlib import Path
    from typing import List, Dict, Any

    from fastapi import APIRouter
    from fastapi.responses import StreamingResponse

    from services.config import config
    from services.schemas import ExchangeRateItem
    from services.runner import BatchRunner
    from services.reporting import ensure_reports_dir, write_json, write_failed_csv
    from services.daily import finalize_batch_tracking, prune_live_trackers, daily_rollup_collect
    from services.tracking import read_live_status_summary, PENDING, DONE, SKIPPED

    log = logging.getLogger("sapbot")
    if not log.handlers:
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s [%(levelname)s] %(threadName)s %(message)s"
        )

    router = APIRouter()

    @router.post("/currency/exchange-rates/batch")
    async def create_exchange_rates(items: List[ExchangeRateItem]) -> Dict[str, Any]:
        cfg = config()
        workers = int(cfg.get("NUM_WORKERS", 6)) or 6

        received_count = len(items)
        batch_id = datetime.now().strftime("%Y%m%d-%H%M%S") + "-" + str(uuid.uuid4())[:8]
        reports_root = ensure_reports_dir(Path(cfg.get("REPORTS_DIR") or "reports"))

        runner = BatchRunner(cfg=cfg, batch_id=batch_id, reports_root=reports_root, workers=workers)
        runner.write_request_summary([it.dict() for it in items[:5]], workers)

        start_ts = time.time()
        result = runner.run_force_all_done(items)
        duration_sec = time.time() - start_ts

        # Persist standard artifacts
        result_path = Path(runner.batch_dir) / "result.json"
        failed_json_path = Path(runner.batch_dir) / "failed.json"
        failed_csv_path = Path(runner.batch_dir) / "failed.csv"

        # "Failures" now means anything not Done (i.e., Pending or errors mapped to Pending)
        failed_rows = [r for r in result.get("results", []) if (r.get("status") or "").strip().lower() not in ("created", "skipped")]
        write_json(result_path, result)
        write_json(failed_json_path, failed_rows)
        write_failed_csv(failed_csv_path, failed_rows)

        # Move trackers to finished/<day>/<batch_id>, prune live, and (optionally) daily rollup
        finalize_batch_tracking(batch_id, runner.track_dir)
        try:
            prune_live_trackers()
        except Exception:
            pass
        try:
            if cfg.get("DAILY_REPORTS_ENABLED"):
                _ = daily_rollup_collect()  # compile daily summary/failed.csv
        except Exception:
            pass

        # Strong guarantee: API is "done" only if live tracker summary shows zero Pending
        try:
            live = read_live_status_summary(track_dir=Path(runner.batch_dir).parent.parent / "live" / batch_id)
            # if we moved it already, read_live_status_summary may not find live dir; in that case, trust result["pending"]
        except Exception:
            live = {"Pending": result.get("pending", 0)}

        out = {
            **result,
            "duration_sec": round(duration_sec, 2),
            "reports": {
                "dir": str(runner.batch_dir),
                "result_json": str(result_path),
                "failed_json": str(failed_json_path),
                "failed_csv": str(failed_csv_path),
            },
            "api_ok": (result.get("pending", 0) == 0),  # hardened: only Done/Skipped left
        }
        return out

    @router.post("/currency/exchange-rates/batch/stream")
    async def create_exchange_rates_stream(items: List[ExchangeRateItem]):
        cfg = config()
        workers = int(cfg.get("NUM_WORKERS", 6)) or 6

        batch_id = datetime.now().strftime("%Y%m%d-%H%M%S") + "-" + str(uuid.uuid4())[:8]
        reports_root = ensure_reports_dir(Path(cfg.get("REPORTS_DIR") or "reports"))

        runner = BatchRunner(cfg=cfg, batch_id=batch_id, reports_root=reports_root, workers=workers)
        runner.write_request_summary([it.dict() for it in items[:5]], workers)

        HEARTBEAT_SEC = int(cfg.get("STREAM_HEARTBEAT_SEC", 5))

        def _gen():
            for line in runner.stream_events(items, heartbeat_sec=HEARTBEAT_SEC):
                yield line

        return StreamingResponse(_gen(), media_type="application/x-ndjson")


    # routes\drafts.py

    # routes/drafts.py
    from __future__ import annotations

    from datetime import datetime, date
    from typing import Dict, Any, Optional

    from fastapi import APIRouter, Query, Body, HTTPException
    from pydantic import BaseModel

    from services.drafts_service import run_delete_drafts_range

    # Mount under /currency/exchange-rates
    router = APIRouter(prefix="/currency/exchange-rates")

    # ---------- Helpers ----------
    def _parse_iso(s: str) -> date:
        try:
            return datetime.strptime(s, "%Y-%m-%d").date()
        except Exception:
            raise HTTPException(status_code=422, detail=f"Date must be YYYY-MM-DD, got {s!r}")

    class DeleteDraftsRequest(BaseModel):
        day_from: str  # "YYYY-MM-DD"
        day_to: str    # "YYYY-MM-DD"

    # ---------- Unified endpoint (query OR body) ----------
    @router.post("/drafts/delete")
    async def delete_drafts(
        # Query style: /currency/exchange-rates/drafts/delete?date_from=YYYY-MM-DD&date_to=YYYY-MM-DD
        date_from: Optional[str] = Query(default=None),
        date_to: Optional[str]   = Query(default=None),
        # Body style: {"day_from":"YYYY-MM-DD","day_to":"YYYY-MM-DD"}
        body: Optional[DeleteDraftsRequest] = Body(default=None),
    ) -> Dict[str, Any]:

        # Prefer explicit query params if provided; else fall back to JSON body
        if date_from and date_to:
            df = _parse_iso(date_from)
            dt = _parse_iso(date_to)
        elif body is not None:
            df = _parse_iso(body.day_from)
            dt = _parse_iso(body.day_to)
        else:
            raise HTTPException(
                status_code=400,
                detail="Provide either query params (?date_from=YYYY-MM-DD&date_to=YYYY-MM-DD) "
                    "or JSON body {\"day_from\":\"YYYY-MM-DD\",\"day_to\":\"YYYY-MM-DD\"}."
            )

        # Run the deletion (inclusive). If df == dt, only that day is processed.
        return run_delete_drafts_range(df, dt)


    # routes\fallback.py

    # routes/fallback.py
    from __future__ import annotations

    from datetime import datetime, date
    from typing import Dict, Any, Optional

    from fastapi import APIRouter, Query, HTTPException

    from services.fallback_service import run_collect_missing_range

    router = APIRouter(prefix="/currency/exchange-rates/fallback")


    def _parse_iso(s: str) -> date:
        try:
            return datetime.strptime(s, "%Y-%m-%d").date()
        except Exception:
            raise HTTPException(status_code=422, detail=f"Date must be YYYY-MM-DD, got {s!r}")


    @router.post("/collect-missing")
    async def collect_missing(
        date_from: Optional[str] = Query(default=None),
        date_to: Optional[str] = Query(default=None),
    ) -> Dict[str, Any]:
        if not date_from or not date_to:
            raise HTTPException(
                status_code=400,
                detail="Provide ?date_from=YYYY-MM-DD&date_to=YYYY-MM-DD",
            )

        df = _parse_iso(date_from)
        dt = _parse_iso(date_to)
        return run_collect_missing_range(df, dt)


    # routes\__init__.py

    # routes/__init__.py
    from fastapi import APIRouter
    from . import auth
    from . import currency
    from .drafts import router as drafts_router
    from .fallback import router as fallback_router   # <-- add this

    router = APIRouter()
    router.include_router(auth.router, tags=["auth"])
    router.include_router(currency.router, tags=["currency"])
    router.include_router(drafts_router, tags=["drafts"])
    router.include_router(fallback_router, tags=["fallback"])  # <-- add this


    # services\auth.py

    from services.config import config
    from pages.Login.page import LoginPage
    from services.ui import wait_for_shell_home

    def login(driver) -> None:
        cfg = config()
        LoginPage(driver).login(cfg["SAP_USERNAME"], cfg["SAP_PASSWORD"])
        # Let caller verify with wait_for_shell_home
        wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])


    # services\commit.py

    # services/commit.py
    from __future__ import annotations
    import os
    import threading
    from contextlib import contextmanager

    # How many concurrent "Create/Activate" commits may run at once?
    # Default = 1 (fully serialized). You can set COMMIT_CONCURRENCY=2..N if SAP allows it.
    _COMMIT_CONCURRENCY = max(1, int(os.getenv("COMMIT_CONCURRENCY", "1")))
    _SEM = threading.Semaphore(_COMMIT_CONCURRENCY)

    @contextmanager
    def commit_gate():
        """
        Narrow critical section for the exact click(s) that commit/activate
        the object. Everything else (typing, navigation) runs concurrently.
        """
        _SEM.acquire()
        try:
            yield
        finally:
            _SEM.release()


    # services\config.py

    # services/config.py
    from dotenv import load_dotenv
    import os

    load_dotenv()

    _BOOL = {"1", "true", "yes", "on", "y", "t"}

    def _as_bool(v: str, default=False) -> bool:
        if v is None:
            return default
        return v.strip().lower() in _BOOL

    def _as_int(v: str, default: int) -> int:
        try:
            return int(v)
        except Exception:
            return default

    def config():
        sap_url = os.getenv("SAP_URL", "https://my413369.s4hana.cloud.sap/ui#Shell-home")
        return {
            # SAP / browser
            "SAP_URL": sap_url,
            "ROOT_URL": sap_url,
            "SAP_USERNAME": os.getenv("SAP_USERNAME", ""),
            "SAP_PASSWORD": os.getenv("SAP_PASSWORD", ""),

            "HEADLESS": _as_bool(os.getenv("HEADLESS", "false")),
            "EXPLICIT_WAIT_SECONDS": _as_int(os.getenv("EXPLICIT_WAIT_SECONDS", "30"), 30),
            "PAGELOAD_TIMEOUT_SECONDS": _as_int(os.getenv("PAGELOAD_TIMEOUT_SECONDS", "90"), 90),
            "KEEP_BROWSER": _as_bool(os.getenv("KEEP_BROWSER", "true")),

            # Multithreading / pacing
            "NUM_WORKERS": _as_int(os.getenv("NUM_WORKERS", "4"), 4),
            "LOGIN_CONCURRENCY": _as_int(os.getenv("LOGIN_CONCURRENCY", "2"), 2),
            "WATCHDOG_SECONDS": _as_int(os.getenv("WATCHDOG_SECONDS", "2000"), 2000),
            "CHROME_USER_DATA_BASE": os.getenv("CHROME_USER_DATA_BASE", "chrome_profile"),

            # Reporting
            "REPORTS_DIR": os.getenv("REPORTS_DIR", "reports"),
            "DAILY_REPORTS_ENABLED": _as_bool(os.getenv("DAILY_REPORTS_ENABLED", "true")),
            "NUM_LIVE_TRACKERS": _as_int(os.getenv("NUM_LIVE_TRACKERS", "8"), 8),  # keep last N live trackers

            # Email (Outlook via Microsoft Graph)
            "EMAIL_ENABLED": _as_bool(os.getenv("EMAIL_ENABLED", "false")),
            "OUTLOOK_TENANT_ID": os.getenv("OUTLOOK_TENANT_ID", ""),
            "OUTLOOK_CLIENT_ID": os.getenv("OUTLOOK_CLIENT_ID", ""),
            "OUTLOOK_CLIENT_SECRET": os.getenv("OUTLOOK_CLIENT_SECRET", ""),
            "OUTLOOK_SENDER": os.getenv("OUTLOOK_SENDER", ""),
            "OUTLOOK_TO": os.getenv("OUTLOOK_TO", ""),
            "OUTLOOK_CC": os.getenv("OUTLOOK_CC", ""),
            "EMAIL_MAX_ATTACH_MB": _as_int(os.getenv("EMAIL_MAX_ATTACH_MB", "3"), 3),

            # Legacy lock/ retry knobs (kept)
            "LOCK_RETRY_MAX": _as_int(os.getenv("LOCK_RETRY_MAX", "3"), 3),
            "LOCK_RETRY_DELAY_SEC": _as_int(os.getenv("LOCK_RETRY_DELAY_SEC", "8"), 8),

            # Tracking
            "TRACK_DIR": os.getenv("TRACK_DIR", "WebService/TrackDrivers"),

            # Force-all-done loop
            "FORCE_ALL_DONE_ENABLED": _as_bool(os.getenv("FORCE_ALL_DONE_ENABLED", "true")),
            "FORCE_ALL_DONE_MAX_ROUNDS": _as_int(os.getenv("FORCE_ALL_DONE_MAX_ROUNDS", "25"), 25),
            "FORCE_ALL_DONE_MAX_MINUTES": _as_int(os.getenv("FORCE_ALL_DONE_MAX_MINUTES", "60"), 60),
            "FORCE_ALL_DONE_BASE_SLEEP_SEC": _as_int(os.getenv("FORCE_ALL_DONE_BASE_SLEEP_SEC", "8"), 8),

            # Page commit flow
            "LOCK_MAX_RETRIES": _as_int(os.getenv("LOCK_MAX_RETRIES", "3"), 3),
        }

    # Legacy convenience
    ROOT_URL = config()["ROOT_URL"]
    EXPLICIT_WAIT_SEC = config()["EXPLICIT_WAIT_SECONDS"]


    # services\daily.py

    # services/daily.py
    from __future__ import annotations

    from pathlib import Path
    from typing import Dict, Any, List
    import json
    from datetime import datetime

    from services.config import config
    from services.tracking import move_live_to_finished, prune_live_trackers_keep_last_n, finished_dir_for_day

    def finalize_batch_tracking(batch_id: str, track_dir: Path | None = None) -> Dict[str, Any]:
        """
        If batch is fully processed (no Pending), move its tracker to Finished/YYYY-MM-DD.
        """
        return move_live_to_finished(batch_id=batch_id, track_dir=track_dir)

    def prune_live_trackers(keep_n: int | None = None) -> Dict[str, Any]:
        """
        Prune live trackers, keeping at most keep_n (defaults to NUM_LIVE_TRACKERS or TRACK_LIVE_MAX or 10).
        """
        cfg = config()
        default_keep = cfg.get("NUM_LIVE_TRACKERS", cfg.get("TRACK_LIVE_MAX", 10))
        kn = keep_n if keep_n is not None else int(default_keep)
        return prune_live_trackers_keep_last_n(keep_n=kn)

    def daily_rollup_collect(day: str | None = None) -> Dict[str, Any]:
        """
        Return a parsed list of rollup entries for a given day (default = today).
        """
        d = day or datetime.now().strftime("%Y-%m-%d")
        from services.reporting import _reports_root  # local import to avoid cycle
        path = _reports_root() / "daily" / d / "rollup.ndjson"
        if not path.exists():
            return {"ok": True, "day": d, "items": []}
        items: List[Dict[str, Any]] = []
        with path.open("r", encoding="utf-8") as f:
            for line in f:
                s = line.strip()
                if not s:
                    continue
                try:
                    items.append(json.loads(s))
                except Exception:
                    pass
        return {"ok": True, "day": d, "items": items}


    # services\drafts_service.py

    # services/drafts_service.py
    from __future__ import annotations

    import logging
    from datetime import date, timedelta
    from typing import Dict, Any

    from services.config import config
    from services.driver import get_driver
    from services.auth import login
    from services.ui import wait_for_shell_home, wait_ui5_idle
    from pages.Shell.Search.element import ShellSearch
    from pages.CurrencyExchangeRates.page import CurrencyExchangeRatesPage
    from pages.CurrencyExchangeRates.elements.DraftFinder import DraftFinder

    log = logging.getLogger("sapbot")


    def _ddmmyyyy(d: date) -> str:
        return f"{d.day:02d}.{d.month:02d}.{d.year:04d}"


    def _daterange_inclusive(d0: date, d1: date):
        cur = d0
        while cur <= d1:
            yield cur
            cur += timedelta(days=1)


    def run_delete_drafts_range(day_from: date, day_to: date) -> Dict[str, Any]:
        """
        For each day in [day_from, day_to]:
        - open 'Currency Exchange Rates' app
        - set filter 'Exchange Rate Effective Date' to DD.MM.YYYY and press Enter
        - (optionally pre-scroll) to trigger row rendering
        - delete all currently visible draft rows (one-by-one)
        Returns:
        {
            "ok": bool,
            "days_processed": int,
            "total_deleted": int,
            "per_day": [
            {
                "date": "YYYY-MM-DD",
                "deleted": int,
                "attempts": int,
                "sample": [ "<from->to @ date>", ... ],  # <= up to 10 items if your DraftFinder returns it
                "ok": bool,
                "why": "reason-if-any"
            },
            ...
            ],
            "error": "...optional..."
        }
        """
        cfg = config()
        drv = None
        summary: Dict[str, Any] = {
            "ok": False,
            "days_processed": 0,
            "total_deleted": 0,
            "per_day": [],
        }

        try:
            # Start browser + login + shell
            drv = get_driver(headless=cfg["HEADLESS"])
            login(drv)
            wait_for_shell_home(drv, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
            wait_ui5_idle(drv, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

            # Navigate to app
            ShellSearch(drv).open_search().type_and_choose_app("Currency Exchange Rates")
            wait_ui5_idle(drv, timeout=30)
            CurrencyExchangeRatesPage(drv).ensure_in_app(max_attempts=3, settle_each=8)

            # Normalize range order
            df = min(day_from, day_to)
            dt = max(day_from, day_to)

            total_deleted = 0
            days_count = 0
            per_day_stats = []

            finder = DraftFinder(drv)

            for day in _daterange_inclusive(df, dt):
                days_count += 1
                day_iso = str(day)          # YYYY-MM-DD for API consumers/logs
                date_str = _ddmmyyyy(day)   # DD.MM.YYYY for UI filter

                # Set date and apply
                ok = finder.set_effective_date_and_apply(date_str, timeout=20)
                if not ok:
                    per_day_stats.append({
                        "date": day_iso,
                        "deleted": 0,
                        "attempts": 0,
                        "sample": [],
                        "ok": False,
                        "why": "date_set_failed"
                    })
                    continue

                # Light pre-scroll to help initial rows render
                finder.pre_scroll(times=2, settle=0.5)

                # Delete visible drafts
                sample: list[str] = []
                try:
                    # Prefer new triple-return signature if you added it:
                    #   deleted, attempts, sample = finder.delete_visible_drafts(...)
                    res = finder.delete_visible_drafts(per_click_timeout=16)
                    if isinstance(res, (list, tuple)) and len(res) >= 3:
                        deleted, attempts, sample = res[0], res[1], list(res[2])[:10]
                    else:
                        # Backward compatibility with (deleted, attempts)
                        deleted, attempts = res  # type: ignore[misc]
                        sample = []
                except Exception as e:
                    log.error("[drafts] delete_visible_drafts failed for %s: %s: %s",
                            day_iso, type(e).__name__, e)
                    per_day_stats.append({
                        "date": day_iso,
                        "deleted": 0,
                        "attempts": 0,
                        "sample": [],
                        "ok": False,
                        "why": f"delete_failed:{type(e).__name__}"
                    })
                    continue

                total_deleted += int(deleted)
                per_day_stats.append({
                    "date": day_iso,
                    "deleted": int(deleted),
                    "attempts": int(attempts),
                    "sample": sample or [],
                    "ok": True
                })

            summary.update(
                ok=True,
                days_processed=days_count,
                total_deleted=total_deleted,
                per_day=per_day_stats,
            )
            return summary

        except Exception as e:
            log.exception("[drafts] deletion run failed")
            summary["error"] = f"{type(e).__name__}: {e}"
            return summary
        finally:
            try:
                if drv and not cfg.get("KEEP_BROWSER"):
                    drv.quit()
            except Exception:
                pass


    # services\driver.py

    # services/driver.py
    # -----------------------------------------------
    # FULL FILE (adds download_dir support & unified prefs)
    # -----------------------------------------------
    from __future__ import annotations

    import os
    import threading
    from pathlib import Path
    import shutil
    import stat
    import time
    import random
    import gc

    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.chrome.service import Service
    from selenium.common.exceptions import SessionNotCreatedException, WebDriverException
    from webdriver_manager.chrome import ChromeDriverManager

    from services.config import config

    _DRIVER_PATH_CACHE: str | None = None
    _DRIVER_INIT_LOCK = threading.Lock()

    _PROFILE_SET_LOCK = threading.Lock()
    _PROFILE_DIRS_USED: set[str] = set()

    def ensure_driver_binary_ready() -> str:
        global _DRIVER_PATH_CACHE
        if _DRIVER_PATH_CACHE:
            return _DRIVER_PATH_CACHE
        with _DRIVER_PATH_CACHE_LOCK():
            if _DRIVER_PATH_CACHE:
                return _DRIVER_PATH_CACHE
            _DRIVER_PATH_CACHE = ChromeDriverManager().install()
            return _DRIVER_PATH_CACHE

    def _DRIVER_PATH_CACHE_LOCK():
        # backward-compatible simple lock factory (kept separate in case of future refactors)
        return _DRIVER_INIT_LOCK

    def _base_profile_dir() -> Path:
        return Path(os.getenv("CHROME_USER_DATA_BASE", "chrome_profile")).resolve()

    def _register_profile_dir(p: str) -> None:
        with _PROFILE_SET_LOCK:
            _PROFILE_DIRS_USED.add(p)

    def list_profile_dirs_used() -> list[str]:
        with _PROFILE_SET_LOCK:
            return list(_PROFILE_DIRS_USED)

    def _per_thread_profile_dir() -> str:
        """
        Use a process-unique + thread-unique Chrome user-data directory to avoid
        cross-process collisions on profile locks. Format: w-<pid>-<thread_id>
        """
        base = _base_profile_dir()
        base.mkdir(parents=True, exist_ok=True)
        pid = os.getpid()
        tid = threading.get_ident()
        d = base / f"w-{pid}-{tid}"
        d.mkdir(parents=True, exist_ok=True)
        p = str(d.resolve())
        _register_profile_dir(p)
        return p

    def _random_debug_port() -> int:
        return random.randint(9223, 9550)

    def get_driver(headless: bool = True, download_dir: str | None = None) -> webdriver.Chrome:
        """
        Create a Chrome driver. If download_dir is provided, Chrome will save files there silently.
        """
        cfg = config()

        driver_path = ensure_driver_binary_ready()
        service = Service(driver_path)

        options = Options()
        if headless:
            options.add_argument("--headless=new")
        else:
            options.add_argument("--start-maximized")

        user_data_dir = _per_thread_profile_dir()
        options.add_argument(f"--user-data-dir={user_data_dir}")
        options.add_argument("--profile-directory=Default")

        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-extensions")
        options.add_argument("--disable-gpu")
        options.add_argument("--disable-features=Translate,BackForwardCache,Prerender2,VizDisplayCompositor")
        options.add_argument("--window-size=1366,768")
        options.add_argument("--lang=en-US")
        options.add_argument("--no-first-run")
        options.add_argument("--no-default-browser-check")
        options.add_argument("--log-level=3")
        options.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
        options.add_experimental_option("useAutomationExtension", False)

        # -------- unified prefs (includes optional download_dir) --------
        prefs = {
            "credentials_enable_service": False,
            "profile.password_manager_enabled": False,
        }
        if download_dir:
            dl = str(Path(download_dir).resolve())
            Path(dl).mkdir(parents=True, exist_ok=True)
            prefs.update({
                "download.default_directory": dl,
                "download.prompt_for_download": False,
                "download.directory_upgrade": True,
                "safebrowsing.enabled": True,
                "savefile.default_directory": dl,
            })
        options.add_experimental_option("prefs", prefs)
        # ---------------------------------------------------------------

        try:
            options.add_argument(f"--remote-debugging-port={_random_debug_port()}")
        except Exception:
            pass

        try:
            driver = webdriver.Chrome(service=service, options=options)
        except SessionNotCreatedException as e:
            raise RuntimeError(
                "Chrome/ChromeDriver version mismatch (SessionNotCreated). "
                "Install matching major versions of Chrome and Chromedriver. "
                f"Original: {e}"
            )
        except WebDriverException as e:
            raise RuntimeError(f"WebDriver failed to start: {type(e).__name__}: {e}")

        try:
            pl_timeout = int(cfg.get("PAGELOAD_TIMEOUT_SECONDS", 90)) or 90
            driver.set_page_load_timeout(pl_timeout)
        except Exception:
            try:
                driver.set_page_load_timeout(90)
            except Exception:
                pass

        if not headless:
            try:
                driver.maximize_window()
            except Exception:
                pass

        # Hide webdriver flag (minor hardening)
        try:
            driver.execute_cdp_cmd(
                "Page.addScriptToEvaluateOnNewDocument",
                {"source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"},
            )
        except Exception:
            pass

        try:
            setattr(driver, "_user_data_dir", user_data_dir)  # nosec
        except Exception:
            pass

        return driver

    # ---------- OS-level cleanup (best-effort) ----------

    def _safe_str(s) -> str:
        try:
            return str(s or "")
        except Exception:
            return ""

    def _cmdline_has_userdata_under_base(cmdline: list[str], base: Path) -> bool:
        b = str(base)
        for arg in cmdline or []:
            a = _safe_str(arg)
            if "--user-data-dir=" in a:
                try:
                    path = a.split("=", 1)[1]
                except Exception:
                    path = ""
                if path and Path(path).resolve().as_posix().startswith(base.as_posix()):
                    return True
        for i, a in enumerate(cmdline or []):
            if a == "--user-data-dir" and i + 1 < len(cmdline):
                path = _safe_str(cmdline[i + 1])
                if path and Path(path).resolve().as_posix().startswith(base.as_posix()):
                    return True
            if b in _safe_str(a):
                return True
        return False

    def _should_kill(proc, base: Path) -> bool:
        try:
            name = _safe_str(proc.info.get("name")).lower()
            cmd  = proc.info.get("cmdline") or []
        except Exception:
            return False

        chrome_names = {"chrome", "chrome.exe", "google-chrome", "chromium", "chromium-browser"}
        driver_names = {"chromedriver", "chromedriver.exe"}

        if name in chrome_names and _cmdline_has_userdata_under_base(cmd, base):
            return True

        if name in driver_names:
            if _cmdline_has_userdata_under_base(cmd, base):
                return True
            try:
                for child in proc.children(recursive=True):
                    try:
                        from psutil import NoSuchProcess  # type: ignore
                        cname = _safe_str(child.name()).lower()
                        ccmd  = child.cmdline() or []
                        if cname in chrome_names and _cmdline_has_userdata_under_base(ccmd, base):
                            return True
                    except Exception:
                        continue
            except Exception:
                pass
        return False

    def kill_strays() -> dict:
        try:
            import psutil  # type: ignore
        except Exception:
            return {"ok": False, "reason": "psutil_missing"}

        base = _base_profile_dir()
        killed: list[int] = []
        errs: list[dict] = []

        try:
            for proc in psutil.process_iter(["pid", "name", "cmdline"]):
                try:
                    if _should_kill(proc, base):
                        try:
                            proc.terminate()
                        except Exception:
                            pass
                        try:
                            proc.wait(timeout=1.5)
                        except Exception:
                            try:
                                proc.kill()
                            except Exception as e:
                                errs.append({"pid": proc.pid, "err": f"kill_failed:{type(e).__name__}"})
                                continue
                        killed.append(proc.pid)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
                except Exception as e:
                    errs.append({"pid": getattr(proc, "pid", -1), "err": f"{type(e).__name__}"})
                    continue
        except Exception as e:
            return {"ok": False, "reason": f"iter_failed:{type(e).__name__}"}

        return {"ok": True, "killed": killed, "errors": errs}

    # ---------- filesystem cleanup ----------

    def _on_rm_error(func, path, exc_info):
        try:
            os.chmod(path, stat.S_IWRITE)
        except Exception:
            pass
        try:
            func(path)
        except Exception:
            pass

    def _rmtree_force(p: Path, retries: int = 3, delay: float = 0.25):
        for _ in range(max(1, retries)):
            try:
                if p.exists():
                    shutil.rmtree(p, onerror=_on_rm_error)
                return
            except Exception:
                time.sleep(delay)
        try:
            if p.exists():
                shutil.rmtree(p, onerror=_on_rm_error)
        except Exception:
            pass

    def cleanup_profiles(also_base: bool = True) -> dict:
        try:
            _ = kill_strays()
        except Exception:
            pass

        deleted = []
        errors = []
        with _PROFILE_SET_LOCK:
            dirs = list(_PROFILE_DIRS_USED)
            _PROFILE_DIRS_USED.clear()
        for d in dirs:
            try:
                _rmtree_force(Path(d))
                deleted.append(d)
            except Exception as e:
                errors.append({"dir": d, "error": f"{type(e).__name__}: {e}"})

        base = _base_profile_dir()
        if also_base:
            try:
                if base.exists() and base.is_dir() and not any(base.iterdir()):
                    _rmtree_force(base)
            except Exception:
                pass

        gc.collect()
        return {"deleted": deleted, "errors": errors}


    # services\fallback_service.py

    # services/fallback_service.py
    from __future__ import annotations

    import json
    import logging
    from dataclasses import dataclass
    from datetime import date, timedelta
    from pathlib import Path
    from typing import Any, Dict, List, Optional, Tuple

    from services.config import config
    from services.driver import get_driver
    from services.auth import login
    from services.ui import wait_for_shell_home, wait_ui5_idle
    from pages.Shell.Search.element import ShellSearch
    from pages.CurrencyExchangeRates.page import CurrencyExchangeRatesPage
    from pages.CurrencyExchangeRates.elements.DraftFinder import DraftFinder
    from pages.CurrencyExchangeRates.elements.ExcelExport.element import ExcelExporter

    log = logging.getLogger("sapbot")


    # ---------- formatting helpers ----------
    def _ddmmyyyy(d: date) -> str:
        return f"{d.day:02d}.{d.month:02d}.{d.year:04d}"


    def _iso(d: date) -> str:
        return d.strftime("%Y-%m-%d")


    def _daterange_inclusive(d0: date, d1: date):
        cur = min(d0, d1)
        end = max(d0, d1)
        while cur <= end:
            yield cur
            cur = cur + timedelta(days=1)


    # ---------- IO helpers ----------
    BASE_DATA_DIR = Path("WebService") / "data"
    FALLBACK_TRACK_DIR = Path("WebService") / "TrackDrivers" / "Fallback"
    TEMP_DL_DIR = Path(config().get("REPORTS_DIR") or "reports") / "tmp_downloads"
    TEMP_DL_DIR.mkdir(parents=True, exist_ok=True)
    FALLBACK_TRACK_DIR.mkdir(parents=True, exist_ok=True)

    # --- replace old helpers with this block ---

    def _q_norm(q: str) -> str:
        """Normalize to 'Direct' or 'Indirect'."""
        q = (q or "").strip().lower()
        return "Indirect" if q.startswith("ind") else "Direct"

    def _key_tuple(r: Dict[str, Any]) -> tuple:
        """Exact-direction key used for matching."""
        return (
            (r.get("ExchangeRateType") or "").strip().upper(),
            (r.get("ValidFrom") or "").strip(),
            (r.get("FromCurrency") or "").strip().upper(),
            (r.get("ToCurrency") or "").strip().upper(),
            _q_norm(r.get("Quotation")),
        )

    def _reversed_key_tuple(r: Dict[str, Any]) -> tuple:
        """Opposite-direction key: swap currencies and flip quotation."""
        q = _q_norm(r.get("Quotation"))
        flipped_q = "Direct" if q == "Indirect" else "Indirect"
        return (
            (r.get("ExchangeRateType") or "").strip().upper(),
            (r.get("ValidFrom") or "").strip(),
            (r.get("ToCurrency") or "").strip().upper(),  # swapped
            (r.get("FromCurrency") or "").strip().upper(),  # swapped
            flipped_q,
        )

    def _json_missing_vs_excel(excel_rows: list[dict], json_rows: list[dict]) -> list[dict]:
        def _q_norm(q: str) -> str:
            q = (q or "").strip().lower()
            return "Indirect" if q.startswith("ind") else "Direct"

        def _key_tuple(r: dict) -> tuple:
            return (
                (r.get("ExchangeRateType") or "").strip().upper(),
                (r.get("ValidFrom") or "").strip(),
                (r.get("FromCurrency") or "").strip().upper(),
                (r.get("ToCurrency") or "").strip().upper(),
                _q_norm(r.get("Quotation")),
            )

        def _rev_flip_tuple(r: dict) -> tuple:
            q = _q_norm(r.get("Quotation"))
            flipped_q = "Direct" if q == "Indirect" else "Indirect"
            return (
                (r.get("ExchangeRateType") or "").strip().upper(),
                (r.get("ValidFrom") or "").strip(),
                (r.get("ToCurrency") or "").strip().upper(),
                (r.get("FromCurrency") or "").strip().upper(),
                flipped_q,
            )

        def _rev_same_tuple(r: dict) -> tuple:
            # same quotation, just swap currencies
            return (
                (r.get("ExchangeRateType") or "").strip().upper(),
                (r.get("ValidFrom") or "").strip(),
                (r.get("ToCurrency") or "").strip().upper(),
                (r.get("FromCurrency") or "").strip().upper(),
                _q_norm(r.get("Quotation")),
            )

        excel_keys: set[tuple] = set()
        for er in excel_rows or []:
            try:
                excel_keys.add(_key_tuple(er))       # exact
                excel_keys.add(_rev_flip_tuple(er))  # reverse + flipped quotation
                excel_keys.add(_rev_same_tuple(er))  # reverse + same quotation  <-- NEW
            except Exception:
                continue

        missing: list[dict] = []
        for r in json_rows or []:
            k_exact = _key_tuple(r)
            k_rev_flip = _rev_flip_tuple(r)
            k_rev_same = _rev_same_tuple(r)
            if k_exact in excel_keys or k_rev_flip in excel_keys or k_rev_same in excel_keys:
                continue
            missing.append({
                "ExchangeRateType": (r.get("ExchangeRateType") or "").strip().upper(),
                "FromCurrency": (r.get("FromCurrency") or "").strip().upper(),
                "ToCurrency": (r.get("ToCurrency") or "").strip().upper(),
                "ValidFrom": (r.get("ValidFrom") or "").strip(),
                "Quotation": _q_norm(r.get("Quotation")),
                "ExchangeRate": r.get("ExchangeRate"),
            })
        return missing

    def _read_json_payload(day_iso: str) -> Tuple[List[Dict[str, Any]], bool]:
        p = BASE_DATA_DIR / day_iso / "exchange_rates_payload.json"
        if not p.exists():
            return [], False
        try:
            rows = json.loads(p.read_text(encoding="utf-8"))
            # ensure list[dict]
            out = []
            for r in rows or []:
                if isinstance(r, dict):
                    out.append(r)
            return out, True
        except Exception:
            # File existed but parse failed; treat as empty but mark exists=True for diagnostics
            return [], True


    def _write_missing_tracker(day_iso: str, rows: List[Dict[str, Any]]) -> Path:
        out_path = FALLBACK_TRACK_DIR / f"{day_iso}.json"
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(json.dumps(rows, indent=2, ensure_ascii=False), encoding="utf-8")
        return out_path


    # ---------- Excel parsing ----------
    def _read_excel_rows(xlsx_path: Path) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Parse SAP ListReport export.

        Returns (rows, diag) where rows are normalized for matching:
        {ExchangeRateType, ValidFrom, FromCurrency, ToCurrency, Quotation, ExchangeRate}
        """
        import openpyxl

        wb = openpyxl.load_workbook(xlsx_path, data_only=True)
        ws = wb.active

        header_cells = list(next(ws.iter_rows(min_row=1, max_row=1, values_only=True)))
        headers = { (str(v).strip() if v is not None else ""): i for i, v in enumerate(header_cells) }

        def get(r, name, *alts):
            for key in (name, *alts):
                if key in headers:
                    idx = headers[key]
                    return r[idx]
            return None

        rows: List[Dict[str, Any]] = []
        for r in ws.iter_rows(min_row=2, values_only=True):
            exch_lbl = (get(r, "Exchange Rate Type") or "")
            exch_lbl = str(exch_lbl or "").strip()
            exch_code = exch_lbl[:1].upper() if exch_lbl else ""

            vf_raw = get(r, "Valid From")
            if hasattr(vf_raw, "strftime"):
                valid_from = vf_raw.strftime("%d.%m.%Y")
            else:
                valid_from = str(vf_raw or "").strip()

            # Prefer Currency Pair if present (fast path), else From/To columns
            cp = get(r, "Currency Pair")
            if cp:
                cp = str(cp).strip()
                if "/" in cp:
                    frm, to = cp.split("/", 1)
                else:
                    frm, to = cp, ""
                frm, to = (frm or "").strip(), (to or "").strip()
            else:
                frm = str(get(r, "From Currency") or "").strip()
                to = str(get(r, "To Currency") or "").strip()

            qtn = str(get(r, "Quotation") or "").strip()
            rate = get(r, "Rate 1:1", "Rate (1:1)")
            try:
                rate = float(rate)
            except Exception:
                rate = None

            # Clean currency labels like "AED (United ...)" -> "AED"
            if frm:
                frm = frm.split(" ", 1)[0].split("(")[0].strip().upper()
            if to:
                to = to.split(" ", 1)[0].split("(")[0].strip().upper()

            if not (exch_code and valid_from and frm and to and qtn and rate):
                continue

            rows.append({
                "ExchangeRateType": exch_code,
                "ValidFrom": valid_from,
                "FromCurrency": frm,
                "ToCurrency": to,
                "Quotation": "Indirect" if qtn.lower().startswith("ind") else "Direct",
                "ExchangeRate": rate,
            })

        diag = {
            "sheet_title": ws.title,
            "n_cols": len(header_cells),
            "headers": list(headers.keys()),
            "n_rows_parsed": len(rows),
            "file_bytes": xlsx_path.stat().st_size if xlsx_path.exists() else 0,
        }
        return rows, diag


    # ---------- diff logic ----------
    def _key_of(row: Dict[str, Any]) -> Tuple[str, str, str, str, str]:
        """
        Matching key — we don't require exact rate equality to identify presence.
        (You can change this to include ExchangeRate if you want strict match.)
        """
        return (
            (row.get("ExchangeRateType") or "").strip().upper(),
            (row.get("ValidFrom") or "").strip(),
            (row.get("FromCurrency") or "").strip().upper(),
            (row.get("ToCurrency") or "").strip().upper(),
            ("Indirect" if str(row.get("Quotation") or "").lower().startswith("ind") else "Direct"),
        )


    # ---------- main runner ----------
    def run_collect_missing_range(day_from: date, day_to: date) -> Dict[str, Any]:
        """
        For each day in [day_from, day_to]:
        - open 'Currency Exchange Rates' app
        - set 'Exchange Rate Effective Date'
        - export to Excel
        - parse the xlsx + read JSON `WebService/data/<YYYY-MM-DD>/exchange_rates_payload.json`
        - find items present in JSON but missing in Excel
        - write them to `WebService/TrackDrivers/Fallback/<YYYY-MM-DD>.json`
        """
        cfg = config()
        drv = None

        out: Dict[str, Any] = {
            "ok": True,
            "total_days": 0,
            "processed": 0,
            "total_missing": 0,
            "per_day": [],
        }

        try:
            TEMP_DL_DIR.mkdir(parents=True, exist_ok=True)

            drv = get_driver(headless=cfg["HEADLESS"], download_dir=str(TEMP_DL_DIR))
            login(drv)
            wait_for_shell_home(drv, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
            wait_ui5_idle(drv, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

            # Navigate to app
            ShellSearch(drv).open_search().type_and_choose_app("Currency Exchange Rates")
            wait_ui5_idle(drv, timeout=30)
            CurrencyExchangeRatesPage(drv).ensure_in_app(max_attempts=3, settle_each=8)

            finder = DraftFinder(drv)
            exporter = ExcelExporter(drv)

            for d in _daterange_inclusive(day_from, day_to):
                out["total_days"] += 1
                day_iso = _iso(d)
                day_ddmmyyyy = _ddmmyyyy(d)

                # Set date filter
                ok = finder.set_effective_date_and_apply(day_ddmmyyyy, timeout=20)
                if not ok:
                    out["per_day"].append({
                        "date": day_iso, "ok": False, "why": "date_set_failed",
                        "excel_rows": 0, "json_rows": 0, "missing": 0,
                        "tracker_path": "", "export_clicked": False,
                        "xlsx_path": "", "xlsx_size": 0, "headers_seen": [],
                        "json_file_exists": False,
                    })
                    continue

                # Trigger export + wait for file
                xlsx_path, xlsx_size = exporter.export_now(download_dir=TEMP_DL_DIR, timeout=90)
                if not xlsx_path or not xlsx_path.exists() or xlsx_size == 0:
                    out["per_day"].append({
                        "date": day_iso, "ok": False, "why": "excel_export_failed",
                        "excel_rows": 0, "json_rows": 0, "missing": 0,
                        "tracker_path": "", "export_clicked": True,
                        "xlsx_path": str(xlsx_path) if xlsx_path else "",
                        "xlsx_size": xlsx_size, "headers_seen": [],
                        "json_file_exists": False,
                    })
                    continue

                # Parse Excel
                try:
                    excel_rows, diag = _read_excel_rows(xlsx_path)
                    headers_seen = diag.get("headers", [])
                except Exception as e:
                    out["per_day"].append({
                        "date": day_iso, "ok": False, "why": f"excel_parse_failed: {type(e).__name__}: {e}",
                        "excel_rows": 0, "json_rows": 0, "missing": 0,
                        "tracker_path": "", "export_clicked": True,
                        "xlsx_path": str(xlsx_path), "xlsx_size": xlsx_size,
                        "headers_seen": [], "json_file_exists": False,
                    })
                    continue

                # Read JSON payload
                json_rows, json_exists = _read_json_payload(day_iso)

                # Diff
                missing = _json_missing_vs_excel(excel_rows, json_rows)

                tracker_path = ""
                if missing:
                    tracker_path = str(_write_missing_tracker(day_iso, missing))

                out["processed"] += 1
                out["total_missing"] += len(missing)
                out["per_day"].append({
                    "date": day_iso, "ok": True, "why": "",
                    "excel_rows": len(excel_rows), "json_rows": len(json_rows),
                    "missing": len(missing), "tracker_path": tracker_path,
                    "export_clicked": True,
                    "xlsx_path": str(xlsx_path), "xlsx_size": xlsx_size,
                    "headers_seen": headers_seen, "json_file_exists": json_exists,
                })

            return out

        except Exception as e:
            log.exception("[fallback] collect-missing failed")
            return {"ok": False, "error": f"{type(e).__name__}: {e}", **out}
        finally:
            try:
                if drv and not cfg.get("KEEP_BROWSER"):
                    drv.quit()
            except Exception:
                pass


    # services\notify.py

    # services/notify.py
    from __future__ import annotations

    import base64
    import json
    import os
    from pathlib import Path
    from typing import List, Dict, Any, Optional
    from datetime import datetime

    from services.config import config

    GRAPH_BASE = "https://graph.microsoft.com/v1.0"
    _SCOPES = ["https://graph.microsoft.com/.default"]

    def _split_csv(s: str) -> list[str]:
        return [x.strip() for x in s.split(",") if x.strip()]

    def _get_token() -> str:
        """
        Acquire an app-only token using MSAL (client credentials).
        Import msal lazily so the project runs even if emailing is disabled.
        """
        cfg = config()
        try:
            import msal
        except Exception as e:
            raise RuntimeError("Emailing is enabled but 'msal' is not installed.") from e

        app = msal.ConfidentialClientApplication(
            client_id=cfg["OUTLOOK_CLIENT_ID"],
            authority=f"https://login.microsoftonline.com/{cfg['OUTLOOK_TENANT_ID']}",
            client_credential=cfg["OUTLOOK_CLIENT_SECRET"],
        )
        result = app.acquire_token_silent(_SCOPES, account=None)
        if not result:
            result = app.acquire_token_for_client(scopes=_SCOPES)
        if not result or "access_token" not in result:
            raise RuntimeError(f"Could not acquire Graph token: {result}")
        return result["access_token"]

    def _file_attachment_dict(path: Path, max_mb: int) -> Optional[Dict[str, Any]]:
        """
        Build Graph fileAttachment payload for files up to max_mb (simple attach limit).
        Returns None if too large or missing.
        """
        try:
            if not path.exists() or not path.is_file():
                return None
            size = path.stat().st_size
            if size > max_mb * 1024 * 1024:
                return None
            content = path.read_bytes()
            return {
                "@odata.type": "#microsoft.graph.fileAttachment",
                "name": path.name,
                "contentBytes": base64.b64encode(content).decode("ascii"),
            }
        except Exception:
            return None

    def _build_html_body(batch_id: str,
                        received_count: int,
                        created_count: int,
                        failed_rows: List[Dict[str, Any]],
                        duration_sec: Optional[float]) -> str:
        rows = []
        for r in failed_rows:
            p = r.get("payload", {})
            err = r.get("error") or r.get("dialog_text") or ""
            rows.append(f"""
            <tr>
                <td>{r.get('index','')}</td>
                <td>{p.get('ExchangeRateType','')}</td>
                <td>{p.get('FromCurrency','')}</td>
                <td>{p.get('ToCurrency','')}</td>
                <td>{p.get('ValidFrom','')}</td>
                <td>{p.get('Quotation','')}</td>
                <td>{p.get('ExchangeRate','')}</td>
                <td>{r.get('status','')}</td>
                <td>{(err or '').replace('<','&lt;').replace('>','&gt;')}</td>
            </tr>
            """)
        rows_html = "\n".join(rows) or "<tr><td colspan='10'>—</td></tr>"
        dur = f"{duration_sec:.1f}s" if duration_sec is not None else "n/a"
        created_pct = f"{(created_count/received_count*100):.1f}%" if received_count else "n/a"
        return f"""
        <div style="font-family:Segoe UI,Arial,sans-serif">
        <h2>[SAP-BOT] Batch {batch_id} completed</h2>
        <p><b>Received:</b> {received_count} &nbsp;|&nbsp; <b>Created:</b> {created_count} ({created_pct}) &nbsp;|&nbsp; <b>Failed:</b> {len(failed_rows)} &nbsp;|&nbsp; <b>Duration:</b> {dur}</p>
        <h3>Failures</h3>
        <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;font-size:13px">
            <thead>
            <tr>
                <th>#</th><th>Type</th><th>From</th><th>To</th><th>Date</th>
                <th>Quotation</th><th>Rate</th><th>Status</th><th>Error</th>
            </tr>
            </thead>
            <tbody>{rows_html}</tbody>
        </table>
        <p style="margin-top:12px">Full JSON/CSV attached. attached when size allowed; if any were too large, their paths are listed in the table.</p>
        </div>
        """

    def send_batch_email(
        batch_id: str,
        received_count: int,
        result_obj: Dict[str, Any],
        failed_rows: List[Dict[str, Any]],
        attachment_paths: List[str],
        duration_sec: Optional[float] = None,
    ) -> Dict[str, Any]:
        """
        Sends a summary email via Microsoft Graph to OUTLOOK_TO/CC.
        attachment_paths: list of files to attach (failed json/csv).
        Returns a dict with 'ok' and 'attached' lists.
        """
        cfg = config()
        if not cfg.get("EMAIL_ENABLED"):
            return {"ok": False, "reason": "email_disabled"}

        # Prepare recipients
        to_list = _split_csv(cfg.get("OUTLOOK_TO", ""))
        if not to_list:
            return {"ok": False, "reason": "no_to_recipients"}
        cc_list = _split_csv(cfg.get("OUTLOOK_CC", ""))

        # Subject/body
        created_count = int(result_obj.get("created", 0))
        subject = f"[SAP-BOT] Batch {batch_id}: {created_count}/{received_count} created – {len(failed_rows)} failed"
        html_body = _build_html_body(batch_id, received_count, created_count, failed_rows, duration_sec)

        # Build attachments (respect simple attach size)
        max_mb = int(cfg.get("EMAIL_MAX_ATTACH_MB") or 3)
        attached = []
        attachments = []
        for p in attachment_paths:
            att = _file_attachment_dict(Path(p), max_mb=max_mb)
            if att:
                attachments.append(att)
                attached.append(os.path.basename(p))
        # Graph API payload
        message = {
            "subject": subject,
            "body": {"contentType": "HTML", "content": html_body},
            "toRecipients": [{"emailAddress": {"address": a}} for a in to_list],
        }
        if cc_list:
            message["ccRecipients"] = [{"emailAddress": {"address": a}} for a in cc_list]
        if attachments:
            message["attachments"] = attachments

        # Send
        token = _get_token()
        import requests  
        sender_upn = cfg["OUTLOOK_SENDER"] or to_list[0]  # fallback
        url = f"{GRAPH_BASE}/users/{sender_upn}/sendMail"
        resp = requests.post(
            url,
            headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"},
            data=json.dumps({"message": message, "saveToSentItems": True}),
            timeout=30,
        )
        if resp.status_code not in (202, 200):
            return {"ok": False, "reason": f"graph_send_failed {resp.status_code}: {resp.text}"}

        return {"ok": True, "attached": attached, "to": to_list, "cc": cc_list}


    # services\reporting.py

    # services/reporting.py
    from __future__ import annotations

    from pathlib import Path
    from typing import Any, Dict, List
    import json
    import csv
    from datetime import datetime

    from services.config import config
    from services.tracking import move_live_to_finished, prune_live_trackers_keep_last_n

    # ---------- file utils ----------

    def ensure_reports_dir(path: Path) -> Path:
        path.mkdir(parents=True, exist_ok=True)
        return path

    def _reports_root() -> Path:
        base = Path(config().get("REPORTS_DIR") or "reports").resolve()
        base.mkdir(parents=True, exist_ok=True)
        return base

    def write_json(path: Path, obj: Any) -> None:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(json.dumps(obj, indent=2, ensure_ascii=False), encoding="utf-8")

    def write_failed_csv(path: Path, failed_rows: List[Dict[str, Any]]) -> None:
        path.parent.mkdir(parents=True, exist_ok=True)
        cols = [
            "index", "status",
            "ExchangeRateType", "FromCurrency", "ToCurrency",
            "ValidFrom", "Quotation", "ExchangeRate",
            "error", "dialog_text", "lock_table", "lock_owner", "round",
        ]
        with path.open("w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=cols)
            w.writeheader()
            for r in failed_rows:
                p = r.get("payload", {}) or {}
                w.writerow({
                    "index": r.get("index"),
                    "status": r.get("status"),
                    "ExchangeRateType": p.get("ExchangeRateType"),
                    "FromCurrency": p.get("FromCurrency"),
                    "ToCurrency": p.get("ToCurrency"),
                    "ValidFrom": p.get("ValidFrom"),
                    "Quotation": p.get("Quotation"),
                    "ExchangeRate": p.get("ExchangeRate"),
                    "error": r.get("error"),
                    "dialog_text": r.get("dialog_text"),
                    "lock_table": r.get("lock_table"),
                    "lock_owner": r.get("lock_owner"),
                    "round": r.get("round"),
                })

    def write_skipped_csv(path: Path, skipped_rows: List[Dict[str, Any]]) -> None:
        """
        Mirror of write_failed_csv but for Skipped rows so we persist the SAP message.
        """
        path.parent.mkdir(parents=True, exist_ok=True)
        cols = [
            "index", "status",
            "ExchangeRateType", "FromCurrency", "ToCurrency",
            "ValidFrom", "Quotation", "ExchangeRate",
            "dialog_text", "round",
        ]
        with path.open("w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=cols)
            w.writeheader()
            for r in skipped_rows:
                p = r.get("payload", {}) or {}
                w.writerow({
                    "index": r.get("index"),
                    "status": r.get("status"),
                    "ExchangeRateType": p.get("ExchangeRateType"),
                    "FromCurrency": p.get("FromCurrency"),
                    "ToCurrency": p.get("ToCurrency"),
                    "ValidFrom": p.get("ValidFrom"),
                    "Quotation": p.get("Quotation"),
                    "ExchangeRate": p.get("ExchangeRate"),
                    "dialog_text": r.get("dialog_text") or r.get("error"),
                    "round": r.get("round"),
                })

    # ---------- daily rollup (by records' day) ----------

    def _daily_dir(day: str | None = None) -> Path:
        """
        Day directory under reports/daily/<YYYY-MM-DD>.
        NOTE: 'day' should be the records' day (derived from ValidFrom), not 'today'.
        """
        d = day or datetime.now().strftime("%Y-%m-%d")
        return _reports_root() / "daily" / d

    def _read_rollup_items(day: str | None = None) -> List[Dict[str, Any]]:
        ddir = _daily_dir(day)
        path = ddir / "rollup.ndjson"
        if not path.exists():
            return []
        items: List[Dict[str, Any]] = []
        with path.open("r", encoding="utf-8") as f:
            for line in f:
                s = line.strip()
                if not s:
                    continue
                try:
                    items.append(json.loads(s))
                except Exception:
                    pass
        return items

    def rebuild_daily_final(day: str | None = None) -> Dict[str, Any]:
        """
        Build/overwrite reports/daily/<day>/final.json from the rollup file.
        Aggregates per-batch stats into day totals + a compact list of batches.
        """
        d = day or datetime.now().strftime("%Y-%m-%d")
        ddir = _daily_dir(d)
        ddir.mkdir(parents=True, exist_ok=True)

        items = _read_rollup_items(d)
        batches: List[Dict[str, Any]] = []
        totals = {"batches": 0, "received": 0, "created": 0, "failed": 0, "skipped": 0, "ok_batches": 0, "nok_batches": 0}

        for it in items:
            batch_id = it.get("batch_id")
            total = int(it.get("total", it.get("received", 0)) or 0)
            created = int(it.get("created", 0) or 0)
            failed = int(it.get("failed", 0) or 0)
            skipped = int(it.get("skipped", 0) or 0)
            ok = bool(it.get("ok"))

            batches.append({
                "batch_id": batch_id,
                "received": total,
                "created": created,
                "failed": failed,
                "skipped": skipped,
                "ok": ok,
                "reports_dir": (it.get("reports") or {}).get("dir") or "",
            })

            totals["batches"] += 1
            totals["received"] += total
            totals["created"] += created
            totals["failed"] += failed
            totals["skipped"] += skipped
            totals["ok_batches"] += 1 if ok else 0
            totals["nok_batches"] += 0 if ok else 1

        final_doc = {
            "day": d,
            "generated_at": datetime.now().isoformat(),
            "totals": totals,
            "batches": batches,
        }
        write_json(ddir / "final.json", final_doc)
        return {"ok": True, "path": str(ddir / "final.json"), "counts": totals}

    def append_daily_rollup(batch_id: str, result_obj: Dict[str, Any], day: str | None = None) -> Dict[str, Any]:
        """
        Appends one JSON line per batch to reports/daily/<day>/rollup.ndjson,
        then (re)builds reports/daily/<day>/final.json.

        'day' MUST be the records' day (YYYY-MM-DD) when available.
        """
        ddir = _daily_dir(day)
        ddir.mkdir(parents=True, exist_ok=True)
        path = ddir / "rollup.ndjson"
        line = json.dumps({"batch_id": batch_id, "ts": datetime.now().isoformat(), **result_obj}, ensure_ascii=False)
        with path.open("a", encoding="utf-8") as f:
            f.write(line + "\n")

        try:
            rebuild_daily_final(day)
        except Exception:
            pass

        return {"ok": True, "path": str(path)}

    # ---------- tracker archiving/pruning (wrappers) ----------

    def move_tracker_if_finished(cfg: Dict[str, Any], batch_id: str, track_dir: Path) -> Dict[str, Any]:
        return move_live_to_finished(batch_id=batch_id, track_dir=track_dir)

    def prune_live_trackers(cfg: Dict[str, Any], keep_n: int = 10) -> Dict[str, Any]:
        return prune_live_trackers_keep_last_n(keep_n=keep_n)


    # services\runner.py

    # services/runner.py
    from __future__ import annotations

    import logging
    import random
    import shutil
    import time
    import threading
    from pathlib import Path
    from typing import Any, Dict, List, Tuple, Iterable
    from concurrent.futures import ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED
    from datetime import datetime

    from services.schemas import ExchangeRateItem
    from services.driver import ensure_driver_binary_ready, cleanup_profiles
    from services.tracking import (
        tracking_dir_for_batch,
        tracking_path_for_worker,
        init_tracking_files,
        pending_rows_for_report,
    )
    from services.worker import worker_process, chunk_evenly
    from services.reporting import (
        ensure_reports_dir,
        write_json,
        write_failed_csv,
        write_skipped_csv,
        append_daily_rollup,
        move_tracker_if_finished,
        prune_live_trackers,
    )

    log = logging.getLogger("sapbot")


    class BatchRunner:
        def __init__(self, cfg: Dict[str, Any], batch_id: str, reports_root: Path, workers: int):
            self.cfg = cfg
            self.batch_id = batch_id
            self.workers = max(1, int(workers))
            self.reports_root = ensure_reports_dir(reports_root)
            self.batch_dir = ensure_reports_dir(self.reports_root / batch_id)
            self.track_dir = tracking_dir_for_batch(cfg, batch_id)

        # ---------- helpers: records' day (from ValidFrom) + relocate ----------

        @staticmethod
        def _as_record_day(v: str | None) -> str | None:
            """
            Normalize ValidFrom (DD.MM.YYYY) -> YYYY-MM-DD
            """
            if not v:
                return None
            try:
                return datetime.strptime(v.strip(), "%d.%m.%Y").strftime("%Y-%m-%d")
            except Exception:
                return None

        def _record_day_from_items(self, items: List[ExchangeRateItem]) -> str | None:
            days = {self._as_record_day(it.ValidFrom) for it in items if self._as_record_day(it.ValidFrom)}
            return list(days)[0] if len(days) == 1 else None

        def _record_day_from_results(self, results: List[Dict[str, Any]]) -> str | None:
            days = set()
            for r in results:
                p = r.get("payload") or {}
                d = self._as_record_day(p.get("ValidFrom"))
                if d:
                    days.add(d)
            return list(days)[0] if len(days) == 1 else None

        def _relocate_batch_under_day(self, day: str | None) -> None:
            """
            Move reports/<batch_id> → reports/<YYYY-MM-DD>/<batch_id>
            (no-op if day is None).
            """
            if not day:
                return
            target_root = ensure_reports_dir(self.reports_root / day)
            target = target_root / self.batch_id
            if str(target.resolve()) == str(self.batch_dir.resolve()):
                return
            try:
                if target.exists():
                    shutil.rmtree(target, ignore_errors=True)
                shutil.move(str(self.batch_dir), str(target))
                self.batch_dir = target
            except Exception as e:
                log.error("[relocate] failed moving batch_dir into day folder %s: %s: %s", day, type(e).__name__, e)

        # ---------- internal helpers ----------

        def _run_multithread_once(self, items: List[ExchangeRateItem]) -> Dict[str, Any]:
            try:
                ensure_driver_binary_ready()
            except Exception:
                pass

            indexed = list(enumerate(items, start=1))
            shards = chunk_evenly(indexed, self.workers)
            stop_event = threading.Event()
            login_sem = threading.BoundedSemaphore(int(self.cfg.get("LOGIN_CONCURRENCY", min(2, self.workers))))

            init_tracking_files(self.track_dir, shards)

            track_files = {w_id: tracking_path_for_worker(self.track_dir, w_id)
                        for w_id, _ in enumerate(shards, start=1)}

            all_results: List[Dict[str, Any]] = []
            with ThreadPoolExecutor(max_workers=self.workers) as pool:
                futures = []
                for w_id, shard in enumerate(shards, start=1):
                    track_file = track_files[w_id]
                    futures.append(pool.submit(
                        worker_process, shard, stop_event, login_sem, self.cfg, w_id, track_file
                    ))

                for fut in as_completed(futures):
                    try:
                        r = fut.result()
                    except Exception as e:
                        r = {"results": [{
                            "index": None,
                            "status": "error",
                            "error": f"worker_crashed: {type(e).__name__}: {e}",
                        }]}
                    all_results.extend(r.get("results", []))

            have_idx = {r.get("index") for r in all_results if r.get("index") is not None}
            for tf in track_files.values():
                try:
                    for prow in pending_rows_for_report(tf):
                        idx = prow.get("index")
                        if idx is not None and idx not in have_idx:
                            all_results.append(prow)
                            have_idx.add(idx)
                except Exception:
                    pass

            try:
                cleanup_profiles(also_base=True)
            except Exception:
                pass

            all_results.sort(key=lambda x: x.get("index") or 0)
            return {"results": all_results}

        # ---------------- PUBLIC: non-streaming ----------------
        def run_force_all_done(self, items: List[ExchangeRateItem]) -> Dict[str, Any]:
            workers = self.workers
            base_sleep = max(0, int(self.cfg.get("FORCE_ALL_DONE_BASE_SLEEP_SEC", 8)))
            max_rounds = int(self.cfg.get("FORCE_ALL_DONE_MAX_ROUNDS", 25))
            max_minutes = int(self.cfg.get("FORCE_ALL_DONE_MAX_MINUTES", 60))

            start_ts = time.time()
            time_cap = (max_minutes > 0)

            aggregate_results: Dict[int, Dict[str, Any]] = {}
            pending: List[Tuple[int, ExchangeRateItem]] = list(enumerate(items, start=1))
            round_no = 0

            try:
                while pending:
                    if max_rounds > 0 and round_no >= max_rounds:
                        break
                    if time_cap and (time.time() - start_ts) > (max_minutes * 60):
                        break

                    round_no += 1
                    round_items = [it for _, it in pending]
                    r = self._run_multithread_once(round_items)
                    round_rows = r.get("results", [])

                    lim = min(len(round_rows), len(pending))
                    for i in range(lim):
                        orig_idx = pending[i][0]
                        row = {**round_rows[i], "round": round_no}
                        aggregate_results[orig_idx] = row

                    next_pending: List[Tuple[int, ExchangeRateItem]] = []
                    for i in range(lim):
                        orig_idx, orig_item = pending[i]
                        row = aggregate_results.get(orig_idx, {})
                        st = (row.get("status") or "").strip().lower()
                        if st == "pending":
                            next_pending.append((orig_idx, orig_item))

                    if next_pending:
                        time.sleep(base_sleep + random.uniform(0, 2.0))
                        pending = next_pending
                    else:
                        pending = []

                for idx in range(1, len(items) + 1):
                    aggregate_results.setdefault(idx, {
                        "index": idx,
                        "payload": items[idx - 1].dict(),
                        "status": "error",
                        "error": "no_result",
                        "round": round_no,
                    })

                final_rows = [aggregate_results[i] for i in sorted(aggregate_results.keys())]
                created = sum(1 for r in final_rows if (r.get("status") or "").lower() == "created")
                failed_rows = [r for r in final_rows if (r.get("status") or "").lower() not in ("created", "skipped")]
                failed = len(failed_rows)
                skipped = sum(1 for r in final_rows if (r.get("status") or "").lower() == "skipped")
                skipped_rows = [r for r in final_rows if (r.get("status") or "").lower() == "skipped"]

                return {
                    "ok": failed == 0,
                    "workers": workers,
                    "total": len(items),
                    "created": created,
                    "failed": failed,
                    "skipped": skipped,
                    "results": final_rows,
                    "skipped_rows": skipped_rows,
                    "force_all_done_rounds_used": round_no,
                    "force_all_done_max_rounds": max_rounds,
                    "force_all_done_time_cap_minutes": max_minutes,
                    "track_dir": str(self.track_dir),
                }
            finally:
                try:
                    if self.track_dir.exists():
                        shutil.rmtree(self.track_dir, ignore_errors=True)
                except Exception:
                    pass

        # ---------------- PUBLIC: streaming ----------------
        def stream_events(self, items: List[ExchangeRateItem], heartbeat_sec: int = 5) -> Iterable[str]:
            start_ts = time.time()
            workers = self.workers
            base_sleep = max(0, int(self.cfg.get("FORCE_ALL_DONE_BASE_SLEEP_SEC", 8)))
            max_rounds = int(self.cfg.get("FORCE_ALL_DONE_MAX_ROUNDS", 25))
            max_minutes = int(self.cfg.get("FORCE_ALL_DONE_MAX_MINUTES", 60))
            time_cap = (max_minutes > 0)

            yield self._json_line({
                "event": "start",
                "batch_id": self.batch_id,
                "received": len(items),
                "workers": workers,
                "ts": self._iso_now(),
            })

            pending_pairs: List[Tuple[int, ExchangeRateItem]] = list(enumerate(items, start=1))
            aggregate: Dict[int, Dict[str, Any]] = {}
            round_no = 0
            all_rows_this_batch: List[Dict[str, Any]] = []

            try:
                while pending_pairs:
                    if max_rounds > 0 and round_no >= max_rounds:
                        break
                    if time_cap and (time.time() - start_ts) > (max_minutes * 60):
                        break

                    round_no += 1
                    shards = chunk_evenly(pending_pairs, workers)

                    init_tracking_files(self.track_dir, shards)

                    stop_event = threading.Event()
                    login_sem = threading.BoundedSemaphore(int(self.cfg.get("LOGIN_CONCURRENCY", min(2, workers))))

                    with ThreadPoolExecutor(max_workers=workers) as pool:
                        futures = [
                            pool.submit(
                                worker_process, shard, stop_event, login_sem, self.cfg, w_id,
                                tracking_path_for_worker(self.track_dir, w_id)
                            )
                            for w_id, shard in enumerate(shards, start=1)
                        ]

                        pending_futs = set(futures)
                        last_emit = time.time()

                        while pending_futs: 
                            done, pending_futs = wait(pending_futs, timeout=heartbeat_sec, return_when=FIRST_COMPLETED)
                            
                            for fut in done:
                                try: 
                                    r = fut.result()
                                except Exception as e:
                                    r = {"results": [ {"index": None, "status": "error", "error": f"worker_crashed: {type(e).__name__}: {e}", "round": round_no} ]}
                            
                                rows = r.get("results", []) 
                                for row in rows: 
                                    row["round"] = round_no
                                all_rows_this_batch.extend(rows) 
                                
                                for row in rows:
                                    yield self._json_line({"event": "row", **row})
                                last_emit = time.time()
                                
                            if (time.time() - last_emit) >= heartbeat_sec:
                                yield self._json_line({"event": "tick", "ts": self._iso_now()})
                                last_emit = time.time()

                results_sorted = sorted(list(aggregate.values()), key=lambda x: (x.get("index") or 0))
                created = sum(1 for r in results_sorted if (r.get("status") or "").lower() == "created")
                failed_rows = [r for r in results_sorted if (r.get("status") or "").lower() not in ("created", "skipped")]
                failed = len(failed_rows)
                skipped = sum(1 for r in results_sorted if (r.get("status") or "").lower() == "skipped")
                skipped_rows = [r for r in results_sorted if (r.get("status") or "").lower() == "skipped"]
                duration_sec = time.time() - start_ts

                result = {
                    "ok": (failed == 0),
                    "workers": workers,
                    "total": len(items),
                    "created": created,
                    "failed": failed,
                    "skipped": skipped,
                    "results": results_sorted,
                    "track_dir": str(self.track_dir),
                    "force_all_done_rounds_used": round_no,
                    "force_all_done_max_rounds": max_rounds,
                    "force_all_done_time_cap_minutes": max_minutes,
                }

                # persist per-batch artifacts
                result_path = self.batch_dir / "result.json"
                failed_json_path = self.batch_dir / "failed.json"
                failed_csv_path = self.batch_dir / "failed.csv"
                skipped_json_path = self.batch_dir / "skipped.json"
                skipped_csv_path = self.batch_dir / "skipped.csv"

                write_json(result_path, result)
                write_json(failed_json_path, failed_rows)
                write_failed_csv(failed_csv_path, failed_rows)
                write_json(skipped_json_path, skipped_rows)
                write_skipped_csv(skipped_csv_path, skipped_rows)

                # figure records' day from the batch items and MOVE under reports/<day>/<batch_id>
                rec_day = self._record_day_from_items(items)
                self._relocate_batch_under_day(rec_day)

                # daily rollup + archive/prune (by records' day)
                try:
                    append_daily_rollup(self.batch_id, {**result, "duration_sec": round(duration_sec, 2)}, day=rec_day)
                except Exception:
                    pass
                try:
                    _td = tracking_dir_for_batch(self.cfg, self.batch_id)
                    move_tracker_if_finished(self.cfg, self.batch_id, _td)
                    prune_live_trackers(self.cfg, keep_n=int(self.cfg.get("NUM_LIVE_TRACKERS", 10)))
                except Exception:
                    pass

                # recompute artifact paths after potential relocate
                result_path = self.batch_dir / "result.json"
                failed_json_path = self.batch_dir / "failed.json"
                failed_csv_path = self.batch_dir / "failed.csv"
                skipped_json_path = self.batch_dir / "skipped.json"
                skipped_csv_path = self.batch_dir / "skipped.csv"

                yield self._json_line({
                    "event": "end",
                    "batch_id": self.batch_id,
                    "received": len(items),
                    "duration_sec": round(duration_sec, 2),
                    "created": created,
                    "failed": failed,
                    "skipped": skipped,
                    "reports": {
                        "dir": str(self.batch_dir),
                        "result_json": str(result_path),
                        "failed_json": str(failed_json_path),
                        "failed_csv": str(failed_csv_path),
                        "skipped_json": str(skipped_json_path),
                        "skipped_csv": str(skipped_csv_path),
                    },
                    "email": {"ok": False, "reason": "not_requested"},
                    "track_dir": str(self.track_dir),
                    "records_day": rec_day,
                })

            finally:
                try:
                    if self.track_dir.exists():
                        shutil.rmtree(self.track_dir, ignore_errors=True)
                except Exception:
                    pass

        # ---------- reporting helpers used by routes ----------

        def write_request_summary(self, items_sample: List[Dict[str, Any]], workers: int) -> None:
            from datetime import datetime
            write_json(self.batch_dir / "request.json", {
                "batch_id": self.batch_id,
                "received": len(items_sample),
                "ts": datetime.now().isoformat(),
                "workers": workers,
                "sample": items_sample[:5],
            })

        def persist_and_email(self, result: Dict[str, Any], duration_sec: float) -> Dict[str, Any]:
            results = result.get("results", [])
            failed_rows = [r for r in results if (r.get("status") or "").lower() not in ("created", "skipped")]
            skipped_rows = [r for r in results if (r.get("status") or "").lower() == "skipped"]

            result_path = self.batch_dir / "result.json"
            failed_json_path = self.batch_dir / "failed.json"
            failed_csv_path = self.batch_dir / "failed.csv"
            skipped_json_path = self.batch_dir / "skipped.json"
            skipped_csv_path = self.batch_dir / "skipped.csv"

            write_json(result_path, result)
            write_json(failed_json_path, failed_rows)
            write_failed_csv(failed_csv_path, failed_rows)
            write_json(skipped_json_path, skipped_rows)
            write_skipped_csv(skipped_csv_path, skipped_rows)

            # relocate under records' day (derived from results payloads)
            rec_day = self._record_day_from_results(results)
            self._relocate_batch_under_day(rec_day)

            # Email summary if enabled & there are failures
            email_info = {"ok": False, "reason": "not_requested"}
            if self.cfg.get("EMAIL_ENABLED") and failed_rows:
                try:
                    from services.notify import send_batch_email
                    attachments = [str(self.batch_dir / "failed.json"), str(self.batch_dir / "failed.csv")]
                    email_info = send_batch_email(
                        batch_id=self.batch_id,
                        received_count=result.get("total", 0),
                        result_obj=result,
                        failed_rows=failed_rows,
                        attachment_paths=attachments,
                        duration_sec=duration_sec,
                    )
                except Exception as e:
                    email_info = {"ok": False, "reason": f"send_error: {type(e).__name__}: {e}"}

            # paths may have changed after relocate
            result_out = dict(result)
            result_out.update({
                "batch_id": self.batch_id,
                "duration_sec": round(duration_sec, 2),
                "reports": {
                    "dir": str(self.batch_dir),
                    "result_json": str(self.batch_dir / "result.json"),
                    "failed_json": str(self.batch_dir / "failed.json"),
                    "failed_csv": str(self.batch_dir / "failed.csv"),
                    "skipped_json": str(self.batch_dir / "skipped.json"),
                    "skipped_csv": str(self.batch_dir / "skipped.csv"),
                },
                "email": email_info,
                "records_day": rec_day,
            })

            # Append to daily rollup for that records' day
            try:
                append_daily_rollup(self.batch_id, result_out, day=rec_day)
            except Exception:
                pass

            # Archive tracker & prune
            try:
                from services.tracking import tracking_dir_for_batch
                _td = tracking_dir_for_batch(self.cfg, self.batch_id)
                move_tracker_if_finished(self.cfg, self.batch_id, _td)
                prune_live_trackers(self.cfg, keep_n=int(self.cfg.get("NUM_LIVE_TRACKERS", 10)))
            except Exception:
                pass

            return result_out

        # ---------- small utils ----------

        @staticmethod
        def _json_line(obj: Dict[str, Any]) -> str:
            import json
            return json.dumps(obj) + "\n"

        @staticmethod
        def _iso_now() -> str:
            from datetime import datetime
            return datetime.now().isoformat()


    # services\safe.py

    from selenium.webdriver.support.ui import WebDriverWait

    def wait_js(driver, predicate_js: str, timeout: int) -> bool:
        try:
            WebDriverWait(driver, timeout).until(lambda d: bool(d.execute_script(predicate_js)))
            return True
        except Exception:
            return False


    # services\schemas.py

    from __future__ import annotations

    from pydantic import BaseModel, Field, validator
    from decimal import Decimal, ROUND_HALF_UP


    class ExchangeRateItem(BaseModel):
        ExchangeRateType: str = Field(..., description="e.g. M")
        FromCurrency: str = Field(..., description="e.g. USD")
        ToCurrency: str = Field(..., description="e.g. JOD")
        # Normalize to DD.MM.YYYY for SAP typing
        ValidFrom: str = Field(
            ...,
            description="Date like 31.12.2025 or 2025-12-31 or 12/31/2025; normalized to DD.MM.YYYY"
        )
        Quotation: str | None = Field("Direct", description="Direct or Indirect")
        ExchangeRate: str | float | Decimal = Field(..., description="> 0; rounded to 5 dp")

        @validator("ExchangeRateType", "FromCurrency", "ToCurrency")
        def _up(cls, v: str):  # noqa: N805
            return (v or "").strip().upper()

        @validator("Quotation", always=True)
        def _q(cls, v: str | None):  # noqa: N805
            s = (v or "Direct").strip().capitalize()
            return "Indirect" if s.startswith("Ind") else "Direct"

        @validator("ValidFrom")
        def _datefmt(cls, v: str):  # noqa: N805
            s = (v or "").strip()
            fmts = [
                "%m/%d/%Y",   # 12/31/2025
                "%Y-%m-%d",   # 2025-12-31
                "%Y/%m/%d",   # 2025/12/31
                "%d/%m/%Y",   # 31/12/2025
                "%Y%m%d",     # 20251231
                "%d.%m.%Y",   # 31.12.2025
                "%Y-%d-%m",   # legacy 2025-31-12
            ]
            from datetime import datetime as _dt
            for f in fmts:
                try:
                    dt = _dt.strptime(s, f)
                    return dt.strftime("%d.%m.%Y")
                except Exception:
                    pass
            raise ValueError(f"Unrecognized date: {v}")

        @validator("ExchangeRate")
        def _5dp(cls, v):  # noqa: N805
            q = Decimal(str(v))
            if q <= 0:
                raise ValueError("ExchangeRate must be > 0")
            q = q.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
            return f"{q:.5f}"


    # services\tracking.py

    # services/tracking.py
    from __future__ import annotations

    from pathlib import Path
    from typing import Dict, Any, List, Tuple, Optional
    import json
    import shutil
    from datetime import datetime

    from services.schemas import ExchangeRateItem
    from services.config import config

    # ---- Standardized tracker status tokens ----
    PENDING = "Pending"
    DONE    = "Done"
    SKIPPED = "Skipped"

    # ---- Directory layout helpers ----

    def _root() -> Path:
        """Base tracking root from env TRACK_DIR (default WebService/TrackDrivers)."""
        return Path(config().get("TRACK_DIR") or "WebService/TrackDrivers").resolve()

    def _live_root() -> Path:
        p = _root() / "Live"
        p.mkdir(parents=True, exist_ok=True)
        return p

    def _finished_root_for_day(day: Optional[str] = None) -> Path:
        d = day or datetime.now().strftime("%Y-%m-%d")
        p = _root() / "Finished" / d
        p.mkdir(parents=True, exist_ok=True)
        return p

    def finished_dir_for_day(day: Optional[str] = None) -> Path:
        """Public getter to be used by reporting/daily."""
        return _finished_root_for_day(day)

    def tracking_dir_for_batch(cfg: Dict[str, Any], batch_id: str) -> Path:
        """Per-batch live tracker dir."""
        d = _live_root() / batch_id
        d.mkdir(parents=True, exist_ok=True)
        return d

    def tracking_path_for_worker(track_dir: Path, worker_id: int) -> Path:
        return track_dir / f"driver-{worker_id}.json"

    # ---- File IO helpers ----

    def _load_tracking(path: Path) -> Dict[str, Any]:
        try:
            return json.loads(path.read_text(encoding="utf-8"))
        except Exception:
            return {"worker_id": None, "items": []}

    def _save_tracking_atomic(path: Path, doc: Dict[str, Any]) -> None:
        tmp = path.with_suffix(".json.tmp")
        tmp.write_text(json.dumps(doc, indent=2, ensure_ascii=False), encoding="utf-8")
        tmp.replace(path)

    # ---- Initialize / Update ----

    def init_tracking_files(track_dir: Path, shards: List[List[Tuple[int, ExchangeRateItem]]]) -> None:
        """
        Create one JSON per worker with each row initialized as Pending.
        """
        track_dir.mkdir(parents=True, exist_ok=True)
        for w_id, shard in enumerate(shards, start=1):
            path = tracking_path_for_worker(track_dir, w_id)
            if path.exists():
                # keep existing (supports driver restarts)
                continue
            doc = {
                "worker_id": w_id,
                "items": [{"index": idx, "status": PENDING, "payload": it.dict()} for (idx, it) in shard],
            }
            _save_tracking_atomic(path, doc)

    def mark_item_status(path: Path, index: int, status: str, extra: Optional[Dict[str, Any]] = None) -> None:
        """
        Update a single item inside a worker tracking file.
        status should be one of: Pending / Done / Skipped / Error ...
        """
        doc = _load_tracking(path)
        changed = False
        for row in doc.get("items", []):
            if row.get("index") == index:
                row["status"] = status
                if extra:
                    row.update(extra)
                changed = True
                break
        if changed:
            _save_tracking_atomic(path, doc)

    def iter_pending_items(path: Path) -> List[Tuple[int, ExchangeRateItem]]:
        """
        Only return items currently Pending in this track file.
        """
        doc = _load_tracking(path)
        out: List[Tuple[int, ExchangeRateItem]] = []
        changed = False
        for row in doc.get("items", []):
            st = (row.get("status") or "").strip()
            if st.lower() == PENDING.lower():
                payload = row.get("payload") or {}
                try:
                    item = ExchangeRateItem(**payload)
                    out.append((row.get("index"), item))
                except Exception:
                    # malformed → mark Error to avoid loops
                    row["status"] = "Error"
                    changed = True
        if changed:
            _save_tracking_atomic(path, doc)
        return out

    def pending_rows_for_report(path: Path) -> list[dict]:
        """
        Synthesize rows for reporting for remaining Pending items.
        """
        doc = _load_tracking(path)
        out: list[dict] = []
        for row in doc.get("items", []):
            if (row.get("status") or "").strip().lower() == PENDING.lower():
                out.append({
                    "index": row.get("index"),
                    "status": PENDING,
                    "payload": row.get("payload") or {},
                })
        return out

    # ---- Live -> Finished archiving & pruning ----

    def _dir_has_any_pending(track_dir: Path) -> bool:
        for f in sorted(track_dir.glob("driver-*.json")):
            doc = _load_tracking(f)
            for row in doc.get("items", []):
                if (row.get("status") or "").strip().lower() == PENDING.lower():
                    return True
        return False

    def move_live_to_finished(batch_id: str, track_dir: Optional[Path] = None, day: Optional[str] = None) -> Dict[str, Any]:
        """
        If the batch's live tracker has NO Pending rows, move it under Finished/YYYY-MM-DD/<batch_id>.
        Returns a dict describing the action.
        """
        lr = _live_root()
        tdir = track_dir or (lr / batch_id)
        if not tdir.exists():
            return {"ok": False, "reason": "no_live_dir", "batch_id": batch_id}

        if _dir_has_any_pending(tdir):
            return {"ok": False, "reason": "still_pending", "batch_id": batch_id, "path": str(tdir)}

        dest_root = _finished_root_for_day(day)
        dest = dest_root / batch_id
        try:
            if dest.exists():
                shutil.rmtree(dest, ignore_errors=True)
            shutil.move(str(tdir), str(dest))
            return {"ok": True, "moved_to": str(dest), "batch_id": batch_id}
        except Exception as e:
            return {"ok": False, "reason": f"move_failed: {type(e).__name__}: {e}", "batch_id": batch_id}

    def prune_live_trackers_keep_last_n(keep_n: int = 10) -> Dict[str, Any]:
        """
        Keep only the most-recent N live batch tracker dirs by mtime; delete older ones.
        """
        keep_n = max(0, int(keep_n))
        lr = _live_root()
        if not lr.exists():
            return {"ok": True, "deleted": [], "kept": []}

        dirs = [d for d in lr.iterdir() if d.is_dir()]
        dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

        to_keep = dirs[:keep_n] if keep_n > 0 else []
        to_delete = dirs[keep_n:] if keep_n >= 0 else []

        deleted = []
        for d in to_delete:
            try:
                shutil.rmtree(d, ignore_errors=True)
                deleted.append(str(d))
            except Exception:
                pass

        return {"ok": True, "deleted": deleted, "kept": [str(p) for p in to_keep]}

    # ---- Live status summary (for routes/currency.py) ----

    def _count_statuses_in_doc(doc: Dict[str, Any]) -> Dict[str, int]:
        """
        Count normalized statuses in a single tracking doc.
        Normalization: 'created' -> Done, 'skipped' -> Skipped, 'pending' -> Pending.
        Anything else -> Error.
        """
        counts = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
        for row in doc.get("items", []):
            raw = (row.get("status") or "").strip().lower()
            if raw == "done" or raw == "created":
                counts[DONE] += 1
            elif raw == "skipped":
                counts[SKIPPED] += 1
            elif raw == "pending":
                counts[PENDING] += 1
            else:
                counts["Error"] += 1
        return counts

    def read_live_status_summary(batch_id: Optional[str] = None, track_dir: Optional[Path] = None) -> Dict[str, Any]:
        """
        Summarize the live tracker(s).
        - If track_dir is provided, summarize that directory.
        - Else if batch_id is provided, summarize Live/<batch_id>.
        - Else, summarize ALL batches under Live/.
        Returns dict with totals and per-worker breakdown (when summarizing a single batch).
        """
        lr = _live_root()
        if track_dir is None:
            if batch_id:
                track_dir = lr / batch_id
            else:
                # global summary across all live batches
                batches = []
                for bdir in sorted([d for d in lr.iterdir() if d.is_dir()]):
                    b_tot = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
                    for f in sorted(bdir.glob("driver-*.json")):
                        doc = _load_tracking(f)
                        c = _count_statuses_in_doc(doc)
                        for k, v in c.items():
                            b_tot[k] = b_tot.get(k, 0) + int(v)
                    batches.append({"batch_id": bdir.name, "totals": b_tot, "path": str(bdir)})
                grand = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
                for b in batches:
                    for k, v in b["totals"].items():
                        grand[k] = grand.get(k, 0) + int(v)
                return {"ok": True, "scope": "all", "totals": grand, "batches": batches, "live_root": str(lr)}

        # single batch dir summary
        if not track_dir.exists():
            return {"ok": False, "reason": "not_found", "path": str(track_dir)}
        by_worker = []
        totals = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
        for f in sorted(track_dir.glob("driver-*.json")):
            doc = _load_tracking(f)
            wid = doc.get("worker_id")
            c = _count_statuses_in_doc(doc)
            by_worker.append({"worker_id": wid, "file": f.name, "totals": c})
            for k, v in c.items():
                totals[k] = totals.get(k, 0) + int(v)

        return {
            "ok": True,
            "scope": "batch",
            "batch_id": batch_id or track_dir.name,
            "path": str(track_dir),
            "totals": totals,
            "by_worker": by_worker,
            "has_pending": totals.get(PENDING, 0) > 0,
        }


    # services\ui.py

    # services/ui.py
    from selenium.webdriver.support.ui import WebDriverWait
    from services.config import EXPLICIT_WAIT_SEC
    from core.base import fluent_wait

    def _wait_js(driver, script: str, timeout: int) -> bool:
        try:
            fluent_wait(driver, timeout).until(lambda d: bool(d.execute_script(script)))
            return True
        except Exception:
            return False

    def wait_for_shell_home(driver, timeout: int | None = None) -> bool:
        """
        Ready when:
        - URL contains '#Shell-home', OR
        - UI5 core is initialized and ushell container is present.
        """
        t = timeout or EXPLICIT_WAIT_SEC
        try:
            fluent_wait(driver, t).until(
                lambda d: "shell-home" in (d.current_url or "").lower()
            )
            return True
        except Exception:
            pass

        js = """
        try {
        if (!window.sap || !sap.ui) return false;
        if (sap.ushell && sap.ushell.Container) return true;
        var core = sap.ui.getCore && sap.ui.getCore();
        if (!core) return false;
        if (core.isInitialized && !core.isInitialized()) return false;
        return true;
        } catch (e) { return false; }
        """
        return _wait_js(driver, js, t)

    def wait_ui5_idle(driver, timeout: int | None = None) -> bool:
        """
        Lightweight 'settled' check for UI5 renderer and DOM idle enough to interact.
        """
        t = timeout or EXPLICIT_WAIT_SEC
        js = """
        try {
        if (document.readyState !== 'complete') return false;
        if (window.sap && sap.ui && sap.ui.getCore) {
            var core = sap.ui.getCore();
            if (core && core.isInitialized && !core.isInitialized()) return false;
            if (core && core.getUIDirty && core.getUIDirty()) return false;
        }
        return true;
        } catch (e) { return true; }
        """
        return _wait_js(driver, js, t)

    def wait_url_contains(driver, needle: str, timeout: int | None = None) -> bool:
        t = timeout or EXPLICIT_WAIT_SEC
        try:
            fluent_wait(driver, t).until(
                lambda d: needle.lower() in (d.current_url or "").lower()
            )
            return True
        except Exception:
            return False

    # ---------- Robust shell search readiness + JS fallback ----------

    def wait_shell_search_ready(driver, timeout: int | None = None) -> bool:
        """
        Wait until the FLP header search control is available OR the renderer exists.
        """
        t = timeout or EXPLICIT_WAIT_SEC
        js = """
        try {
        var hasSearch = !!document.querySelector('a#sf.sapUshellShellHeadItm')
                    || !!document.querySelector("a.sapUshellShellHeadItm[data-help-id='shellHeader-search']")
                    || !!document.querySelector("a.sapUshellShellHeadItm[role='button'][aria-label*='Search']");
        if (hasSearch) return true;
        if (window.sap && sap.ushell && sap.ushell.Container) {
            var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
            if (r) return true;
        }
        return false;
        } catch(e){ return false; }
        """
        return _wait_js(driver, js, t)

    def open_shell_search_via_js(driver) -> bool:
        """
        Ask the FLP renderer to open the global search.
        Returns True if we could call an API; False otherwise.
        """
        js = """
        try {
        if (window.sap && sap.ushell && sap.ushell.Container){
            var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
            if (r){
                if (typeof r.showSearch === 'function'){ r.showSearch(true); return true; }
                if (typeof r.openSearch === 'function'){ r.openSearch(); return true; }
            }
        }
        } catch(e){}
        return false;
        """
        try:
            return bool(driver.execute_script(js))
        except Exception:
            return False


    # services\worker.py

    # services/worker.py
    from __future__ import annotations

    import logging
    import threading
    import time
    from typing import Dict, Any, List, Tuple

    from selenium.common.exceptions import (
        InvalidSessionIdException,
        WebDriverException,
        NoSuchWindowException,
        TimeoutException,
        StaleElementReferenceException,
        ElementClickInterceptedException,
        ElementNotInteractableException,
    )

    from services.schemas import ExchangeRateItem
    from services.driver import get_driver
    from services.auth import login
    from services.ui import wait_ui5_idle, wait_for_shell_home, wait_shell_search_ready, wait_url_contains
    from pages.Shell.Search.element import ShellSearch
    from pages.CurrencyExchangeRates.page import CurrencyExchangeRatesPage
    from services.commit import commit_gate
    from services.tracking import mark_item_status, iter_pending_items

    log = logging.getLogger("sapbot")


    def _is_fatal_session_err(err: Exception) -> bool:
        msg = (str(err) or "").lower()
        return (
            isinstance(err, (InvalidSessionIdException, NoSuchWindowException))
            or any(s in msg for s in [
                "invalid session id",
                "chrome not reachable",
                "target closed",
                "disconnected: not connected to devtools",
                "cannot determine loading status",
            ])
        )


    def _open_currency_app(drv) -> CurrencyExchangeRatesPage:
        if not wait_for_shell_home(drv, timeout=60):
            raise RuntimeError("Shell home not detected after login")
        wait_ui5_idle(drv, timeout=30)
        wait_shell_search_ready(drv, timeout=30)
        ShellSearch(drv).open_search().type_and_choose_app("Currency Exchange Rates")
        wait_ui5_idle(drv, timeout=30)
        wait_url_contains(drv, "#Currency-maintainExchangeRates", 40)
        page = CurrencyExchangeRatesPage(drv)
        page.ensure_in_app(max_attempts=3, settle_each=8)
        return page


    def chunk_evenly(indexed: List[Tuple[int, ExchangeRateItem]], workers: int) -> List[List[Tuple[int, ExchangeRateItem]]]:
        n = max(1, min(workers, len(indexed))) if indexed else 1
        k, m = divmod(len(indexed), n)
        chunks: List[List[Tuple[int, ExchangeRateItem]]] = []
        start = 0
        for i in range(n):
            end = start + k + (1 if i < m else 0)
            if start < end:
                chunks.append(indexed[start:end])
            start = end
        return chunks


    def worker_process(
        shard: List[Tuple[int, ExchangeRateItem]],
        stop_event: threading.Event,
        login_sem: threading.Semaphore,
        cfg: Dict[str, Any],
        worker_id: int,
        track_file_path,  # Path
    ) -> Dict[str, Any]:
        """
        Per-thread worker. Own Chrome session.
        Uses per-worker tracking file to persist progress. Status values:
        - Pending  → not finished, will be retried
        - Done     → created (success)
        - Skipped  → duplicate existed (policy)
        - Error    → terminal error for this batch

        **IMPORTANT CHANGE**
        If a tracker file exists, we will ONLY process rows still marked Pending.
        If there are no Pending rows in the tracker, we return immediately with no work.
        We DO NOT fall back to the original shard in that case.
        """
        results: List[Dict[str, Any]] = []
        drv = None
        page = None

        WATCHDOG_SECONDS = int(cfg.get("WATCHDOG_SECONDS", 2000))
        MAX_OPEN_RETRIES = 3
        NONFATAL_RETRIES = 2  # soft retries inside SAME driver for flaky DOM

        # ---- Build the todo queue ----
        # If the tracker file exists, ALWAYS respect it and only take Pending rows.
        # If it doesn't exist (should not happen after init), fall back to the shard (first run).
        if track_file_path and track_file_path.exists():
            pending_list = iter_pending_items(track_file_path)
            # CRITICAL: do not "re-expand" the shard when nothing is pending; just exit with no work.
            if not pending_list:
                return {"interrupted": False, "results": []}
        else:
            pending_list = shard[:]

        def _kill_driver():
            nonlocal drv
            try:
                if drv:
                    drv.quit()
            except Exception:
                pass
            drv = None

        def _recreate_driver_and_reopen(max_open_retries: int = MAX_OPEN_RETRIES):
            nonlocal drv, page
            log.warning("[reopen] worker=%s recreating driver (max_open_retries=%s)", worker_id, max_open_retries)
            _kill_driver()
            drv = get_driver(headless=cfg["HEADLESS"])
            with login_sem:
                login(drv)
            wait_ui5_idle(drv, timeout=30)
            last_exc = None
            for attempt in range(1, max_open_retries + 1):
                try:
                    page_local = _open_currency_app(drv)
                    log.info("[reopen] worker=%s reopened app on attempt=%s", worker_id, attempt)
                    return page_local
                except Exception as e:
                    last_exc = e
                    log.error("[reopen] worker=%s attempt=%s failed: %s: %s", worker_id, attempt, type(e).__name__, e)
                    time.sleep(1.0 * attempt)
            raise RuntimeError(f"open_app_failed after {max_open_retries} attempts: {last_exc}")

        def _track_skipped(idx: int, row: Dict[str, Any]):
            """
            Ensure dialog_text (or error) is persisted for Skipped rows, both in results and tracking.
            """
            # normalize & keep dialog_text in results
            if not row.get("dialog_text"):
                if row.get("error"):
                    row["dialog_text"] = row["error"]
            results.append(row)
            if track_file_path:
                mark_item_status(
                    track_file_path,
                    idx,
                    "Skipped",
                    {
                        "notes": row.get("notes", {}),
                        "dialog_text": row.get("dialog_text") or "",
                    },
                )

        try:
            try:
                page = _recreate_driver_and_reopen()
            except Exception as e:
                # Could not open a browser/app now. Leave rows Pending so the runner requeues.
                log.error("[init-failed] worker=%s could not open driver/app: %s: %s",
                        worker_id, type(e).__name__, e)
                return {"interrupted": False, "results": []}

            for idx, it in pending_list:
                if stop_event.is_set():
                    stop_event.clear()

                def _watchdog_kill():
                    log.critical("[watchdog] worker=%s idx=%s exceeded=%ss → killing driver", worker_id, idx, WATCHDOG_SECONDS)
                    _kill_driver()

                def _do_one():
                    timer = threading.Timer(WATCHDOG_SECONDS, _watchdog_kill)
                    timer.daemon = True
                    timer.start()
                    try:
                        return page.create_rate(
                            exch_type=it.ExchangeRateType,
                            from_ccy=it.FromCurrency,
                            to_ccy=it.ToCurrency,
                            valid_from_mmddyyyy=it.ValidFrom,
                            quotation=it.Quotation,
                            rate_value=it.ExchangeRate,
                            commit_gate=commit_gate,
                        )
                    finally:
                        try:
                            timer.cancel()
                        except Exception:
                            pass

                soft_attempt = 0
                while True:
                    try:
                        res = _do_one()
                        row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                        # normalize status coming from page
                        st = (row.get("status") or "").strip().lower()
                        if st == "created":
                            results.append(row)
                            if track_file_path:
                                mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                        elif st == "skipped":
                            _track_skipped(idx, row)
                        elif st == "pending":
                            results.append(row)
                            if track_file_path:
                                mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                        else:
                            results.append({**row, "status": "error"})
                            if track_file_path:
                                mark_item_status(
                                    track_file_path, idx, "Error",
                                    {"error": row.get("error") if isinstance(row.get("error"), str) else (row.get("dialog_text") or "")}
                                )
                        time.sleep(0.2)
                        break

                    except TimeoutException as e:
                        log.error("[driver-recreate] worker=%s idx=%s cause=TimeoutException msg=%r", worker_id, idx, str(e))
                        try:
                            page = _recreate_driver_and_reopen(max_open_retries=2)
                            res = _do_one()
                            row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                            st = (row.get("status") or "").strip().lower()
                            if st == "created":
                                results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                            elif st == "skipped":
                                _track_skipped(idx, row)
                            elif st == "pending":
                                results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                            else:
                                results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                            {"error": row.get("error") or row.get("dialog_text") or ""})
                        except Exception as e2:
                            row = {
                                "index": idx, "payload": it.dict(), "status": "error",
                                "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                "worker": worker_id,
                            }
                            results.append(row)
                            if track_file_path:
                                mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                        break

                    except (StaleElementReferenceException, ElementClickInterceptedException, ElementNotInteractableException) as e:
                        if soft_attempt < NONFATAL_RETRIES:
                            soft_attempt += 1
                            log.warning("[soft-retry] worker=%s idx=%s attempt=%s cls=%s msg=%r",
                                        worker_id, idx, soft_attempt, type(e).__name__, str(e))
                            try:
                                page.ensure_in_app_quick()
                            except Exception:
                                try:
                                    page.ensure_in_app(max_attempts=2, settle_each=8)
                                except Exception:
                                    pass
                            time.sleep(0.3)
                            continue
                        else:
                            log.error("[soft-retry-exhausted] worker=%s idx=%s cls=%s → recreating driver",
                                    worker_id, idx, type(e).__name__)
                            try:
                                page = _recreate_driver_and_reopen(max_open_retries=2)
                                res = _do_one()
                                row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                                st = (row.get("status") or "").strip().lower()
                                if st == "created":
                                    results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                                elif st == "skipped":
                                    _track_skipped(idx, row)
                                elif st == "pending":
                                    results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                                else:
                                    results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                                {"error": row.get("error") or row.get("dialog_text") or ""})
                            except Exception as e2:
                                row = {
                                    "index": idx, "payload": it.dict(), "status": "error",
                                    "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                    "worker": worker_id,
                                }
                                results.append(row)
                                if track_file_path:
                                    mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                            break

                    except WebDriverException as e:
                        fatal = _is_fatal_session_err(e)
                        log.error("[driver-exc] worker=%s idx=%s fatal=%s cls=%s msg=%r",
                                worker_id, idx, fatal, type(e).__name__, str(e))
                        if fatal:
                            try:
                                page = _recreate_driver_and_reopen(max_open_retries=2)
                                res = _do_one()
                                row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                                st = (row.get("status") or "").strip().lower()
                                if st == "created":
                                    results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                                elif st == "skipped":
                                    _track_skipped(idx, row)
                                elif st == "pending":
                                    results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                                else:
                                    results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                                {"error": row.get("error") or row.get("dialog_text") or ""})
                            except Exception as e2:
                                row = {
                                    "index": idx, "payload": it.dict(), "status": "error",
                                    "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                    "worker": worker_id,
                                }
                                results.append(row)
                                if track_file_path:
                                    mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                        else:
                            if soft_attempt < NONFATAL_RETRIES:
                                soft_attempt += 1
                                log.warning("[soft-retry] worker=%s idx=%s attempt=%s nonfatal-webdriver cls=%s msg=%r",
                                            worker_id, idx, soft_attempt, type(e).__name__, str(e))
                                try:
                                    page.ensure_in_app_quick()
                                except Exception:
                                    try:
                                        page.ensure_in_app(max_attempts=2, settle_each=8)
                                    except Exception:
                                        pass
                                time.sleep(0.3)
                                continue
                            else:
                                log.error("[soft-retry-exhausted] worker=%s idx=%s nonfatal-webdriver → recreating driver",
                                        worker_id, idx)
                                try:
                                    page = _recreate_driver_and_reopen(max_open_retries=2)
                                    res = _do_one()
                                    row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                                    st = (row.get("status") or "").strip().lower()
                                    if st == "created":
                                        results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                                    elif st == "skipped":
                                        _track_skipped(idx, row)
                                    elif st == "pending":
                                        results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                                    else:
                                        results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                                    {"error": row.get("error") or row.get("dialog_text") or ""})
                                except Exception as e2:
                                    row = {
                                        "index": idx, "payload": it.dict(), "status": "error",
                                        "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                        "worker": worker_id,
                                    }
                                    results.append(row)
                                    if track_file_path:
                                        mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                        break

        finally:
            try:
                if drv:
                    drv.quit()
            except Exception:
                pass

        return {"interrupted": False, "results": results}


    # services\__init__.py

    from .config import config
    from .driver import get_driver
    from .auth import login

    __all__ = ["config", "get_driver", "login"]


    # downloads\fallback-1758975352\Exchange Rates.xlsx

    PK
        
    b;[G�-�<       [Content_Types].xml���N1�_����0ưp�ϥ��P�Y�����wvAbY4rմ3眯�t2�z�6���P�qAGcò�o���3,*�b��� �l:Y� #m�����;)Q���� P��٫Bۼ�I�Z���n���@(U�<�t� �Z���t�� 9g���.��*%g�*T�]U��ep8 ��:�	R�=�ڄW��z�l
    ����Yy��['?b^�ǸØ'�b�X
    &�'���Al�w�_�W6�"�oF�/����p`�9�K�Boz.�U�k�4���=�A�y�	i�3��k�:u��r��7?&���o
    ݷ1`Nd��{O?PK
         
    b;[               _rels/PK
        
    b;[��   J     _rels/.rels���JA�_eȽ�m鴗"�&R �d���0u����J-=x�ߗ���v�F��)�,,�'�������LV
    �F	l�������e$w}̦0B�Щ�{��:�(W9�J#i"-aj1��e\��-��8e�����~	�p�|
    [��w��:q�3+~u2����<⻤�Ed�
    ���?]xV��"�2��/w���K:#�x���z��/�+yRB'�/�|v|	��l> PK
         
    b;[            	   docProps/PK
        
    b;[v����   �     docProps/app.xml��ˎ�0E%ʞ��Ѡr��<��!�G�K#5%ѿ� �fy��c���dGv���w-o��3r�k��-�n~g���,���w��_
    \G(fC��K-r���2U��J����\d܃�{��۫�%�᭮�@�LN���;�_��c~��:ߗv�)��U�Q2�E�Z���³�Б:D�'Q#<K��6H7]&����n��t��!<����5U�T������ <��PK
        
    b;[S=�-c  �     docProps/core.xml��]o�0��J�{(`�"�٦&Kff3���=*ڦ�C�� u�f������6����6�#�F ��؍�:�9�����L
    �3<�#�B&5,�T�m
    �aB�Fxo�
        1l95nI�2�J�S[��(�t$���RN-%��Q�_���Ju�Y-��@9k�����ZйyZP'wd�ڳ��h��ɤ-X�[tj���'��Ǫ�IE�)8�8mj3��'��bhI-���A�0
    �J�^h��EɎ�PhzRRۚn�j�8Rs�L7��e���3j�|�m
    ����5�'��+�������4�W�m��pxA��N�O� �{a�w���j��q��׋�i�כֿ$���v�/PK
         
    b;[               xl/PK
        
    b;[ ��P  \     xl/workbook.xml��Mo�0��JU��2��"$��e��G�F�J�Z��Ҳnp�����~�x^K���X�U�G�!F�2͸:&x����0��*F�V��X<O�J��A����&�p���Y�ځ.A�J����Ks$�4@�- �$�DR���G:�yK��%(w����m�K��d�NRs:��L��#\pwi�8���8T���F�z��U��Q���j�g�Hp�ӿ��cἷ��y�I�v�G�"E��x��خ'�.�q����f����̚�[P�� �
    ػo�W��}-��W\80K��Z�H茊M���1h�N{w[���E0���`<��fBz��t�ٕ� PK
         
    b;[            	   xl/_rels/PK
        
    b;[5�;�   4     xl/_rels/workbook.xml.rels���j�0�_��8�`�Q��1�@�J��������
    �5P�=���}���qP'���`��jPlt}��oϠX08b 1�W�-
    (�	�>�*���Hzњ�����B�icQJ�;���#���'��0g��3�7�����۶����HAnDh����$��qc�H��U���-����L][|��?�3��=����>'U��[F϶�� PK
        
    b;[85�cL  �  
       xl/styles.xml�Uۊ�0����/mҲ�^����.��B_eKvDu1�����,_K���P�A���93ґ�<\�@gfZ�U��]�S��\�)����}Ĩ�DQ"�b)�Y�����`�'�, զ�dmsmyb��;�0+�6�X��:h�m]�A��@��G���- ��]sWj��.��,�%����-*u�l��م���B���y�����;)w=|8���Ƈ��}.8	���j���K��L�D.��Bd�5�<�H�#
    '¹*"��3H<Կ,�ap�s!���a���aˌ�a�F��o�K�|mC�o�kC�(�ߞ�j����>��Hq���oha\����S�Cu�+ęk��B
    2�������*��'7Z�8m��`PNj��pS�h lɄxv��{���T+�NBj6����0~���h{��[ط��%)�&!�4�ϵ�f�A�(�?��C<
    ^+ɦ="���� �D�Nc،K��xwo�z�d�L>�ܥ��*��V	��PB0*a%���f/r@�������j븰\]`�ˢ�aՒ�
    `PV�Nؗy1ŋ��Q��x����ڎQ���u�ȥ鎣Y^���*$�҂�(�	PK
        
    b;[2����  `     xl/sharedStrings.xml���r�6�_�+����v�����m)���!Uc�!",aJ�
    ���w]O��a{g�Ş�@�J��
    ��������@Y��
    �w���j��/UG�SV�^N�|������ח�}���Q��ۃ��UG���s&ʿa7������[�����O��q~��U�D����j���؛W����]]īɷ����U��V�NG{1�W#|}��ݔ�P�P�_��M�$u�~\U���P�λ��^-�ݏ˦�&�Dv?|VC��a(T��ek�LTF��HnA~��On�p�]���EM���uao��Z�M-AJg�����6�HL�X�ۘ�<�1o�7���(����TRqu-�1~����Ib�UO��ͬ?8����OI.����꽚Y��Q��x�i�������B�cA]�.q]g����?��:��O��:���1Ŭ����޷�ɚ��y�U⸔���q��|OMŪ���
    �L.D��&���9���Z�I9g	:k^�L���.���9�/*���=��
    ���w��g��ǃ$�2gJ�&6I/���D��Ħ�5ܴi
    D;��i�7�a���m��9I����Z
    W{��ɹ6�H=�,�̤��&����Ic�YR̼M�j�^����b隞%���J��'���&���?0�޵��K'o;pO#�Ě4Q��h&���f`��)��R%���L�`�D09�!���YH�,�`��`�D�=SL� %�D	0QL����� %�D	0QL� 3%�*LNf`~�Q�������d&�0�R0�R0�9�=ɓ#��9&ɷ��,y`�%0��d	L�&Y�
    �0I��i:���t��L���G`�dI/�,��A��&��(&s�oN�nLf����Y�LJ�b�΂�^`�dA{�,ۼ��*�&���{�X1�D0�"`"�	�Њ3%ZZ`�dC�5�kټ
    /v��2�� L �\ �
    �粩 fc�<���D�������dl�d��8}���g�ӽ����Lރ�d�� ��L:V�ӆ L^2��� }K^������&���EӼh�M�i^4͋�y�Z��4�k�y-[�6w�K�y�5/��%ּ���
    �J�y�5/10�ܺ���}$[�D7p� D 0(�4dF<`Ry`&0�� p�2Ub���D 0Y�-N�&0Y��$K`�fe &Y��|_�|!缅�|i.z~d}���VuT��x�������R���LۿR�u��PK
         
    b;[               xl/worksheets/PK
        
    b;[ Wb�G0  ۫    xl/worksheets/sheet1.xml��[�G���
    ��I���U�4��L�.�4f��\���$� K�����ŋ���g2�}��S'��'<=���_����g����������������W�?�y������x�/��g�n��|�������y������������׻��g�����><|��ŋO�~�{w��p�����O^�|w�p���_^|�������?���v<./�ݾy����w+��_�yuw��ۻ��_L>޽�}����_�|����ݫ�ݻۏ��ÿ����b�ӛ�o�������>ѿ}�����޾y����>�����������x~|����_�!����S|������;��=j>K�כ��?=��g�	�t���_�ן�=���wo�^=�]~m�s�p����?����������v���wo�^�О?�}���w�}�����������{����������;��c=��o'��s&����w�o{��������7���x����_ݿ�����{��󩼻������ݧ��_O��7??����>����W�}������{����Ϸ�?���ڟ�|��󝏿dǟ��������ן���ӿ������ֳ�_�����?���?��������������?���Y�\�����������_>_>����f����t���x���?ݿ*��
    UE'U�QqV�4*^�b7�X�P����GBmH�[��'?��(�(��ӛ����_�asA�bwA|QL_�)�mG��R=�In@bE�(zEO�P�*�}l�}Ȣ��d&�u� �	���,�$u�Y�����<
    Y��}�g&�
    I�ŌY�is��:�,Ta��b~���Y?`���$Af��Y,I��P�9�y�X�,Y��tn@d�bk�Śd�>U4�7=�O���z�����ݨ$
    c�0�4�-	C|�h~���� ?x�$�b�,�4�=�B|�h~���,�����S%Qv�0>�����U�>�4?�~�L_�շv�!r��(h�X�c�<�bQ�E%��_5_b��r0����PA��m��:jYIE%��6vRۻf6~\M�	�R�{�e�<$�t?���n:�
    .��,h�P��Z^P-k��!����a�ƒ����<��k�qO���Z�T�C2QI��v2��ld���U�jya�����d��.��2(G-�d#�l���Vˋ�e�<$�L2ȮC&����A��^����ղ��J&d�vX;ᡗld���X�ky���Ȃ�d��I�ا]��]'��F��z�m�f[�f[�f�Cf�T2�1�=m��a��sB6~�M�	WٖWٖUY�LT2�1�=��f��amm��YЄ�󪅉�tf�0������i����4��,h�L�ɶ�ɶ�ɂ��3I���a<�p����H�=�q�my�mY��D%2u��;Cg���w@f�=��=�e=<$��Js=�=�̓Ϥ�c�ؖ�ؖ�X�LT"��-㵳B&j3�{1h�L�Ƕ�Ƕ�ǂ�dT��u�d�{��̋Ϥ�c�ؖ�ؖ�X�LT2�>�q.v�!��|&�۸Ƕ�Ƕ�ǂ������=v�1V]f�'�۹������ǂ�d�����A��Y�׿t:Q(\d{^d{Vd�CC��T��6�2�7`���F���E��E�gE<4�ȭ����al_��t�P�����b�|-�	4r��c�]��Q�EVԻl�.��.۳.
    �P��c��P�f�ōN'
    ��l��l��,x��'���OZf��7dpY|q���2�2��2۳2��j��3.%8�l���t�P�������͂������e
    BQ��O-��D�p��y��Y�
    &T�泍���6��t:Q(�g{�g{�g�CC�&*��>\>���j��BK��W�B;�v�
    -x�UX'��qv�,}P�l}����2�>;�}v��,xh&�g�8;�}�h)���t:Q(�g���NY�
    E52�NmV����>K���}v����Y��P���qv������,�NJ���6]RBQ����M������,�N
    ��)�S�g�CC�iU���Y������ډ��)+��ᗽ�@#7�q��3�t�����D�p���>;e}<4�r��}������>K���}v����Y��P`���|��Y�#���>K���}v����Y��P`���|�E�3|�A���,�N����9�s�g�CB��|fWh��R��|��ӉB�B;�v�
    -xh(�����
    -L���-�N
    �9/�sVh�ÿgp����c�������,h�L���y���>�	h���,�����YЄ�p���>;g}<4����<���\�gA���Ux�+}�VH(����<�L��>�0�s�g�ς���
    ��Y�P��B�0.�s^h�Ђ������Е��v�B;�v�
    -x�A�����&S���YЄ�p���>;g}<4�|�<�}v�Gd��|��CE�r�]�>�d}<$��qvy�g��0m��?�>�/��	S�B��v�
    -xh*��Xh7(�`��B�0.�K^h��Ђ����zy�h��f;�0����[-h�`��.y�]�Vh�
    짭�����U�u}�M��%/�KVl�Cs�׸dl���MC����؂&����%+�ࡡ��2�<h4���]_lA�l_Pؿ �� _Up��eB�hX���؂&����%+�ࡡ�BZV��i=l��ŧkv}�M�
    7�%o�K�l�CS),�]�W�f%�f��4a(\m���.Y�
    �Ƞ2��=�����
    H�ۮ�m׼ۮY���N����z����E�Q7$�B�j���vͪ-xh(��-R�V�e>L�2��QvI��ە�횗�5+�ࡱ����qX��2�\Z�O��lWn�k�l׬ق��_�ס�ڶ�Vv�ݖDQ2�m׼ۮY�M��mױ�H6v��DQ*\n׼ܮY�M�Pnױ����ѷ[E�p�]�v�f�<4�B�]����p���Ǝ�ޒ(J%ئ��OW�QW�h�����z;ϸ1����[E�p�]�~�f�<4�B�]�~�)�G_pI��w��\��7�h�2N�^"�C�Kp���$��v�~���v��-xH(�����"�:�6&���(H���-+�ࡩV�n�?+�/�l�|�EQ�
    ��-�[�o�CS�;�yky*T]}�EQ�
    ��-�[�o�CS)����z�+`c��,��T��ny�ݲn�Ja��6�Pm��EA*�m���nY�M���v��+�j��(
    R�n���v˺-x��5N��7�m��羗�b~��
    ��P��ny�ݲjJa���J*�Q���-��T��h{Ѧ��B��TT#��ۖ�B��7[�p���f�e�<4Xe+���zQk��E����vϫ�U[�T@#��~L?+`c�"ߐ(J���W�=���ᯎh�`�?m���`B\L��&Q
    7�=o�{�l�CC��)[;��[h+d��E�p���f�g�<4��J�}����i��lI���vϛ�5[��T
    Km�iH��-ؘ��!Q�
    7�=o�{�l�CS��+�ʀSئ�v�T�L�H��۝�힗�=+����F.�a{�㊯{����E�p���~�g�<4��V��0u�����$�R�~���v��-xh*��j�mH��g���oH�@
    ԅ���JaW�}���n�
    �I�"�B����ŏ'�&�GWriwc�1��p��0� �p,P�)�\ ��:�o�?�O
    �9#S� ��t��~��,����ӹ�1�����eEF�w��0� �p,p�)�\ �|i������!t��N�0���p, �)�\ ����7���훌��nP���T�1e5��S���&����\�X�*L'`6ІcJm ��`��_�x�p���*�'�7��c
    p ���[�7џ�C��-Ua<��X@9S��P<�}þ��l��'�R��P�c��pL��B�悿��<z�M�u9��Upe9���`�th6���������e���-˹eP���!)�l�=4~� ,��ޠ*L'(�|Y�/#���S)�ìV���La2�`�"�Yd��̈/��T
    �@3k��NF��47�
    �	
    s�h�#�
    �����5`��;^Z��Nx
    �,b�U�f9݌�c,��KkG�F�7�y��
    ��x��\��3b�y`ЉT0���6��^<��g�Y�<#��S��|v�7��p�ܼ�2G�
    �,ǟq�Tf+3-�����nP�T�
    -'�|�Tf+3!X�p�tBU�l
    *s��f)�\ Pience�mU�p�wBUOP�x4K�h�9E�l"��
    �1=�*'h�L���4r�pT���Jk�J� �P�4�0�Rb�@:҄9lZ�JHL4�?�*L'h�v���4r�t
    �	� 5z�":�`�P��E�R���Y��t�yڗw�ˑ���oP���N�R��@8��
    L��0�
    ��iB�BU�NЖ`5K�j���j6���Ê�@
    n��t��\@�Y�X#��8�H/,��Yb�	?Ua8AU.��,����{;H8cQ����L>&-TE��5+@�,�����S`��́�����O�����0��'�k����ҡaIg\��e������0��(0l�r��ҁ��7I��f�}U�2IQ���f��
    <6K�l��@s�A��+�W@m����P����R2�@:���g�l���5x���Ҕ� �Y@h���RF�@<��q1-c'#���t��\��YJk#H&�u��'O����LH\�
    �	�r�f)��\ �|%�����ҁ,H.T��]��o��F.��h��3�|)���mB�BUOЖ$7KQn����fy�R�$T�`�P�ݬ�t���F.���$���mZt�922�u�*L'�����t7r�t`�Y*���N�6w�*L'��ʛ��7r�t@$�@z3^~J7!x�*L'��ܛ��7r�t@$��4�+/M7u!#���t��\�Y
    ~#HD:�<���X��ꅪ0��- p������;�B;4�q��L�^�
    �	�rg)�\ �&�6�����=X8_�
    �	�r
    g)�\��{"�~v��A߄���0��,�p����݂%�q
    �t��Ad�IU�g#�
    �8K)q��Ыy��[����Z���|+�X�hq����E�!����1��-�tR����Y@��6�Rn�@:9.�l:�.7t�S'U�
    z��8+��,ȑ��U�"g�e�+��*_��� $g���(9r�tr�������FS�ĊL��x��\`�Y
    �#�''t��q�=g4Nxa�
    �	�r.g)]�\ ����\�Y&z���P�T�e�R��@:���4����c(q�!��0��+xs�������;�����v��Ώ�r�CU�OP��9K�s��vz�y�˗�5�MX�b�
    �	�rBg)��\ �Zց�i_�;�N�9��*�'��YGg)��\4���2f�y'ܜP�P����R.�@:���94�D���s�CU�NP�|:Ku��Hg�F���;,r"��@�P����RJ�@:�ݎm �;-$���P�����RV�@: �q�i_n�y�[:��C��0��/�u�B�����;O��vXp܁&,82T��}� ���^G.��t�yڗ�x�h���L��0��/0v�r���) �m'�<ЃP��0��-pv�������#�y��%�'�2R��m����lG.~�=�H���f�1،Y�e�
    �	�vV��Y
    �#?�H$��:ve��e��	��Tq8AW.p�,ݑ��/�8�j�th/:��W��,��Ywg)�\ ��P�m@�]ҡ�PB�	ÌTq:AW.`�,�ޑ�"������!�eF�8��+�w����ҩ����w���P{�4#U�NЕ<Kx��?'�G�� Gw,"�	ٌTq8AU.��,E��S�
    c�������H�4��R$�@:��0ֵ�	�Tq:AS.��,%��S�c�
    W4eA��*N'h�@���<r�t*M�S�0hʂ>#U�N ʳ)�RT�h: �[����E�=A��*N'��b���<r�tT�Ϡ���/}OPh���	�r��g):�\���D"���~Xh�� |BD#UNД =K	z��H#� z�
    ����F�8��)@z�����)G���VzE���F�8��)�z����ɹ{g�z�:�a���%�4R�m��ֳ�G.P��;� س~\�S��%�4R����ٳ�G.P�%?��[ii.1��F�8��0x{���ҩ恹w�s���Y@j���	
    s��g)x�\ �Ja�{�_M'Ο�H�����߳�G.��tl`�M�;
    <����x��\ �YJ�#��Ҙ�=��`q.85a��*�'��$��L>r�����3N.�w�i�Z#UNP�d>K�|��TV.t�ƥ)R����Y ���RD�@:�����١�R����Y ���RT�@:�ݖ����e���*N'��\���>r�t�R}���.��6`Ԅ�F�8��,�y��_,����L�F�c�ǲ<ݲ�K���g�πsG�m|4�I:n��^�'#��_ѕ����I�2�h:���3�.�e2�[V�+���� x�鴔�G>>��{lm`��a����F~PFQ�W�F|=H'+�����y�������I��3:��t�)7��i:YW&M���NX~֑��N�1�Dq<ܕ� ��-���S�_n�Gﱡ��I��]�����2�h:����`~��a�Dq:ܕ�(��-���S�_n̯��v�td�����"�4��0��T \��7��6�WW�/� ����d}�|4�]֫�-��t�H��zanͯ���
    3�h:�^]n[x�B#��ꅹ0��;J'+����k~Zz��lG*=`������ � ���G>�hd��9���U�H:�(��� �(��0眾id���0?\��F2*_��kʯ!_O�I3�h:��7��c���;ɨ|ʯ(�F|=H'�����˛�m`�m�
    &��HF�+P~-@�5��Q:i_M&�eT�,?���:ɰ|ʯ(��;�'-��������2,u�_�ߐ*�'�ˈ��xҺ>Oa�6���ú���h�w�+�r@�kD׃tҶ>���o!��_�7��GPc$��	�2��(��,���CǒtƲL�2���t���;J'-���������$��F�#Q�N@�k���tR��H:�Ѳ<P�B�HXc$��	�2��(��,����/�8�6�]�W����G�8��,��I�21����$�Q�a�w�G�QxFa:AY����eb�i:���6�./��F���S
    �	�2��(��-4O�L/{�M���@���x���;�'m˄��x�m��m@�5\_IFB��S
    �	�2��(��-7O����8����+^\j$�(<�0��.���I�2��4�¶�����	7
    O)�'(̀��x��L�<�����5n�1�m]}��g�f`�Q:ia&v��C�x�6fÕNd$�(<�(� �� z�@?��x�`r�r@?"������x���;�'��X߉Dz��~���Q#G�)����wOڙ	����İ\\�o�G
    :�.��
    �_�~
    �w�Oښ	����/����5�=`$d-<�0��5h�I[3b�$�t"�ܺ+�xq��ky�����_#����f��I:t0�g�c��g�H�ZxJa<Ai&�ē�f��I<p0�s�K����P�)�`����׀|G�9{O��;7G��^R�g�+�~-��5 �Q<ii&��Ɠ�8wn�M3��o)�3�P�@���(��5BO���<7��3�q�k��PqկT��;�'����_�{"�ܸ�o�YxB�3�T�P���(��4COӡ�I<n?9�#�<S\��k֯���IK3A�48�ܸ�_p_'�<S\��kׯ���I;3Q�4����mg�g��h�ҙ� �� �� G񤝙0zO�G�M�4ӷ�`$�-<�0��4���IK3a�4��ɕf��#al�)����wOZ��ǿ�G"�q�����>ҙ� ����� �G餝�|4:�ē�*GF�"QOЙ�G񤝙|4�k+�3�ҙ������׀�G񤝙|4���}n�������|ޯx�<�'����S� ���a<`$�-���(xOZ��G㩬Θ-���H8[$��	J3`�(��4��ģ"�q
    ����i��|�3_�k�u�I;3�H:�d���cg��q����G�	:3R�4��3�}'��< ���0m+�N��"Q�OP������}$��9��F����E�8��4x�IK3�H<�_(v���� 5��∂�L�=�(m��#Hm ���ۡ5��`	���+H- �5��QBiyFI���k���s����E�8��<��I�3�H<��<��&��� �H��� � ���>>����߄���0�H��g �Q<iyF�'߻���ߴ�]���$�-����x�Oڞ�G�Q�>\�?;ͩ��P�H��g��Q<i}F�'ߌ���_;����p�H��g��Q>i&Y�"���a���ɝX~�BUOP���G���|4�H>O��2&���p~��BUPP���G��|4�ˤ��?��'���P��g`�Q>i{&�D�1p�̶�x���	�UaFA&�d��g�ь
    [47G��)��	h
    Ua>A�&��h��|
    �4���7#Մ�LPS���	��`z�OJ Dɇ0�r��̻��OpS�
    
    :4�� ��C��T��(�v��cN�*�'��Dԃ|�M>�$
    D��yZ���K8~�zI>&�)T����zOڡ�G�)���V�lc��
    D�II��`#��vh��|��s�(�����_��	u�UQ>A�&�䓖h��|*sО��P;��x
    �4���>�'�����;�z}�����'��
    `x���z�Oڡ�G����所�5c�`���"`#���g��|rʹy& ^_Ԍ�?_�l�_�I�3�������>�g�9����W@[ l��xR, �h<x0�πO	����^�l�b�I�3�@>p0��`@ۦ�v�n�����l���� ��@�D�"��
    x�����O����<`Cf��6h��|`�^b}ȧ�<���ɀ�0��Al�I4�@>�v�Ƴ���g}��0��Ak�I4���O$��hZ@F�?ݒ�
    @` ��H{OZ�����G��6��hx�j��*_�l�k�I4��4���gG<�����Ua>A�Fڞ�h��|*�����aO�]Q�F`Cޞ�h��|*+8��0��Y���P�$��H>�q�����g�? ���ߠ*�'h�H��|�
    >�Oe�y���"�n"'�����=�'�τ��;ğ�h��@��_��?_�
    l+�!wOJ�3��  8���{/D��}.�����=
    (-�烀
    ��������%N�����4��A�*@�.���G}��0��C#�OJ;4!� �7�yn ^bp8�\�
    l7����-�����H$�`8�� ����
    ��|�]B�H>�Oew��+�qP�
    W�[ l%x`K���T�w聍�8C�%�^�{��%|`O��#��H�`}��a���L��
    ��K���*Q��l�_d��y@�
    ��F�D��A�1O�8��$!W�1 :�o��
    ��K��bɇ*���@�GX,·�-Ua@\�{�$�S� �P@��K�VJ�����T�q��%�`Oa��Cjt?�5�����	�Ua@\�{	&�S� �P@�ݏc�����p� AU��^�	�'H>�A"_���l�e<��@@P��-��x�=�	��SXݏc����dd�AU���^"
    ��(H>�Oa-t?�-��ddAU�O��%�`O�����H��=���f�WP{@�%�`O����g�N$��g�
    � "�Aߠ*�'��%�`O����H���+�&��2PH2�
    �	t	,�S� �@>��} ��j,,T�����)Z�|�G�D"���u�E���dP���Z��hA�x`
    �g,�SSv���dP���Z��hA�xr�ʹ�[��8�(��.�ҝ��� .�Kp�����c�g\ǁ凌�&��0��<���=���o}�`���`S6��|a���^"��0H>��Y�G`�
    L4���|�`/1{�$͇&�g�Z?��7	}@����\��3H>P���;� -'#���|��\
    �4H>�L��48�*�dB�AUPПK������WK��c
    �>C>Ќ���0��?�`�=�
    �����
    ���Ra)9��SP4�n���A�`���@n�IP�)�
    �	*t�7�S� �@>�^ZG��BO�nwCF&�T����)p�| ���
    䀃v�;<�c���*�'��%�`O�����)�������	=Ua>A�.1{�$�D:����K�w������(� :�K���B�G�!��?tpC� � TP�4�u���A�|
    ����:hvh�Y$9� TPT�w���A�T$�u��:���((T��
    ���)w�|��{"�~~�v���((T�����)w�| ��Y��oLG�A$��0TP���x���A�xr���;�`_�M94�
    ��|��\"��<H>���|�����F�QAU�OP�K����������>��r{�������0��>�؃=e��}V��>/;]_d$��
    �`����)|�| ���r�|��a�)h
    JUQ@~����=�����9�`��/�J�@� a/{
    $ȧ2=f�w(��
    a��D �)��| ���@ l�����ҟ�`��A�K2���@;�m�	/(�T���!�)��| ��� !�;�L�AA��*(��%aO1��Uf���4���0��B�8�=���S��v ���Z��|�
    ]"��DH>�Oez�3а� ��AU�OP�K(��򩬀v(��ePx!�
    �	*t�E�S!�@>��i���'X�B�A��*�'�����0B��|H$��<�@/4�gP�!�
    �	t�F�S!�@>��Fh��F��iP�!�
    
    *t�G�S!�@@0-K� ��� b
    2Ua>A�.	{J$$ȧ�T��p:,���0CH�4����HB��c�	EҠ�q�c>�6�}��H�^B�IH>~�=�H���)V:i!��*�'��%$aO����v���Rȇvœ�|��<�^���GH>�Oa7�>��Lϧt�G��W�{@#�%aOi����H��q
    �p{x�BS!U�OПK8���Q���fv4�Jg-4R��<�^���GH>��q"�||�q�`3x��R!UOP�K<���ɡ�羌д
    	K�Tq>A{.�{�#$�&���0���B�8��=���=��/�>���/8k���*�'h�% aO����T��2��
    ��|��\"��HH>������̅��Z`*���	�s	H�S !�@>���^_n��n�t�S!U�OP�K@	��4N$������Mn�IK�Tq<A{.�{�"$��J��3�7����d/hR���#�)��| ��}��X�q	l�Ta>���`�=����S ��:��� ##���Tq>A.�{�"$�&���p[gC�9z�<b\�#����p�=��D�1z�Z?��}�9z��+�nHG�����HB�*�8�p�u�t�&OW 	{�$�%$aO����T������<�Bt��q��H�^B�IH>�Oe�I��Mx<kyʸI�$a/!	{�$$�'���> 	��m :my̸�I�&a/1	{�$$�q"���v�Iz<i��W 	{�$�%$aO����Tj�$lA����x��H�^B�IH>�O���׽����֖xE�����$�)��|4����|�"^�$������=e��S ����Bӗ<x��+@��~��{8�>�����o�/߼}�������K:��g�?~������~��7�?={{���wif����7����/�?\�}������w���׻۟�>>
    .������/.�/~����χ���PK 
        
    b;[G�-�<                     [Content_Types].xmlPK 
         
    b;[                        m  _rels/PK 
        
    b;[��   J               �  _rels/.relsPK 
         
    b;[            	            �  docProps/PK 
        
    b;[v����   �               �  docProps/app.xmlPK 
        
    b;[S=�-c  �               �  docProps/core.xmlPK 
         
    b;[                        g  xl/PK 
        
    b;[ ��P  \               �  xl/workbook.xmlPK 
         
    b;[            	              xl/_rels/PK 
        
    b;[5�;�   4               ,  xl/_rels/workbook.xml.relsPK 
        
    b;[85�cL  �  
                 ;  xl/styles.xmlPK 
        
    b;[2����  `               �
      xl/sharedStrings.xmlPK 
         
    b;[                        �  xl/worksheets/PK 
        
    b;[ Wb�G0  ۫              �  xl/worksheets/sheet1.xmlPK      N  k@    

    # pages\CurrencyExchangeRates\page.py

    # pages/CurrencyExchangeRates/page.py

    from urllib.parse import urlparse
    from datetime import datetime
    import os
    import time
    import re
    from typing import Optional
    from contextlib import nullcontext

    from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    from core.base import Page, Element
    from services.ui import wait_ui5_idle
    from .selectors import APP_HASH

    # Elements
    from .elements.ListToolbar.element import ListToolbar
    from .elements.Dialog.element import DialogWatcher
    from .elements.Fields.element import Fields
    from .elements.Factors.element import Factors
    from .elements.Quotation.element import QuotationField
    from .elements.Rate.element import ExchangeRateField
    from .elements.Footer.element import FooterActions
    from .elements.Toast.element import ToastReader
    from .elements.Validation.element import ValidationInspector
    from .elements.SideColumn.element import SideColumnController
    from .elements.Header.element import ObjectHeaderVerifier

    # For verify-after-set of Quotation
    from .elements.Quotation.selectors import QUOTATION_INNER_INPUT_XPATH

    # legacy constant (not used directly; Fields.EXCH_TYPE_INPUT_XPATH is used)
    EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,"
                            "'ExchangeRateTypeForEdit::Field-input-inner')]")

    # The exact label we want for the Exchange Rate Type field
    TARGET_EXCH_TYPE_LABEL = "M (Standard translation at average rate)"

    # --- tiny retry helper (local, non-invasive) ---
    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None


    class CurrencyExchangeRatesPage(Page):
        def __init__(self, driver, root: Optional[str] = None):
            super().__init__(driver, root)
            self._app_ready_fast = False  # quick flag

        def _el(self) -> Element:
            return Element(self.driver)

        # -------- Utilities --------
        def _origin(self) -> str:
            try:
                return self.driver.execute_script("return location.origin;")
            except Exception:
                parsed = urlparse(self.driver.current_url or "")
                return f"{parsed.scheme}://{parsed.netloc}"

        def _app_root_url(self) -> str:
            return f"{self._origin()}/ui?sap-ushell-config=lean{APP_HASH}"

        def _wait_not_busy(self, timeout: int) -> bool:
            end = time.time() + max(1, timeout)
            while time.time() < end:
                try:
                    busy = self.driver.execute_script(
                        """
                        try{
                        var core=sap && sap.ui && sap.ui.getCore ? sap.ui.getCore():null;
                        if(core && core.isInitialized && !core.isInitialized()) return true;
                        if(core && core.getUIDirty && core.getUIDirty()) return true;
                        var BI=sap && sap.ui && sap.ui.core && sap.ui.core.BusyIndicator;
                        if(BI && BI.oPopup && BI.oPopup.getOpenState && BI.oPopup.getOpenState() === 'OPEN'){return true;}
                        return false;
                        }catch(e){return false;}
                        """
                    )
                    if not busy:
                        return True
                except Exception:
                    return True
                time.sleep(0.12)
            return False

        # --- EXACTLY set Exchange Rate Type to the full label ---
        def _set_exchange_rate_type_exact(self, fields: Fields, timeout: int = 12) -> dict:
            """
            Hard-sets Exchange Rate Type to the exact UI label:
            M (Standard translation at average rate)

            Returns:
            {"ok": True, "observed": "<value>"} when confirmed exact,
            {"ok": False, "observed": "<value>", "why": "<reason>"} otherwise.
            """
            el = self._el()
            t = max(timeout, el._timeout)

            def _get():
                try:
                    return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
                except Exception:
                    return ""

            def _blur(xpath: str):
                try:
                    self.driver.execute_script(
                        """
                        try{
                        var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                        if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur && el.blur(); }
                        }catch(e){}
                        """,
                        xpath
                    )
                except Exception:
                    pass

            # fast path — already exact
            cur = _get()
            if cur == TARGET_EXCH_TYPE_LABEL:
                return {"ok": True, "observed": cur}

            # 1) Try simple 'M' + Enter + blur
            try:
                fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, "M", press_enter=True)
            except Exception:
                pass
            _blur(fields.EXCH_TYPE_INPUT_XPATH)
            wait_ui5_idle(self.driver, timeout=t)
            self._wait_not_busy(t)
            cur = _get()
            if cur == TARGET_EXCH_TYPE_LABEL:
                return {"ok": True, "observed": cur}

            # 2) Open value-help and pick exact label
            try:
                vhi_xpath = fields.EXCH_TYPE_INPUT_XPATH.replace("-inner", "-vhi")
                vhi = el.wait_clickable(By.XPATH, vhi_xpath)
                el.js_click(vhi)

                WebDriverWait(self.driver, t).until(
                    EC.presence_of_element_located((By.XPATH,
                        "//*[contains(@class,'sapMDialog') or contains(@class,'sapUiMdcValueHelpDialog') or contains(@class,'sapMPopup')]"))
                )
                exact_cell = WebDriverWait(self.driver, t).until(
                    EC.element_to_be_clickable((By.XPATH, f"//span[normalize-space(text())='{TARGET_EXCH_TYPE_LABEL}']"))
                )
                el.js_click(exact_cell)

                # If value-help has an OK button, click it
                try:
                    ok_btn = WebDriverWait(self.driver, 2).until(
                        EC.element_to_be_clickable((By.XPATH, "//button[.//bdi[normalize-space()='OK'] or .//span[normalize-space()='OK']]"))
                    )
                    el.js_click(ok_btn)
                except Exception:
                    pass
            except Exception:
                pass

            _blur(fields.EXCH_TYPE_INPUT_XPATH)
            wait_ui5_idle(self.driver, timeout=t)
            self._wait_not_busy(t)
            cur = _get()
            if cur == TARGET_EXCH_TYPE_LABEL:
                return {"ok": True, "observed": cur}

            return {"ok": False, "observed": cur, "why": "could_not_select_exact_label"}

        # -------- App navigation (hardened) --------
        def ensure_in_app(self, max_attempts: int = 2, settle_each: int = 8):
            attempts = max(1, max_attempts)
            listbar = ListToolbar(self.driver)
            sidecol = SideColumnController(self.driver)

            for _ in range(attempts):
                cur = (self.driver.current_url or "")
                if APP_HASH.lower() not in cur.lower():
                    self.driver.execute_script("location.href = arguments[0];", self._app_root_url())

                wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, settle_each))
                self._wait_not_busy(max(self._el()._timeout, settle_each))

                sidecol.close_if_present(timeout=min(10, max(8, self._el()._timeout)))

                try:
                    listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
                    self._app_ready_fast = True
                    return
                except TimeoutException:
                    self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
                    time.sleep(0.5)

            self._app_ready_fast = False
            raise TimeoutException(f"ensure_in_app failed after {attempts} attempts.")

        def ensure_in_app_quick(self):
            if self._app_ready_fast:
                try:
                    if ListToolbar(self.driver).is_at_list(quick=1.0):
                        return
                except Exception:
                    pass
            self.ensure_in_app(max_attempts=3, settle_each=8)

        def back_to_list(self):
            listbar = ListToolbar(self.driver)
            self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
            wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, 20))
            listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
            self._app_ready_fast = True

        # -------- Internal helpers --------
        def _click_list_create(self, timeout: int | None = None):
            listbar = ListToolbar(self.driver)
            listbar.click_create(timeout or self._el()._timeout)
            wait_ui5_idle(self.driver, timeout=timeout or self._el()._timeout)
            self._wait_not_busy(timeout or self._el()._timeout)

        def _read_last_toast_text(self) -> str:
            return ToastReader(self.driver).read_last()

        def _wait_object_header_ready(self, timeout: int) -> bool:
            return ObjectHeaderVerifier(self.driver).wait_ready(timeout=timeout)

        def _wait_for_success_toast_or_list(self, timeout: int) -> dict:
            listbar = ListToolbar(self.driver)
            dlg = DialogWatcher(self.driver)
            end = time.time() + max(timeout, self._el()._timeout)
            info = {"toast": "", "dialog": "", "at_list": False}
            while time.time() < end:
                if dlg.is_open():
                    info["dialog"] = dlg.text() or "Dialog open (no text captured)."
                    return info
                txt = ToastReader(self.driver).read_last()
                if txt:
                    info["toast"] = txt
                    lt = txt.lower()
                    if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                        return info
                try:
                    listbar.wait_create_clickable(timeout=0.8)
                    info["at_list"] = True
                    return info
                except Exception:
                    pass
                time.sleep(0.18)
            return info

        # -------- SOFT guard: ensure type contains 'M' (do not abort) --------
        def _soft_ensure_exch_type_contains_M(self, fields: Fields, desired_exch_type: str) -> dict:
            """
            Ensure the Exchange Rate Type *contains* 'M' BEFORE clicking Create,
            but do NOT abort the row pre-commit.
            """
            def _get():
                try:
                    return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
                except Exception:
                    return ""

            cur = _get()
            if "m" in cur.lower():
                return {"ok": True, "observed": cur}

            # corrective retype
            try:
                fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, desired_exch_type, press_enter=True)
            except Exception:
                pass
            # explicit blur to fire change bindings
            try:
                self.driver.execute_script(
                    """
                    try{
                    var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                    if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur&&el.blur(); }
                    }catch(e){}
                    """,
                    fields.EXCH_TYPE_INPUT_XPATH
                )
            except Exception:
                pass

            wait_ui5_idle(self.driver, timeout=self._el()._timeout)
            self._wait_not_busy(self._el()._timeout)

            cur2 = _get()
            return {"ok": ("m" in cur2.lower()), "observed": cur2}

        # ---------------- NEW helpers for your policy ----------------
        def _detect_lock_info(self, text: str) -> dict | None:
            if not text:
                return None
            low = text.lower()
            if "locked by user" in low and "table" in low and "tcurr" in low:
                m = re.search(r"Table\s+(\w+)\s+is\s+locked\s+by\s+user\s+([A-Za-z0-9_]+)", text, re.IGNORECASE)
                table = None
                owner = None
                if m:
                    table = m.group(1)
                    owner = m.group(2)
                return {"table": table or "TCURR", "owner": owner or ""}
            return None

        def _is_required_fields_dialog(self, s: str) -> bool:
            return "fill out all required entry fields" in (s or "").lower()

        def _is_duplicate_exists(self, s: str) -> bool:
            low = (s or "").lower()
            return ("exchange rate" in low) and ("already exists in the system" in low)

        # -------- Public: create + submit --------
        def create_entry_and_submit(
            self,
            exch_type: str,
            from_ccy: str,
            to_ccy: str,
            valid_from_ddmmyyyy: str,     # IMPORTANT: pass DD.MM.YYYY
            quotation: str,
            rate_str: str,
            commit_gate=None,
        ) -> dict:
            fields = Fields(self.driver)
            factors = Factors(self.driver)
            quote = QuotationField(self.driver)
            rate = ExchangeRateField(self.driver)
            footer = FooterActions(self.driver)
            listbar = ListToolbar(self.driver)
            dlg = DialogWatcher(self.driver)
            sidecol = SideColumnController(self.driver)
            validate = ValidationInspector(self.driver)

            el = self._el()

            # QUICK ensure to avoid heavy waits on every item
            self.ensure_in_app_quick()

            # ---------- local helpers ----------
            def _noop_gate_ctx():
                class _C:
                    def __enter__(self): return None
                    def __exit__(self, *a): return False
                return _C()

            def _verify_or_retype(xpath: str, expected: str) -> None:
                if expected is None:
                    return
                got = (fields.get_input_value(xpath) or "").strip()
                if got.lower() != (expected or "").strip().lower():
                    fields.set_plain_input(xpath, expected, press_enter=True)
                    _ = fields.get_input_value(xpath)

            def _verify_quotation(expected: str) -> None:
                try:
                    cur = _retry_stale(lambda: (self.driver.find_element(By.XPATH, QUOTATION_INNER_INPUT_XPATH).get_attribute("value") or "").strip())
                except Exception:
                    cur = ""
                if cur.lower() != (expected or "").strip().lower():
                    quote.set_value(expected)

            def _fill_all_fields(prefer_ui5_for_rate: bool = False):
                # 1) Exchange Rate Type
                fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, exch_type, press_enter=True)
                _verify_or_retype(fields.EXCH_TYPE_INPUT_XPATH, exch_type)

                # 2) From Currency
                fields.set_plain_input(fields.FROM_CCY_INPUT_XPATH, from_ccy, press_enter=True)
                _verify_or_retype(fields.FROM_CCY_INPUT_XPATH, from_ccy)

                # 3) To Currency
                fields.set_plain_input(fields.TO_CCY_INPUT_XPATH, to_ccy, press_enter=True)
                _verify_or_retype(fields.TO_CCY_INPUT_XPATH, to_ccy)

                # 4) Valid From — **DD.MM.YYYY**
                fields.set_plain_input(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy, press_enter=True)
                _verify_or_retype(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy)

                # 5) Quotation
                quote.set_value(quotation)
                _verify_quotation(quotation)

                # 6) Factors and Rate
                factors.try_set_from("1")
                factors.try_set_to("1")
                if prefer_ui5_for_rate:
                    rate.set_via_ui5(rate_str)
                    rate.commit(times=1)
                else:
                    rate.set_via_typing(rate_str)
                    rate.commit(times=2)

            def _looks_like_required_fields_issue(msgs: list[dict]) -> bool:
                if not msgs:
                    return False
                blob = " | ".join(
                    f"{(m.get('message') or '')} {m.get('description') or ''}".lower()
                    for m in msgs
                )
                keys = (
                    "fill out all required",
                    "required entry fields",
                    "required field",
                    "mandatory field",
                    "exchange rate type",
                    "from currency",
                )
                return any(k in blob for k in keys)

            def _commit_flow_under_gate() -> dict:
                gate_ctx = commit_gate() if callable(commit_gate) else _noop_gate_ctx()
                with gate_ctx:
                    first_phase = footer.click_create(clicks=1)

                    header_ready = self._wait_object_header_ready(timeout=min(10, max(8, el._timeout)))
                    if header_ready:
                        sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))
                        return {
                            "status": "created",
                            "footer_clicks": 1,
                            "intermediate_toasts": first_phase.get("toasts", []),
                            "toast": self._read_last_toast_text(),
                            "at_list": True,
                            "dialog_open": False,
                            "dialog_text": "",
                        }

                    loop_res = footer.ensure_created_by_loop_clicking(
                        object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                        at_list=lambda: listbar.is_at_list(quick=0.8),
                        close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                        total_timeout=max(35, el._timeout),
                        max_clicks=5,
                    )
                    if loop_res.get("status") in ("created", "dialog_open", "activation_error"):
                        return loop_res

                    final_phase = self._wait_for_success_toast_or_list(timeout=max(el._timeout, 18))
                    if not final_phase.get("at_list"):
                        sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))

                    if final_phase.get("dialog"):
                        return {
                            "status": "dialog_open",
                            "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                            "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                            "toast": final_phase.get("toast", ""),
                            "dialog_open": True,
                            "dialog_text": final_phase.get("dialog", ""),
                        }

                    status_guess = "created" if (
                        final_phase.get("at_list")
                        or (final_phase.get("toast") and any(k in final_phase.get("toast", "").lower()
                            for k in ("created", "activated", "successfully")))
                    ) else "unknown"

                    if status_guess != "created":
                        strict = footer.ensure_created_by_loop_clicking(
                            object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                            at_list=lambda: listbar.is_at_list(quick=0.8),
                            close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                            total_timeout=max(30, el._timeout),
                            max_clicks=5,
                        )
                        if strict.get("status") == "created":
                            return strict

                    return {
                        "status": status_guess,
                        "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                        "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                        "toast": final_phase.get("toast", ""),
                        "at_list": True,
                        "dialog_open": False,
                        "dialog_text": "",
                    }

            # 1) Open form
            self._click_list_create(timeout=el._timeout)

            # 2) Fill fields (DD.MM.YYYY is passed straight through)
            _fill_all_fields(prefer_ui5_for_rate=False)

            # 2.5) SOFT GUARD: ensure Exchange Rate Type *contains* "M"
            m_check = self._soft_ensure_exch_type_contains_M(fields, exch_type)

            # 3) Pre-submit validation (client)
            err = ValidationInspector(self.driver).collect()
            if err and "greater than zero" in (err or "").lower():
                Factors(self.driver).try_set_from("1")
                Factors(self.driver).try_set_to("1")
                ExchangeRateField(self.driver).set_via_ui5(rate_str)
                ExchangeRateField(self.driver).commit(times=1)
                err = ValidationInspector(self.driver).collect()

            # 4) COMMIT attempt
            res = _commit_flow_under_gate()
            status = (res.get("status") or "").lower()

            # 5) Post-commit note if M was missing pre-commit
            if not m_check.get("ok", True):
                res.setdefault("notes", {})
                res["notes"]["exch_type_missing_M_precommit"] = True
                res["notes"]["observed_exch_type"] = m_check.get("observed", "")

            # --- Build a combined message blob for policy checks
            msgs_from_res = res.get("messages", []) or []
            joined_msgs = " | ".join(f"{(m.get('message') or '')} {m.get('description') or ''}".strip() for m in msgs_from_res)
            joined_all = " | ".join([res.get("dialog_text") or "", joined_msgs]).strip()

            # *** NEW *** also read the Message Popover (this is where "already exists" lives)
            pop_msgs = []
            try:
                pop_msgs = footer.open_and_read_messages(timeout=max(6, el._timeout))
            except Exception:
                pop_msgs = []
            if pop_msgs:
                # add to the joined blob for the same downstream checks
                joined_all = " | ".join(filter(None, [joined_all, " | ".join(pop_msgs)]))
            # close popover (so footer buttons stay clickable)
            try:
                footer.close_message_popover_if_open(timeout=3)
            except Exception:
                pass

            # === POLICY REMAP ===
            # TCURR lock anywhere → Pending (not Locked)
            lock = self._detect_lock_info(joined_all)
            if lock:
                try: DialogWatcher(self.driver).close(timeout=1.0)
                except Exception: pass
                SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
                try: self.back_to_list()
                except Exception: pass
                return {
                    "status": "pending",
                    "dialog_open": False,
                    "dialog_text": res.get("dialog_text", ""),
                    "notes": {
                        "lock_table": lock.get("table", "TCURR"),
                        "lock_owner": lock.get("owner", ""),
                        "reason": "table_lock_tcurr"
                    }
                }

            # Duplicate exists → Skipped **AND discard draft** (new behavior)
            # keep your existing detector, but now it sees popover text too
            if self._is_duplicate_exists(joined_all) or ("already exists" in joined_all.lower()):
                # close any popover/dialog so the footer is clickable
                try: DialogWatcher(self.driver).close(timeout=1.2)
                except Exception: pass
                try: footer.close_message_popover_if_open(timeout=2)
                except Exception: pass

                # attempt to discard the draft quietly
                try:
                    _discarded = footer.discard_draft(timeout=max(8, el._timeout))
                except Exception:
                    _discarded = False

                # close side column (no-op if already closed) and go back to list
                SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
                try: self.back_to_list()
                except Exception: pass

                out = {
                    "status": "skipped",
                    "dialog_open": False,
                    "dialog_text": res.get("dialog_text", ""),
                    "notes": {
                        "already_existed": True,
                        "draft_discarded": bool(_discarded),
                        "message_count": len(pop_msgs) if pop_msgs else len(msgs_from_res),
                    },
                }
                return out

            # Created passes through as Created (runner/worker mapping unchanged)
            if status == "created":
                return res

            # Unknown: re-queue → map to 'pending'
            if status == "unknown":
                res["status"] = "pending"
                return res

            # anything else → return as-is (error/activation_error/dialog_open, etc.)
            return res

        def create_rate(
            self,
            exch_type: str,
            from_ccy: str,
            to_ccy: str | None = None,
            valid_from_mmddyyyy: str = "",
            quotation: str = "",
            rate_value: str | float = "",
            to_cy: str | None = None,
            commit_gate=None,
        ) -> dict:
            """
            NOTE: pass date in **DD.MM.YYYY**. We DO NOT convert here.
            services.schemas.ExchangeRateItem already normalizes to DD.MM.YYYY.
            """
            if to_ccy is None and to_cy is not None:
                to_ccy = to_cy
            if to_ccy is None:
                raise TypeError("create_rate() missing required argument: 'to_ccy'")

            valid_from_ddmmyyyy = valid_from_mmddyyyy

            return self.create_entry_and_submit(
                exch_type=exch_type,
                from_ccy=from_ccy,
                to_ccy=to_ccy,
                valid_from_ddmmyyyy=valid_from_ddmmyyyy,   # typed as-is
                quotation=quotation,
                rate_str=str(rate_value),
                commit_gate=commit_gate,
            )


    # pages\CurrencyExchangeRates\selectors.py

    # pages/CurrencyExchangeRates/selectors.py
    APP_HASH = "#Currency-maintainExchangeRates"


    # pages\CurrencyExchangeRates\__init__.py



    # pages\Index\page.py

    # pages/Index/page.py
    from core.base import Page
    from services.ui import wait_ui5_idle
    from .PurchasingTab.element import PurchasingTab
    from .ProcurementOverviewTile.element import ProcurementOverviewTile

    class IndexPage(Page):
        """Fiori Launchpad 'Shell-home' landing."""

        def ensure_home(self):
            wait_ui5_idle(self.driver)

        def to_purchasing(self):
            PurchasingTab(self.driver).click()
            wait_ui5_idle(self.driver)

        def open_procurement_overview(self):
            ProcurementOverviewTile(self.driver).click()
            wait_ui5_idle(self.driver)


    # pages\Index\__init__.py



    # pages\Login\page.py

    from core.base import Page
    from services.config import config
    from .elements.Username.element import Username
    from .elements.Password.element import Password
    from .elements.Submit.element import Submit

    class LoginPage(Page):
        def go(self):
            self.open(config()["SAP_URL"])

        def login(self, username: str, password: str):
            self.go()
            Username(self.driver).set(username)
            Password(self.driver).set(password)
            Submit(self.driver).click()
            # Post-click, S/4HANA may keep same URL but replace DOM; verification is in services.ui


    # pages\Login\__init__.py



    # pages\Shell\__init__.py



    # pages\CurrencyExchangeRates\elements\__init__.py



    # pages\CurrencyExchangeRates\elements\Dialog\element.py

    # pages/CurrencyExchangeRates/elements/Dialog/element.py
    from __future__ import annotations

    from typing import Optional
    import time

    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import (
        TimeoutException,
        StaleElementReferenceException,
        NoSuchElementException,
    )

    from core.base import Element

    # Robust selectors for the Message Popover
    _POPOVER_WRAPPER_CSS = ".sapMPopoverWrapper"
    _POPOVER_CONT_CSS    = ".sapMPopoverCont"
    _CLOSE_BTN_CSS       = "button.sapMMsgPopoverCloseBtn"   # the “X” button
    # Title/span for message text (works for list view items)
    _MSG_ITEM_TITLE_XP   = "//li[contains(@class,'sapMMsgViewItem')]" \
                            "//span[contains(@id,'-titleText')]"

    # Generic dialog “Close” button by visible text
    _CLOSE_BDI_BTN_XP    = "//bdi[normalize-space()='Close']/ancestor::button[1] | //button[.//bdi[normalize-space()='Close']]"
    # Generic OK button (fallbacks)
    _OK_BDI_BTN_XP       = "//bdi[normalize-space()='OK']/ancestor::button[1] | //button[.//bdi[normalize-space()='OK']]"

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None


    class DialogWatcher:
        """
        Handles both classic sap.m.Dialog and the Message Popover.
        Now also knows how to click a <bdi>Close</bdi> button exactly like:
        <span class="sapMBtnContent"><bdi>Close</bdi></span>
        """

        def __init__(self, driver):
            self.driver = driver
            self._el = Element(driver)

        # ---------- basic checks ----------
        def _any_popover_present(self) -> bool:
            def _see():
                els = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
                return any((e.is_displayed() for e in els))
            try:
                return _retry_stale(_see)
            except Exception:
                return False

        def is_open(self) -> bool:
            if self._any_popover_present():
                return True
            try:
                return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _CLOSE_BDI_BTN_XP)))
            except Exception:
                pass
            try:
                return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _OK_BDI_BTN_XP)))
            except Exception:
                pass
            return False

        # ---------- text scraping ----------
        def text(self, timeout: float = 0.5) -> str:
            end = time.time() + timeout
            while time.time() < end:
                try:
                    el = WebDriverWait(self.driver, 0.25, ignored_exceptions=(StaleElementReferenceException,)).until(
                        EC.presence_of_element_located((By.XPATH, _MSG_ITEM_TITLE_XP))
                    )
                    if el.is_displayed():
                        try:
                            return el.text.strip()
                        except StaleElementReferenceException:
                            pass
                    break
                except Exception:
                    pass
            try:
                return (self.driver.execute_script("""
                    try{
                    var dlg = document.querySelector("div[role='dialog']");
                    if(!dlg) return '';
                    var h = dlg.querySelector(".sapMDialogTitle, .sapMTitle, [role='heading']");
                    return (h && (h.innerText||h.textContent)||'').trim();
                    }catch(e){ return ''; }
                """) or "").strip()
            except Exception:
                return ""

        # ---------- close helpers ----------
        def _try_click_close_button_once(self) -> bool:
            try:
                pops = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
                for pop in pops:
                    try:
                        if not pop.is_displayed():
                            continue
                    except StaleElementReferenceException:
                        continue
                    try:
                        btn = pop.find_element(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                    except NoSuchElementException:
                        try:
                            btns = self.driver.find_elements(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                            btn  = next((b for b in btns if b.is_displayed()), None)
                        except StaleElementReferenceException:
                            btn = None
                    if btn:
                        try:
                            self._el.js_click(btn)
                            return True
                        except StaleElementReferenceException:
                            pass
            except StaleElementReferenceException:
                return False
            except Exception:
                return False
            return False

        def _js_fallback_close_all_popovers(self) -> bool:
            try:
                return bool(self.driver.execute_script("""
                    try{
                    var closed = 0;
                    document.querySelectorAll('button.sapMMsgPopoverCloseBtn').forEach(function(b){
                        try{
                        var r = b.getBoundingClientRect();
                        var visible = !!(r.width || r.height) && window.getComputedStyle(b).visibility !== 'hidden';
                        if (visible) { b.click(); closed++; }
                        }catch(e){}
                    });
                    return closed > 0;
                    }catch(e){ return false; }
                """))
            except Exception:
                return False

        def _click_bdi_close(self) -> bool:
            try:
                btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.XPATH, _CLOSE_BDI_BTN_XP))
                )
                try:
                    self._el.js_click(btn)
                except Exception:
                    try:
                        btn.click()
                    except Exception:
                        pass
                return True
            except Exception:
                return False

        def _click_ok(self) -> bool:
            try:
                btn = WebDriverWait(self.driver, 1.0, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.XPATH, _OK_BDI_BTN_XP))
                )
                try:
                    self._el.js_click(btn)
                except Exception:
                    try:
                        btn.click()
                    except Exception:
                        pass
                return True
            except Exception:
                return False

        # ---------- public API ----------
        def close(self, timeout: float = 2.0) -> bool:
            end = time.time() + max(0.2, timeout)

            while time.time() < end:
                # Popover?
                if self._any_popover_present():
                    for _ in (1, 2):
                        if self._try_click_close_button_once():
                            try:
                                WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                                    EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                                )
                            except Exception:
                                pass
                            if not self._any_popover_present():
                                return True
                    if self._js_fallback_close_all_popovers():
                        try:
                            WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                                EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                            )
                        except Exception:
                            pass
                        if not self._any_popover_present():
                            return True

                # Dialog “Close”
                if self._click_bdi_close():
                    time.sleep(0.15)
                    if not self.is_open():
                        return True

                # Dialog “OK” fallback
                if self._click_ok():
                    time.sleep(0.15)
                    if not self.is_open():
                        return True

                time.sleep(0.12)

            return not self.is_open()


    # pages\CurrencyExchangeRates\elements\Dialog\selectors.py

    # Generic dialog root
    DIALOG_ROOT_CSS = "div[role='dialog']"


    # pages\CurrencyExchangeRates\elements\Dialog\__init__.py



    # pages\CurrencyExchangeRates\elements\DraftFinder\element.py

    # pages/CurrencyExchangeRates/elements/DraftFinder/element.py
    from __future__ import annotations

    import time
    from typing import List, Tuple

    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import (
        StaleElementReferenceException,
        TimeoutException,
        ElementClickInterceptedException,
        ElementNotInteractableException,
    )

    from core.base import Element
    from services.ui import wait_ui5_idle


    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None


    # ---------- Selectors (robust by suffix/text) ----------
    DATE_INPUT_INNER_XP = (
        "//input[substring(@id,string-length(@id)-string-length("
        "'ExchangeRateEffectiveDateFoEd-input-inner')+1)='ExchangeRateEffectiveDateFoEd-input-inner']"
    )

    # Rows in the ListReport table
    ROW_XP = "//main//table//tbody/tr[contains(@id,'ListReportTable:::ColumnListItem')]"

    # A row is Draft if column 8 contains a 'DraftObjectMarker' link with 'Draft' text
    ROW_IS_DRAFT_REL_XP = (
        "./td[8]//a[contains(@id,'DraftObjectMarker')]"
        "[.//span[contains(normalize-space(),'Draft')]]"
    )

    # Row checkbox (multi-select checkbox cell) – handle both input[role=checkbox] & div.sapMCb
    ROW_CHECKBOX_REL_XP = (
        ".//*[@role='checkbox' and (contains(@id,'selectMulti') or contains(@class,'sapMCb'))]"
        " | .//div[contains(@class,'sapMCb') and contains(@id,'selectMulti')]"
    )

    # Toolbar Delete button in ListReport
    LIST_DELETE_BTN_XP = (
        "//button[substring(@id,string-length(@id)-string-length('--deleteEntry')+1)='--deleteEntry']"
        " | //bdi[normalize-space()='Delete']/ancestor::button[1]"
    )

    # Confirmation dialog root & its Delete button
    DIALOG_ROOT_XP = "//div[@role='alertdialog' or contains(@class,'sapMDialog')]"
    DIALOG_DELETE_BTN_XP = (
        "("
        "//div[@role='alertdialog' or contains(@class,'sapMDialog')]"
        "//button[.//bdi[normalize-space()='Delete']]"
        ")[last()]"
    )


    class DraftFinder(Element):
        """
        UI helper to:
        - Set the List Report 'Exchange Rate Effective Date' and APPLY (Enter)
        - Wait until table rows are (re)loaded
        - Pre-scroll a couple times to trigger initial row rendering
        - Detect draft rows
        - Delete draft rows (check → Delete → confirm)
        """

        # ---------- Date filter ----------
        def set_effective_date_and_apply(self, dd_mm_yyyy: str, timeout: int = 20) -> bool:
            """
            Set the filter date to DD.MM.YYYY and press Enter so the table reloads.
            Returns True if we believe the list refreshed.
            """
            wait = WebDriverWait(self.driver, timeout)
            try:
                inp = wait.until(EC.element_to_be_clickable((By.XPATH, DATE_INPUT_INNER_XP)))
            except TimeoutException:
                return False

            def _focus():
                try:
                    self.js_click(inp)
                except Exception:
                    inp.click()

            _retry_stale(_focus)
            # Hard clear
            for fn in (
                lambda: inp.clear(),
                lambda: inp.send_keys(Keys.CONTROL, "a"),
                lambda: inp.send_keys(Keys.DELETE),
            ):
                try:
                    _retry_stale(fn)
                except Exception:
                    pass

            _retry_stale(lambda: inp.send_keys(dd_mm_yyyy))
            _retry_stale(lambda: inp.send_keys(Keys.ENTER))  # APPLY
            # tiny blur to ensure binding fires
            try:
                self.driver.execute_script(
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));"
                    "arguments[0].blur && arguments[0].blur();",
                    inp,
                )
            except Exception:
                pass

            wait_ui5_idle(self.driver, timeout=max(8, timeout))
            time.sleep(0.2)
            return True

        # ---------- Table readiness ----------
        def wait_rows_loaded(self, timeout: int = 12) -> bool:
            """
            Wait until either (a) some table rows are present or (b) no results rendered.
            """
            end = time.time() + max(1, timeout)
            while time.time() < end:
                try:
                    rows = self.driver.find_elements(By.XPATH, ROW_XP)
                    if rows:  # some rows exist (even if not draft)
                        return True
                except Exception:
                    pass
                wait_ui5_idle(self.driver, timeout=2)
                time.sleep(0.15)
            # Even if no rows, treat as 'loaded' so the delete loop can just find nothing and exit.
            return True

        # ---------- Scrolling ----------
        def pre_scroll(self, times: int = 2, settle: float = 0.4):
            """
            Send PAGE_DOWN a few times to let UI5 render initial rows.
            """
            body = None
            try:
                body = self.driver.find_element(By.TAG_NAME, "body")
            except Exception:
                return
            for _ in range(max(0, int(times))):
                try:
                    body.send_keys(Keys.PAGE_DOWN)
                except Exception:
                    pass
                wait_ui5_idle(self.driver, timeout=6)
                time.sleep(settle)

        # ---------- Rows & Draft detection ----------
        def _rows_now(self):
            return self.driver.find_elements(By.XPATH, ROW_XP)

        def visible_draft_rows(self) -> List:
            rows = self._rows_now()
            out = []
            for r in rows:
                try:
                    if r.find_elements(By.XPATH, ROW_IS_DRAFT_REL_XP):
                        out.append(r)
                except StaleElementReferenceException:
                    continue
            return out

        # ---------- Delete helpers ----------
        def _tick_row_checkbox(self, row) -> bool:
            """
            Robustly tick the row checkbox:
            - scroll row & checkbox into view
            - JS click → native click → SPACE toggle on row
            - verify aria-checked turns 'true'
            """
            # Try locating checkbox inside the row
            try:
                cb = row.find_element(By.XPATH, ROW_CHECKBOX_REL_XP)
            except Exception:
                return False

            def _scroll_into_view(el):
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                except Exception:
                    pass

            def _checked() -> bool:
                try:
                    state = (cb.get_attribute("aria-checked") or "").strip().lower()
                    if state == "true":
                        return True
                    # Some skins put the state on nested input/span; check again
                    inner = None
                    try:
                        inner = cb.find_element(By.XPATH, ".//*[@aria-checked]")
                    except Exception:
                        inner = None
                    if inner:
                        st2 = (inner.get_attribute("aria-checked") or "").strip().lower()
                        return st2 == "true"
                    return False
                except Exception:
                    return False

            # If already checked, we're good
            if _checked():
                return True

            # 1) JS click
            _scroll_into_view(row)
            _scroll_into_view(cb)
            try:
                self.js_click(cb)
            except Exception:
                pass
            time.sleep(0.05)
            if _checked():
                return True

            # 2) native click
            try:
                cb.click()
            except (ElementClickInterceptedException, ElementNotInteractableException):
                pass
            except Exception:
                pass
            time.sleep(0.05)
            if _checked():
                return True

            # 3) SPACE on row to toggle selection
            try:
                row.click()
            except Exception:
                pass
            try:
                row.send_keys(Keys.SPACE)
            except Exception:
                pass
            time.sleep(0.08)
            if _checked():
                return True

            # 4) As last resort, click first cell area (some themes require cell hit)
            try:
                first_cell = row.find_element(By.XPATH, "./td[1]")
                _scroll_into_view(first_cell)
                try:
                    self.js_click(first_cell)
                except Exception:
                    try:
                        first_cell.click()
                    except Exception:
                        pass
            except Exception:
                pass
            time.sleep(0.08)
            return _checked()

        def _click_list_delete(self, timeout: int = 8) -> bool:
            try:
                btn = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((By.XPATH, LIST_DELETE_BTN_XP))
                )
            except TimeoutException:
                return False
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                btn.click()
            except Exception:
                try:
                    self.js_click(btn)
                except Exception:
                    return False
            wait_ui5_idle(self.driver, timeout=timeout)
            return True

        def _confirm_dialog_delete(self, timeout: int = 12) -> bool:
            # Wait for dialog to appear (briefly)
            try:
                WebDriverWait(self.driver, min(6, timeout)).until(
                    EC.presence_of_element_located((By.XPATH, DIALOG_ROOT_XP))
                )
            except TimeoutException:
                # Sometimes confirm is instant; continue
                pass

            # Click 'Delete' in dialog
            try:
                btn = WebDriverWait(self.driver, timeout).until(
                    EC.element_to_be_clickable((By.XPATH, DIALOG_DELETE_BTN_XP))
                )
            except TimeoutException:
                return False

            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                btn.click()
            except Exception:
                try:
                    self.js_click(btn)
                except Exception:
                    return False

            wait_ui5_idle(self.driver, timeout=timeout)
            # Wait until dialog is gone
            try:
                WebDriverWait(self.driver, min(6, timeout)).until_not(
                    EC.presence_of_element_located((By.XPATH, DIALOG_ROOT_XP))
                )
            except Exception:
                pass
            return True

        # ---------- Public: delete all visible drafts ----------
        def delete_visible_drafts(self, per_click_timeout: int = 12):
            """
            Returns (deleted_count, attempts, deleted_sample:list[str])
            """
            deleted = 0
            attempts = 0
            sample: list[str] = []

            while True:
                drafts = self.visible_draft_rows()
                if not drafts:
                    break

                row = drafts[0]
                attempts += 1

                # Grab a small label from columns (From/To/Date) BEFORE deletion
                try:
                    # adjust column indexes if needed
                    from_ccy = (row.find_element(By.XPATH, "./td[2]").text or "").strip()
                    to_ccy   = (row.find_element(By.XPATH, "./td[3]").text or "").strip()
                    date_txt = (row.find_element(By.XPATH, "./td[4]").text or "").strip()
                    label = f"{from_ccy}->{to_ccy} @ {date_txt}"
                except Exception:
                    label = "draft-row"

                if not self._tick_row_checkbox(row):
                    wait_ui5_idle(self.driver, timeout=4)
                    time.sleep(0.2)
                    continue

                if not self._click_list_delete(timeout=per_click_timeout):
                    continue

                if self._confirm_dialog_delete(timeout=per_click_timeout):
                    deleted += 1
                    if len(sample) < 10:
                        sample.append(label)

                wait_ui5_idle(self.driver, timeout=per_click_timeout)
                time.sleep(0.25)

            return deleted, attempts, sample
        
        def wait_rows_loaded(self, timeout: int = 12) -> bool:
            """
            Wait until at least one table row is present/visible.
            """
            try:
                WebDriverWait(self.driver, timeout).until(
                    EC.presence_of_element_located((By.XPATH, ROW_XP))
                )
                return True
            except TimeoutException:
                return False


    # pages\CurrencyExchangeRates\elements\DraftFinder\selectors.py

    # XPaths & ID suffixes used by DraftFinder

    # Table rows in the List Report
    ROWS_XPATH = ("//main//table//tbody"
                "/tr[contains(@id,'ListReportTable:::ColumnListItem')]")

    # A row is Draft if col 8 contains the Draft marker link
    DRAFT_MARKER_REL_XP = (
        "./td[8]//a[contains(@id,'DraftObjectMarker')"
        " and .//span[contains(normalize-space(),'Draft')]]"
    )

    # Row checkbox (multi-select) — works from the row root
    ROW_CHECKBOX_REL_XP = (
        ".//div[contains(@id,'-selectMulti') and contains(@class,'sapMCb')]"
    )

    # List-level “Delete” button (toolbar)
    LIST_DELETE_BTN_SUFFIX = "--deleteEntry"

    # Delete confirmation dialog + its Delete button
    CONFIRM_DIALOG_ROLE = "alertdialog"
    CONFIRM_DELETE_BTN_XP = (
        "//button[.//bdi[normalize-space()='Delete']]"
        " | //bdi[normalize-space()='Delete']/ancestor::button[1]"
    )


    # pages\CurrencyExchangeRates\elements\DraftFinder\__init__.py

    # export DraftFinder for dotted imports
    from .element import DraftFinder

    __all__ = ["DraftFinder"]


    # pages\CurrencyExchangeRates\elements\ExcelExport\element.py

    # pages/CurrencyExchangeRates/elements/ExcelExport/element.py
    from __future__ import annotations

    import time
    from pathlib import Path
    from typing import Optional, Tuple

    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import (
        EXPORT_SPLIT_BTN_IMG_ID_SUFFIX,
        EXPORT_BTN_GENERIC_XP,
    )


    class ExcelExporter(Element):
        """
        Clicks the ListReport 'Export' action and waits for an .xlsx file to appear
        in the provided download directory.

        Returns (xlsx_path, size_bytes) on success, or (None, 0) on failure.
        """

        def _click_export_button(self, timeout: int = 15) -> bool:
            # 1) Try via the icon <span> id suffix, then click its owning button
            try:
                btn_id = self.driver.execute_script(
                    """
                    var suf = arguments[0];
                    var nodes = document.querySelectorAll('[id$="'+suf+'"]');
                    function visible(el){
                    if(!el) return false;
                    var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect();
                    return (r.width>0 && r.height>0);
                    }
                    for (var i=nodes.length-1;i>=0;i--){
                    var el=nodes[i]; if(!visible(el)) continue;
                    var btn = el.closest('button');
                    if(btn) return btn.id;
                    }
                    return null;
                    """,
                    EXPORT_SPLIT_BTN_IMG_ID_SUFFIX
                )
                if btn_id:
                    btn = WebDriverWait(self.driver, timeout).until(
                        EC.element_to_be_clickable((By.ID, btn_id))
                    )
                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                    except Exception:
                        pass
                    try:
                        btn.click()
                    except Exception:
                        self.js_click(btn)
                    wait_ui5_idle(self.driver, timeout=timeout)
                    return True
            except Exception:
                pass

            # 2) Fallbacks by label/aria/title/xpath
            variants = [
                EXPORT_BTN_GENERIC_XP,
                "//button[.//bdi[contains(normalize-space(),'Export to Spreadsheet')]]",
                "//button[.//bdi[normalize-space()='Export']]",
                "//button[@aria-label='Export' or @title='Export']",
                "//button[contains(@id,'btnExcelExport')]",
            ]
            for xp in variants:
                try:
                    btn = WebDriverWait(self.driver, 3).until(
                        EC.element_to_be_clickable((By.XPATH, xp))
                    )
                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                    except Exception:
                        pass
                    try:
                        btn.click()
                    except Exception:
                        self.js_click(btn)
                    wait_ui5_idle(self.driver, timeout=timeout)
                    return True
                except Exception:
                    continue

            return False

        def _maybe_click_menu_item(self) -> None:
            """
            Some UIs open a mini menu after the split button.
            Try a couple of common menu item locators.
            """
            try:
                for xp in (
                    "//div[contains(@class,'sapMSelectList') or contains(@class,'sapMList')]//span[normalize-space()='Export']",
                    "//bdi[normalize-space()='Export to Spreadsheet']/ancestor::button[1]",
                    "//bdi[normalize-space()='Export']/ancestor::button[1]",
                ):
                    try:
                        itm = WebDriverWait(self.driver, 2).until(
                            EC.element_to_be_clickable((By.XPATH, xp))
                        )
                        try:
                            itm.click()
                        except Exception:
                            self.js_click(itm)
                        wait_ui5_idle(self.driver, timeout=6)
                        return
                    except Exception:
                        continue
            except Exception:
                pass

        def _wait_xlsx(self, download_dir: Path, timeout: int = 120) -> Tuple[Optional[Path], int]:
            end = time.time() + max(1, timeout)
            last: Optional[Path] = None
            while time.time() < end:
                files = sorted(download_dir.glob("*.xlsx"), key=lambda p: p.stat().st_mtime, reverse=True)
                if files:
                    cand = files[0]
                    # consider download complete when .crdownload is gone
                    if not cand.with_suffix(cand.suffix + ".crdownload").exists():
                        try:
                            size = cand.stat().st_size
                        except Exception:
                            size = 0
                        return cand, size
                time.sleep(0.6)
            return last, 0

        def export_now(self, download_dir: Path, timeout: int = 90) -> Tuple[Optional[Path], int]:
            if not self._click_export_button(timeout=min(timeout, 20)):
                return None, 0
            self._maybe_click_menu_item()
            return self._wait_xlsx(Path(download_dir), timeout=timeout)


    # pages\CurrencyExchangeRates\elements\ExcelExport\selectors.py

    # pages/CurrencyExchangeRates/elements/ExcelExport/selectors.py

    # The <span> id suffix you showed — we click the owning button of that icon
    EXPORT_SPLIT_BTN_IMG_ID_SUFFIX = "--listReport-btnExcelExport-internalSplitBtn-textButton-img"

    # Generic fallback for the Export button
    EXPORT_BTN_GENERIC_XP = (
        "//button[.//bdi[normalize-space()='Export to Spreadsheet'] or .//bdi[normalize-space()='Export']]"
    )


    # pages\CurrencyExchangeRates\elements\ExcelExport\__init__.py

    from .element import ExcelExporter
    __all__ = ["ExcelExporter"]


    # pages\CurrencyExchangeRates\elements\Factors\element.py

    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.common.exceptions import StaleElementReferenceException
    import time

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import FROM_FACTOR_BY_LABEL_XPATH, TO_FACTOR_BY_LABEL_XPATH

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None

    class Factors(Element):
        def _try_set_by_label(self, label_xpath: str, value: str = "1") -> bool:
            def _find():
                return self.driver.find_element(By.XPATH, label_xpath)

            try:
                inp = _retry_stale(_find)
            except Exception:
                return False

            try:
                for fn in (
                    lambda: inp.clear(),
                    lambda: inp.send_keys(Keys.CONTROL, "a"),
                    lambda: inp.send_keys(Keys.DELETE),
                    lambda: self.driver.execute_script(
                        "arguments[0].value='';"
                        "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                        "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
                ):
                    try:
                        _retry_stale(fn)
                    except Exception:
                        pass

                _retry_stale(lambda: inp.send_keys(value))
                try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
                except Exception: pass
                wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
                return True
            except Exception:
                return False

        def try_set_from(self, value: str = "1") -> bool:
            return self._try_set_by_label(FROM_FACTOR_BY_LABEL_XPATH, value)

        def try_set_to(self, value: str = "1") -> bool:
            return self._try_set_by_label(TO_FACTOR_BY_LABEL_XPATH, value)


    # pages\CurrencyExchangeRates\elements\Factors\selectors.py

    FROM_FACTOR_BY_LABEL_XPATH = (
        "("
        "//label[.//bdi[normalize-space()='From Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
        "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Unit')]]"
        "/following::input[contains(@id,'-inner')][1] | "
        "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Factor')]]"
        "/following::input[contains(@id,'-inner')][1]"
        ")"
    )
    TO_FACTOR_BY_LABEL_XPATH = (
        "("
        "//label[.//bdi[normalize-space()='To Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
        "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Unit')]]"
        "/following::input[contains(@id,'-inner')][1] | "
        "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Factor')]]"
        "/following::input[contains(@id,'-inner')][1]"
        ")"
    )


    # pages\CurrencyExchangeRates\elements\Factors\__init__.py



    # pages\CurrencyExchangeRates\elements\Fields\element.py

    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.common.exceptions import StaleElementReferenceException
    import time

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import (
        EXCH_TYPE_INPUT_XPATH,
        FROM_CCY_INPUT_XPATH,
        TO_CCY_INPUT_XPATH,
        VALID_FROM_INPUT_XPATH,
    )

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None

    class Fields(Element):
        EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,'ExchangeRateTypeForEdit::Field-input-inner')]")
        FROM_CCY_INPUT_XPATH  = ("//input[contains(@id,'SourceCurrencyForEdit::Field-input-inner')]")
        TO_CCY_INPUT_XPATH    = ("//input[contains(@id,'TargetCurrencyForEdit::Field-input-inner')]")
        VALID_FROM_INPUT_XPATH= ("//input[contains(@id,'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')]")

        def _hard_clear(self, web_el):
            for fn in (
                lambda: web_el.clear(),
                lambda: web_el.send_keys(Keys.CONTROL, "a"),
                lambda: web_el.send_keys(Keys.DELETE),
                lambda: self.driver.execute_script(
                    "arguments[0].value='';"
                    "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", web_el),
            ):
                try: _retry_stale(fn)
                except Exception: pass

        def get_input_value(self, xpath: str) -> str:
            def _get():
                el = self.find(By.XPATH, xpath)
                return el.get_attribute("value") or ""
            try:
                return _retry_stale(_get)
            except Exception:
                return ""

        def set_plain_input(self, xpath: str, text: str, press_enter: bool = False) -> None:
            def _get():
                return self.wait_clickable(By.XPATH, xpath)
            inp = _retry_stale(_get)

            def _focus_click():
                try:
                    self.js_click(inp)
                except Exception:
                    inp.click()
            _retry_stale(_focus_click)

            _retry_stale(lambda: inp.clear())
            _retry_stale(lambda: inp.send_keys(str(text or "")))
            if press_enter:
                _retry_stale(lambda: inp.send_keys(Keys.ENTER))
            try:
                self.driver.execute_script(
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true})); arguments[0].blur && arguments[0].blur();",
                    inp
                )
            except Exception:
                pass
            # tiny settle helps UI5 bindings stabilize before subsequent reads
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 3))


    # pages\CurrencyExchangeRates\elements\Fields\selectors.py

    EXCH_TYPE_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('ExchangeRateTypeForEdit::Field-input-inner')+1)="
        "'ExchangeRateTypeForEdit::Field-input-inner']"
    )
    FROM_CCY_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('SourceCurrencyForEdit::Field-input-inner')+1)="
        "'SourceCurrencyForEdit::Field-input-inner']"
    )
    TO_CCY_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('TargetCurrencyForEdit::Field-input-inner')+1)="
        "'TargetCurrencyForEdit::Field-input-inner']"
    )
    VALID_FROM_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')+1)="
        "'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner']"
    )


    # pages\CurrencyExchangeRates\elements\Fields\__init__.py



    # pages\CurrencyExchangeRates\elements\Footer\element.py

    # elements/Footer/element.py
    import time
    from typing import Callable, Dict

    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, WebDriverException, StaleElementReferenceException

    from core.base import Element, fluent_wait
    from services.ui import wait_ui5_idle
    from ..Dialog.element import DialogWatcher
    from ..Toast.element import ToastReader
    from ..Messages.element import Ui5Messages
    from ..Status.element import StatusProbe
    from .selectors import (
        ACTIVATE_CREATE_BTN_XPATH,
        FORM_CREATE_OR_SAVE_BTN_XPATH,
        ACTIVATE_CREATE_BTN_CSS,
        HEADER_TITLE_ID_SUFFIX,
        EDIT_BTN_ID_SUFFIX,
        DISCARD_BTN_ID_SUFFIX,
        COPY_BTN_ID_CONTAINS,
        MESSAGE_BTN_SUFFIX,
        MSG_POPOVER_CLOSE_BTN_XP,
        MSG_ITEMS_XP, 
    )

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None


    class FooterActions(Element):
        """
        Submit logic with:
        - first attempt click
        - loop clicking with DOM/MessageManager checks
        - uses StatusProbe for robust success detection
        """

        EXTRA_SETTLE_SEC = 0.2  # trimmed
        def open_and_read_messages(self, timeout: int = 8) -> list[str]:
            """
            Clicks the footer 'Messages' button to open the Message Popover (if badge > 0),
            returns a list of visible message titles (strings). Leaves the popover open.
            """
            # Find the footer messages button
            try:
                msg_btn_id = self._query_visible_by_suffix(MESSAGE_BTN_SUFFIX)
            except Exception:
                msg_btn_id = None

            if not msg_btn_id:
                return []

            # Read the badge text quickly (optional; if not found, still click)
            badge_text = ""
            try:
                badge_bdi = self.driver.find_element(By.ID, f"{msg_btn_id}-BDI-content")
                badge_text = (badge_bdi.text or "").strip()
            except Exception:
                pass

            # If nothing to show (badge empty/0), bail early
            if badge_text and badge_text.isdigit() and int(badge_text) == 0:
                return []

            # Open the popover (toggle)
            try:
                btn = WebDriverWait(self.driver, 3, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.ID, msg_btn_id))
                )
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                except Exception:
                    pass
                try:
                    btn.click()
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", btn)
                    except Exception:
                        pass
            except Exception:
                return []

            # Wait for message items to render
            try:
                WebDriverWait(self.driver, timeout, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.presence_of_element_located((By.XPATH, MSG_ITEMS_XP))
                )
            except TimeoutException:
                return []

            # Collect item titles
            texts = []
            try:
                items = self.driver.find_elements(By.XPATH, MSG_ITEMS_XP)
                for it in items:
                    try:
                        txt = (it.text or "").strip()
                        if txt:
                            texts.append(txt)
                    except Exception:
                        continue
            except Exception:
                pass
            return texts


        # ---------- finding & UI5 press helpers ----------
        def _query_visible_by_suffix(self, suffix: str) -> str | None:
            try:
                return self.driver.execute_script(
                    """
                    var suffix = arguments[0];
                    var nodes = document.querySelectorAll("[id$='"+suffix.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                    function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                    for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                    return null;
                    """,
                    suffix,
                )
            except Exception:
                return None

        def _header_aria_label(self) -> str:
            try:
                return self.driver.execute_script(
                    """
                    var suf = arguments[0];
                    var nodes = document.querySelectorAll("[id$='"+suf.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                    function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                    for (var i=nodes.length-1;i>=0;i--){ var el=nodes[i]; if(!vis(el)) continue;
                    var a=(el.getAttribute('aria-label')||'').trim(); if(a) return a; }
                    return '';
                    """,
                    HEADER_TITLE_ID_SUFFIX,
                ) or ""
            except Exception:
                return ""

        def _query_activate_id(self) -> str | None:
            try:
                return self.driver.execute_script(
                    """
                    var sel = arguments[0], nodes = document.querySelectorAll(sel);
                    function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                    for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                    return null;
                    """,
                    ACTIVATE_CREATE_BTN_CSS,
                )
            except Exception:
                return None

        def _really_clickable(self, dom_id: str) -> bool:
            try:
                return bool(self.driver.execute_script(
                    """
                    try {
                    var el=document.getElementById(arguments[0]); if(!el) return false;
                    var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    if(el.disabled) return false;
                    if((' '+el.className+' ').indexOf(' sapMBtnDisabled ')>=0) return false;
                    var r=el.getBoundingClientRect();
                    if (r.width<=0 || r.height<=0) return false;
                    var cx=r.left+r.width/2, cy=r.top+r.height/2;
                    var at=document.elementFromPoint(Math.max(0,cx),Math.max(0,cy));
                    return !!(at && (at===el || el.contains(at)));
                    }catch(e){ return false; }
                    """,
                    dom_id
                ))
            except Exception:
                return False

        def _ui5_press_by_id(self, dom_id: str) -> str:
            try:
                res = self.driver.execute_script(
                    """
                    try {
                    var id = arguments[0];
                    var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(id) : null;
                    if (ctrl && ctrl.firePress) { ctrl.firePress(); return 'ui5-firePress'; }
                    if (ctrl && ctrl.press)     { ctrl.press();     return 'ui5-press'; }
                    var el = document.getElementById(id);
                    if (el) { el.click(); return 'dom-click-fallback'; }
                    return 'ui5-miss';
                    } catch(e){ return 'ui5-exc:'+String(e); }
                    """,
                    dom_id,
                )
                return str(res)
            except Exception as e:
                return f"ui5-exc:{type(e).__name__}"

        def _press_activate_best_effort(self) -> bool:
            act_id = self._query_activate_id()
            if act_id:
                try:
                    def _get_el():
                        return self.driver.find_element(By.ID, act_id)
                    el = _retry_stale(_get_el)

                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                    except Exception:
                        pass

                    if self._really_clickable(act_id):
                        try:
                            _retry_stale(lambda: el.click())
                            wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                            time.sleep(self.EXTRA_SETTLE_SEC)
                            return True
                        except Exception:
                            pass

                    try:
                        self.driver.execute_script("arguments[0].click();", el)
                        wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                        time.sleep(self.EXTRA_SETTLE_SEC)
                        return True
                    except Exception:
                        pass

                    _ = self._ui5_press_by_id(act_id)
                    wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                    time.sleep(self.EXTRA_SETTLE_SEC)
                    return True
                except Exception:
                    pass

            # Fallback: generic Create/Save by text
            try:
                btn = fluent_wait(self.driver, 1.5, poll=0.15).until(
                    EC.element_to_be_clickable((By.XPATH, FORM_CREATE_OR_SAVE_BTN_XPATH))
                )
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                except Exception:
                    pass
                try:
                    _retry_stale(lambda: btn.click())
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", btn)
                    except Exception:
                        pass
                wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)
                return True
            except Exception:
                pass

            # Final fallback: Ctrl+S
            try:
                ActionChains(self.driver).key_down(Keys.CONTROL).send_keys("s").key_up(Keys.CONTROL).perform()
                wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)
                return True
            except Exception:
                return False

        # Kept for backward compatibility as a last-resort fallback
        def _activated_dom(self) -> bool:
            try:
                has_edit    = bool(self._query_visible_by_suffix(EDIT_BTN_ID_SUFFIX))
                has_discard = bool(self._query_visible_by_suffix(DISCARD_BTN_ID_SUFFIX))
                aria        = (self._header_aria_label() or "")
                if has_edit and not has_discard:
                    return True
                if aria and ("Header area" in aria) and ("New" not in aria):
                    return True
                return False
            except Exception:
                return False

        def click_create(self, clicks: int = 1) -> dict:
            info = {"clicks": 0, "dialogs": [], "toasts": []}
            dlg = DialogWatcher(self.driver)
            reader = ToastReader(self.driver)

            for _ in range(max(1, clicks)):
                if dlg.is_open():
                    info["dialogs"].append(dlg.text() or "")
                    break

                pressed = self._press_activate_best_effort()
                if not pressed:
                    continue

                info["clicks"] += 1
                wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)

                try:
                    t = reader.read_last()
                    if t:
                        info["toasts"].append(t)
                except Exception:
                    pass

                if dlg.is_open():
                    info["dialogs"].append(dlg.text() or "")
                    break

            return info

        def close_message_popover_if_open(self, timeout: int = 3) -> bool:
            """
            Closes the Message Popover if it is open. Returns True if we believe it closed.
            """
            # Prefer the close button in the popover header
            try:
                close_btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.XPATH, MSG_POPOVER_CLOSE_BTN_XP))
                )
                try:
                    close_btn.click()
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", close_btn)
                    except Exception:
                        pass
                # Wait until close button disappears
                WebDriverWait(self.driver, timeout, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                    EC.presence_of_element_located((By.XPATH, MSG_POPOVER_CLOSE_BTN_XP))
                )
                return True
            except Exception:
                # Fallback: toggle the Messages button to close
                try:
                    msg_btn_id = self._query_visible_by_suffix(MESSAGE_BTN_SUFFIX)
                    if msg_btn_id:
                        btn = self.driver.find_element(By.ID, msg_btn_id)
                        try:
                            btn.click()
                        except Exception:
                            self.driver.execute_script("arguments[0].click();", btn)
                        return True
                except Exception:
                    pass
                return False

        def discard_draft(self, timeout: int = 10) -> bool:
            """
            Clicks footer 'Discard Draft', then confirms 'Discard' in the confirmation popover.
            Returns True if confirmation popover disappears.
            """
            import time

            # 1) Click footer 'Discard Draft'
            disc_id = None
            try:
                disc_id = self._query_visible_by_suffix("--discard")
            except Exception:
                pass

            if disc_id:
                try:
                    el = WebDriverWait(self.driver, 2, ignored_exceptions=(StaleElementReferenceException,)).until(
                        EC.element_to_be_clickable((By.ID, disc_id))
                    )
                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                    except Exception:
                        pass
                    try:
                        el.click()
                    except Exception:
                        try:
                            self.driver.execute_script("arguments[0].click();", el)
                        except Exception:
                            pass
                except Exception:
                    pass
                # UI5 press fallback
                _ = self._ui5_press_by_id(disc_id)

            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            time.sleep(self.EXTRA_SETTLE_SEC)

            # 2) Confirm 'Discard' in popover
            CONFIRM_SUFFIX = "--DiscardDraftConfirmButton"

            def _click_confirm() -> bool:
                # by ID suffix
                try:
                    cid = self._query_visible_by_suffix(CONFIRM_SUFFIX)
                except Exception:
                    cid = None

                if cid:
                    try:
                        btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                            EC.element_to_be_clickable((By.ID, cid))
                        )
                        try:
                            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                        except Exception:
                            pass
                        try:
                            btn.click()
                        except Exception:
                            try:
                                self.driver.execute_script("arguments[0].click();", btn)
                            except Exception:
                                pass
                        return True
                    except Exception:
                        pass

                # by visible text
                try:
                    xp = ("//bdi[normalize-space()='Discard']/ancestor::button[1]"
                        " | //button[.//bdi[normalize-space()='Discard']]")
                    btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                        EC.element_to_be_clickable((By.XPATH, xp))
                    )
                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                    except Exception:
                        pass
                    try:
                        btn.click()
                    except Exception:
                        try:
                            self.driver.execute_script("arguments[0].click();", btn)
                        except Exception:
                            pass
                    return True
                except Exception:
                    return False

            clicked = _click_confirm()
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            time.sleep(self.EXTRA_SETTLE_SEC)

            # If confirm button no longer visible, assume success
            try:
                still = self._query_visible_by_suffix(CONFIRM_SUFFIX)
            except Exception:
                still = None
            return bool(clicked and not still)

        def ensure_created_by_loop_clicking(
            self,
            object_header_ready: Callable[[], bool],
            at_list: Callable[[], bool],
            close_side: Callable[[], bool],
            max_clicks: int = 5,       # was 10
            total_timeout: int = 35,   # default; caller may override
        ) -> Dict:
            dlg   = DialogWatcher(self.driver)
            reader= ToastReader(self.driver)
            msgs  = Ui5Messages(self.driver)
            probe = StatusProbe(self.driver)

            end = time.time() + max(total_timeout, self._timeout)
            clicks = 0
            toasts = []
            msgs.clear()

            while clicks < max(max_clicks,1) and time.time() < end:
                if dlg.is_open():
                    return {
                        "status": "dialog_open",
                        "dialog_open": True,
                        "dialog_text": dlg.text(),
                        "footer_clicks": clicks,
                        "intermediate_toasts": toasts,
                        "messages": msgs.read_all(),
                        "popover_text": msgs.popover_text(),
                    }

                if msgs.has_errors():
                    return {
                        "status": "activation_error",
                        "dialog_open": False,
                        "dialog_text": "",
                        "footer_clicks": clicks,
                        "intermediate_toasts": toasts,
                        "messages": msgs.errors(),
                        "popover_text": msgs.popover_text(),
                    }

                if (
                    probe.success()
                    or probe.is_persisted_object_page()
                    or object_header_ready()
                    or at_list()
                    or self._activated_dom()
                ):
                    close_side()
                    return {
                        "status": "created",
                        "dialog_open": False,
                        "dialog_text": "",
                        "footer_clicks": clicks,
                        "intermediate_toasts": toasts,
                        "messages": msgs.read_all(),
                        "popover_text": msgs.popover_text(),
                    }

                if self._press_activate_best_effort():
                    clicks += 1
                    wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
                    time.sleep(self.EXTRA_SETTLE_SEC)

                try:
                    t = reader.read_last()
                    if t:
                        toasts.append(t)
                        lt = (t or "").lower()
                        if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                            if not (probe.success() or probe.is_persisted_object_page()):
                                wait_ui5_idle(self.driver, timeout=min(2, self._timeout))
                            close_side()
                            return {
                                "status": "created",
                                "dialog_open": False,
                                "dialog_text": "",
                                "footer_clicks": clicks,
                                "intermediate_toasts": toasts,
                                "messages": msgs.read_all(),
                                "popover_text": msgs.popover_text(),
                            }
                except Exception:
                    pass

                time.sleep(0.2)

            if not at_list():
                close_side()

            created = (
                probe.success()
                or probe.is_persisted_object_page()
                or at_list()
                or object_header_ready()
                or self._activated_dom()
            )
            return {
                "status": "created" if created else "unknown",
                "footer_clicks": clicks,
                "intermediate_toasts": toasts,
                "dialog_open": False if not dlg.is_open() else True,
                "dialog_text": dlg.text() if dlg.is_open() else "",
                "messages": msgs.read_all(),
                "popover_text": msgs.popover_text(),
            }


    # pages\CurrencyExchangeRates\elements\Footer\selectors.py

    # Prefer the specific Activate/Create button on the Object Page footer
    ACTIVATE_CREATE_BTN_XPATH = (
        "//*[self::button or self::a]"
        "[substring(@id,string-length(@id)-string-length('--activate')+1)='--activate']"
    )

    # Backup: Create/Save button by text (kept for safety)
    FORM_CREATE_OR_SAVE_BTN_XPATH = (
        "("
        "//bdi[normalize-space()='Create']/ancestor::button[1] | "
        "//bdi[normalize-space()='Save']/ancestor::button[1]"
        ")[1]"
    )

    # CSS variants (used by JS helpers)
    ACTIVATE_CREATE_BTN_CSS = "button[id$='--activate'],a[id$='--activate']"

    # DOM success signals (from your snippet)
    HEADER_TITLE_ID_SUFFIX = "--objectPage-headerTitle"   # aria-label like "* Header area"
    EDIT_BTN_ID_SUFFIX     = "--edit"
    DELETE_BTN_ID_SUFFIX   = "--delete"
    DISCARD_BTN_ID_SUFFIX  = "--discard"
    COPY_BTN_ID_CONTAINS   = "::Copy"

    MESSAGE_BTN_SUFFIX = "--showMessages"
    MSG_POPOVER_CLOSE_BTN_XP = "//button[contains(@class,'sapMMsgPopoverCloseBtn')]"
    MSG_ITEMS_XP = "//li[contains(@class,'sapMMsgViewItem')]//span[contains(@id,'-titleText')]"


    # pages\CurrencyExchangeRates\elements\Footer\__init__.py



    # pages\CurrencyExchangeRates\elements\Header\element.py

    import time
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.common.by import By
    from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
    from core.base import Element
    from .selectors import OBJECT_HEADER_CONTENT_XPATH, OBJECT_HEADER_RATE_VALUE_XPATH

    class ObjectHeaderVerifier(Element):
        def wait_ready(self, timeout: int) -> bool:
            t0 = time.time()
            try:
                WebDriverWait(self.driver, min(6, timeout), ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
                )
            except TimeoutException:
                return False
            while time.time() - t0 < min(timeout, 10):
                try:
                    span = self.driver.find_element(By.XPATH, OBJECT_HEADER_RATE_VALUE_XPATH)
                    txt = ""
                    try:
                        txt = (span.text or "").strip()
                    except StaleElementReferenceException:
                        continue
                    if txt:
                        return True
                except Exception:
                    pass
                time.sleep(0.15)
            return False


    # pages\CurrencyExchangeRates\elements\Header\selectors.py

    OBJECT_HEADER_CONTENT_XPATH = (
        "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
        "'--objectPage-OPHeaderContent']"
    )
    OBJECT_HEADER_RATE_VALUE_XPATH = (
        "//*[substring(@id,string-length(@id)-string-length('--exchangeRate-text')+1)="
        "'--exchangeRate-text']"
    )


    # pages\CurrencyExchangeRates\elements\Header\__init__.py



    # pages\CurrencyExchangeRates\elements\ListToolbar\element.py

    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from core.base import Element, fluent_wait
    from services.ui import wait_ui5_idle
    from .selectors import CREATE_BUTTON_XPATH

    class ListToolbar(Element):
        def wait_create_clickable(self, timeout: int):
            return fluent_wait(self.driver, timeout, poll=0.2).until(
                EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
            )

        def click_create(self, timeout: int):
            btn = self.wait_create_clickable(timeout)
            try:
                btn.click()
            except Exception:
                self.js_click(btn)
            wait_ui5_idle(self.driver, timeout=timeout)

        def is_at_list(self, quick: float = 0.8) -> bool:
            try:
                fluent_wait(self.driver, quick, poll=0.2).until(
                    EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
                )
                return True
            except Exception:
                return False


    # pages\CurrencyExchangeRates\elements\ListToolbar\selectors.py

    # Create button in the list report toolbar
    CREATE_BUTTON_XPATH = "//bdi[normalize-space()='Create']/ancestor::button[1]"


    # pages\CurrencyExchangeRates\elements\ListToolbar\__init__.py



    # pages\CurrencyExchangeRates\elements\Messages\element.py

    from core.base import Element

    class Ui5Messages(Element):
        """
        Reads UI5 MessageManager; surfaces backend errors (why activation fails).
        Also knows how to read the Message Popover DOM (title/subtitle/description)
        which is what your HTML snippet shows.
        """

        def _get_data(self):
            try:
                return self.driver.execute_script(
                    """
                    try{
                    var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                    if(!core) return {ok:false, data:[]};
                    var mm = core.getMessageManager && core.getMessageManager();
                    if(!mm) return {ok:false, data:[]};
                    var model = mm.getMessageModel && mm.getMessageModel();
                    if(!model) return {ok:false, data:[]};
                    var data = (model.getData && model.getData()) || model.oData || [];
                    var out = [];
                    for (var i=0;i<data.length;i++){
                        var m=data[i]||{};
                        out.push({
                        type: String(m.type||''),
                        message: String(m.message||m.text||'').trim(),
                        description: String(m.description||'').trim(),
                        code: String(m.code||'').trim(),
                        target: String(m.target||'').trim(),
                        technical: !!m.technical
                        });
                    }
                    return {ok:true, data:out};
                    }catch(e){ return {ok:false, data:[], err:String(e)}; }
                    """
                ) or {"ok": False, "data": []}
            except Exception:
                return {"ok": False, "data": []}

        def read_all(self):
            res = self._get_data()
            return res.get("data", []) if isinstance(res, dict) else []

        def errors(self):
            return [m for m in self.read_all() if (m.get("type") or "").lower() in ("error","fatal","critical")]

        def has_errors(self) -> bool:
            return len(self.errors()) > 0

        def clear(self) -> bool:
            try:
                return bool(self.driver.execute_script(
                    """
                    try{
                    var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                    var mm = core && core.getMessageManager && core.getMessageManager();
                    if(!mm) return false;
                    if(mm.removeAllMessages) { mm.removeAllMessages(); return true; }
                    return false;
                    }catch(e){ return false; }
                    """
                ))
            except Exception:
                return False

        # ---------- NEW: Message Popover DOM reader ----------

        def popover_text(self) -> str:
            try:
                txt = self.driver.execute_script(
                    """
                    try{
                    function visible(el){
                        if(!el) return false;
                        var cs = getComputedStyle(el);
                        if(cs.display==='none'||cs.visibility==='hidden') return false;
                        var r = el.getBoundingClientRect();
                        return r.width>0 && r.height>0;
                    }

                    var wrap = document.querySelector('.sapMPopoverWrapper');
                    if(!wrap || !visible(wrap)) return '';

                    var errIcon = wrap.querySelector('.sapMMsgViewDescIconError');
                    var errStrip = document.querySelector('.sapMMsgStrip.sapMMsgStripError');
                    var isErr = !!(errIcon || errStrip);

                    var titleEl = wrap.querySelector('.sapMMsgView .sapMMsgViewTitleText .sapMLnkText');
                    var subEl   = wrap.querySelector('.sapMMsgView .sapMMsgViewSubtitleText');
                    var descEl  = wrap.querySelector('.sapMMsgView .sapMMsgViewDescriptionText');

                    var title = titleEl ? (titleEl.innerText||titleEl.textContent||'').trim() : '';
                    var sub   = subEl   ? (subEl.innerText||subEl.textContent||'').trim() : '';
                    var desc  = descEl  ? (descEl.innerText||descEl.textContent||'').trim() : '';

                    if(!isErr && !title && !desc) return '';
                    var parts = [];
                    if(title) parts.push(title);
                    if(sub)   parts.push(sub);
                    if(desc)  parts.push(desc);
                    return parts.join(' | ');
                    }catch(e){ return ''; }
                """
                )
                return (txt or "").strip()
            except Exception:
                return ""


    # pages\CurrencyExchangeRates\elements\Quotation\element.py

    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import StaleElementReferenceException
    import time

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import QUOTATION_INNER_INPUT_XPATH, QUOTATION_ARROW_BTN_XPATH, QUOTATION_OPTION_BY_TEXT_XPATH

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None

    class QuotationField(Element):
        def _hard_clear(self, inp):
            for fn in (
                lambda: inp.clear(),
                lambda: inp.send_keys(Keys.CONTROL, "a"),
                lambda: inp.send_keys(Keys.DELETE),
                lambda: self.driver.execute_script(
                    "arguments[0].value='';"
                    "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
            ):
                try: _retry_stale(fn)
                except Exception: pass

        def set_value(self, value: str):
            wait = WebDriverWait(self.driver, max(self._timeout, 20), ignored_exceptions=(StaleElementReferenceException,))
            inp = wait.until(EC.visibility_of_element_located((By.XPATH, QUOTATION_INNER_INPUT_XPATH)))

            try: _retry_stale(lambda: inp.click())
            except Exception: self.js_click(inp)

            self._hard_clear(inp)

            _retry_stale(lambda: inp.send_keys(value))
            _retry_stale(lambda: inp.send_keys(Keys.ENTER))
            _retry_stale(lambda: inp.send_keys(Keys.TAB))
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

            def _cur():
                return (inp.get_attribute("value") or "").strip()
            try:
                cur = _retry_stale(_cur)
            except Exception:
                cur = ""
            if cur.lower() != value.strip().lower():
                try:
                    arrow = wait.until(EC.element_to_be_clickable((By.XPATH, QUOTATION_ARROW_BTN_XPATH)))
                    try: _retry_stale(lambda: arrow.click())
                    except Exception: self.js_click(arrow)
                except Exception:
                    try: _retry_stale(lambda: inp.send_keys(Keys.ALT, Keys.DOWN))
                    except Exception: pass
                wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
                opt_xpath = QUOTATION_OPTION_BY_TEXT_XPATH.format(TEXT=value.strip())
                option = wait.until(EC.element_to_be_clickable((By.XPATH, opt_xpath)))
                try: _retry_stale(lambda: option.click())
                except Exception: self.js_click(option)
                wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))


    # pages\CurrencyExchangeRates\elements\Quotation\selectors.py

    QUOTATION_INNER_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-inner')+1)="
        "'ExchangeRateQuotation::Field-comboBoxEdit-inner']"
    )
    QUOTATION_ARROW_BTN_XPATH = (
        "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
        "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']/ancestor::button[1] | "
        "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
        "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']"
    )
    QUOTATION_OPTION_BY_TEXT_XPATH = (
        "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
        "//bdi[normalize-space()='{TEXT}']/ancestor::li[1] | "
        "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
        "//span[normalize-space()='{TEXT}']/ancestor::li[1]"
    )


    # pages\CurrencyExchangeRates\elements\Quotation\__init__.py



    # pages\CurrencyExchangeRates\elements\Rate\element.py

    from decimal import Decimal, ROUND_HALF_UP
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.common.exceptions import StaleElementReferenceException
    import time

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import EXCH_RATE_INPUT_XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None

    class ExchangeRateField(Element):
        def _ui_lang_tag(self) -> str:
            try:
                return self.driver.execute_script(
                    """
                    try{
                    var c=sap && sap.ui && sap.ui.getCore && sap.ui.getCore().getConfiguration && sap.ui.getCore().getConfiguration();
                    if(!c) return (navigator.language || 'en-US');
                    if (c.getLanguageTag) return c.getLanguageTag();
                    if (c.getLanguage)    return c.getLanguage();
                    return (navigator.language || 'en-US');
                    }catch(e){ return (navigator.language || 'en-US'); }
                    """
                ) or "en-US"
            except Exception:
                return "en-US"

        def _format_rate_locale(self, num: Decimal) -> str:
            q = num.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
            lang = self._ui_lang_tag()
            try:
                from babel.numbers import format_decimal
                return format_decimal(q, format="0.00000", locale=(lang or "en-US").replace("-", "_"))
            except Exception:
                try:
                    return self.driver.execute_script(
                        """
                        try{
                        var val = Number(arguments[0]);
                        var lang = arguments[1] || (navigator.language || 'en-US');
                        if (!isFinite(val)) return '';
                        return new Intl.NumberFormat(lang,
                                {minimumFractionDigits:5, maximumFractionDigits:5, useGrouping:false}
                                ).format(val);
                        }catch(e){ return String(arguments[0]); }
                        """,
                        float(q), lang
                    )
                except Exception:
                    return f"{q:.5f}"

        def _find_input(self):
            try:
                return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                    lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_XPATH)
                )
            except Exception:
                pass
            try:
                return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                    lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH)
                )
            except Exception:
                raise RuntimeError("Exchange Rate input not found (primary nor fallback).")

        def _hard_clear(self, el):
            for js in (
                lambda: el.clear(),
                lambda: el.send_keys(Keys.CONTROL, "a"),
                lambda: el.send_keys(Keys.DELETE),
                lambda: self.driver.execute_script(
                    "arguments[0].value='';"
                    "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", el),
            ):
                try: _retry_stale(js)
                except Exception: pass

        def commit(self, times: int = 1):
            inp = self._find_input()
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", inp)
            except Exception:
                pass
            try:
                _retry_stale(lambda: inp.click())
            except Exception:
                self.js_click(inp)

            try:
                ac = ActionChains(self.driver)
                for _ in range(max(1, times)):
                    ac.send_keys(Keys.ENTER).pause(0.03)
                ac.send_keys(Keys.TAB)
                ac.perform()
            except Exception:
                try:
                    _retry_stale(lambda: inp.send_keys(Keys.ENTER))
                    _retry_stale(lambda: inp.send_keys(Keys.TAB))
                except Exception: pass

            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

        def set_via_typing(self, rate_val: str | float | Decimal):
            num = Decimal(str(rate_val))
            if num <= 0:
                raise ValueError("rate_val must be > 0")
            s = self._format_rate_locale(num)
            inp = self._find_input()
            self._hard_clear(inp)
            _retry_stale(lambda: inp.send_keys(s))
            try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
            except Exception: pass
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

        def set_via_ui5(self, rate_val: str | float | Decimal):
            inp = self._find_input()
            inner_id = inp.get_attribute("id")
            if not inner_id:
                raise RuntimeError("Exchange Rate input has no DOM id")

            res = self.driver.execute_script(
                """
                try{
                var innerId=arguments[0], num=Number(String(arguments[1]).replace(',','.'));
                if(!isFinite(num) || num<=0){ return {ok:false, reason:'nonpositive'}; }
                var ctrlId = innerId.endsWith('-inner') ? innerId.slice(0,-6) : innerId;
                var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(ctrlId) : null;
                var fmt = (sap && sap.ui && sap.ui.core && sap.ui.core.format && sap.ui.core.format.NumberFormat)
                            ? sap.ui.core.format.NumberFormat.getFloatInstance({maxFractionDigits:5,minFractionDigits:5,groupingEnabled:false})
                            : null;
                var s = fmt ? fmt.format(num) : num.toFixed(5);

                if(ctrl && ctrl.setValue){
                    ctrl.setValue(s);
                    if (ctrl.fireLiveChange) ctrl.fireLiveChange({ value: s });
                    if (ctrl.fireChange)     ctrl.fireChange({ value: s });
                }
                var el = document.getElementById(innerId);
                if(el){
                    el.focus();
                    el.value = s;
                    el.dispatchEvent(new Event('input',{bubbles:true}));
                    el.dispatchEvent(new Event('change',{bubbles:true}));
                }
                var parsed = fmt ? fmt.parse(s) : Number(s.replace(',','.'));
                return {ok:(typeof parsed==='number' && parsed>0), shown:s, parsed:parsed};
                }catch(e){ return {ok:false, reason:String(e)}; }
                """,
                inner_id, str(rate_val)
            )
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            if not res or not res.get("ok"):
                raise RuntimeError(f"Could not set Exchange Rate via UI5. Result={res}.")


    # pages\CurrencyExchangeRates\elements\Rate\selectors.py

    EXCH_RATE_INPUT_XPATH = (
        "//input[substring(@id,string-length(@id)-string-length('AbsoluteExchangeRate::Field-input-inner')+1)="
        "'AbsoluteExchangeRate::Field-input-inner']"
    )

    EXCH_RATE_INPUT_FALLBACK_XPATH = (
        "("
        "//label[.//bdi[normalize-space()='Exchange Rate']]"
        "/following::input[contains(@id,'-inner')][1] | "
        "//span[normalize-space()='Exchange Rate']/ancestor::label[1]"
        "/following::input[contains(@id,'-inner')][1] | "
        "//*[self::label or self::span][contains(normalize-space(.), 'Exchange Rate')]"
        "/following::input[contains(@id,'-inner')][1]"
        ")"
    )


    # pages\CurrencyExchangeRates\elements\Rate\__init__.py



    # pages\CurrencyExchangeRates\elements\SideColumn\element.py

    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.common.by import By
    from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
    import time

    from core.base import Element
    from services.ui import wait_ui5_idle
    from ..ListToolbar.element import ListToolbar
    from .selectors import CLOSE_COLUMN_BTN_XPATH

    def _retry_stale(fn, tries=3, pause=0.12):
        last = None
        for _ in range(max(1, tries)):
            try:
                return fn()
            except StaleElementReferenceException as e:
                last = e
                time.sleep(pause)
        if last:
            raise last
        return None

    class SideColumnController(Element):
        def close_if_present(self, timeout: int | None = None) -> bool:
            t = timeout or max(self._timeout, 20)
            listbar = ListToolbar(self.driver)

            if listbar.is_at_list(quick=0.8):
                return True

            try:
                btn = WebDriverWait(self.driver, min(5, t), ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.XPATH, CLOSE_COLUMN_BTN_XPATH))
                )
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                except Exception:
                    pass
                try:
                    _retry_stale(lambda: btn.click())
                except Exception:
                    self.js_click(btn)
                wait_ui5_idle(self.driver, timeout=min(6, t))
            except TimeoutException:
                try:
                    did = self.driver.execute_script(
                        """
                        try{
                        var q = document.querySelectorAll(
                            "button[id$='--closeColumn'],button[id$='--closeColumnBtn'],button[id*='closeColumn']"
                        );
                        for (var i=q.length-1;i>=0;i--){
                            var b=q[i];
                            var cs=window.getComputedStyle(b);
                            if(b && b.offsetParent && cs.visibility!=='hidden' && cs.display!=='none'){ b.click(); return 'clicked-dom'; }
                        }
                        return 'none';
                        }catch(e){ return 'err:'+e; }
                        """
                    )
                except Exception:
                    did = "err"
                wait_ui5_idle(self.driver, timeout=2)

                if did != "clicked-dom":
                    try:
                        _ = self.driver.execute_script(
                            """
                            try{
                            var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                            if(!core) return 'no-core';
                            var all = core && core.mElements ? Object.values(core.mElements) : [];
                            var fcl=null, name='';
                            for (var i=0;i<all.length;i++){
                                var c=all[i];
                                try{
                                name=c.getMetadata && c.getMetadata().getName && c.getMetadata().getName();
                                if(name==='sap.f.FlexibleColumnLayout'){ fcl=c; break; }
                                }catch(e){}
                            }
                            if(fcl && fcl.setLayout){
                                var LT = sap.f && sap.f.LayoutType;
                                var one = (LT && LT.OneColumn) || 'OneColumn';
                                fcl.setLayout(one);
                                return 'set-one-column';
                            }
                            return 'no-fcl';
                            }catch(e){ return 'err:'+e; }
                            """
                        )
                    except Exception:
                        _ = "err"
                    wait_ui5_idle(self.driver, timeout=2)

            if listbar.is_at_list(quick=1.0):
                return True
            return True


    # pages\CurrencyExchangeRates\elements\SideColumn\selectors.py

    CLOSE_COLUMN_BTN_XPATH = (
        "("
        "  //button[substring(@id,string-length(@id)-string-length('--closeColumn')+1)='--closeColumn']"
        "  | //button[substring(@id,string-length(@id)-string-length('--closeColumnBtn')+1)='--closeColumnBtn']"
        "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-inner')+1)='--closeColumn-inner']/ancestor::button[1]"
        "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-img')+1)='--closeColumn-img']/ancestor::button[1]"
        "  | //button[@title='Close' or @aria-label='Close' or @aria-label='Close Column']"
        ")[1]"
    )


    # pages\CurrencyExchangeRates\elements\SideColumn\__init__.py



    # pages\CurrencyExchangeRates\elements\Status\element.py

    # elements/Status/element.py
    import time
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.common.by import By

    from core.base import Element
    from .selectors import (
        HEADER_EDIT_BTN_XPATH, HEADER_DELETE_BTN_XPATH, HEADER_COPY_BTN_XPATH,
        FOOTER_DISCARD_DRAFT_BTN_XPATH,
        CHANGE_LOG_SECTION_ANCHOR_XPATH, TREND_SECTION_ANCHOR_XPATH,
        OBJECT_HEADER_CONTENT_XPATH,
    )

    class StatusProbe(Element):
        def _exists(self, xp: str, t: float = 0.7) -> bool:
            try:
                WebDriverWait(self.driver, t).until(EC.presence_of_element_located((By.XPATH, xp)))
                return True
            except Exception:
                return False

        def is_active_entity(self):
            try:
                res = self.driver.execute_script(
                    """
                    try{
                    var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                    if(!core) return {ok:false, why:'no-core'};
                    var els = core && core.mElements ? Object.values(core.mElements) : [];
                    for (var i=0;i<els.length;i++){
                        var c=els[i];
                        try{
                        var n=c.getMetadata&&c.getMetadata().getName&&c.getMetadata().getName();
                        if(n==='sap.uxap.ObjectPageLayout'){
                            var bc=c.getBindingContext&&c.getBindingContext();
                            if(bc){
                            var o=bc.getObject&&bc.getObject();
                            if(o && ('IsActiveEntity' in o)) return {ok:true, active: !!o.IsActiveEntity};
                            var p=bc.getProperty&&bc.getProperty('IsActiveEntity');
                            if(typeof p!=='undefined') return {ok:true, active: !!p};
                            }
                        }
                        }catch(e){}
                    }
                    for (var j=0;j<els.length;j++){
                        var c2=els[j];
                        try{
                        var bc2=c2.getBindingContext&&c2.getBindingContext();
                        if(bc2){
                            var p2=bc2.getProperty&&bc2.getProperty('IsActiveEntity');
                            if(typeof p2!=='undefined') return {ok:true, active: !!p2};
                        }
                        }catch(e){}
                    }
                    return {ok:false, why:'no-binding'};
                    }catch(e){ return {ok:false, why:String(e)}; }
                    """
                )
                if isinstance(res, dict) and res.get("ok"):
                    return bool(res.get("active"))
            except Exception:
                pass
            return None

        def buttons_state(self) -> dict:
            return {
                "has_edit":   self._exists(HEADER_EDIT_BTN_XPATH),
                "has_delete": self._exists(HEADER_DELETE_BTN_XPATH),
                "has_copy":   self._exists(HEADER_COPY_BTN_XPATH),
                "has_discard_draft": self._exists(FOOTER_DISCARD_DRAFT_BTN_XPATH),
            }

        def sections_present(self) -> dict:
            return {
                "has_log":   self._exists(CHANGE_LOG_SECTION_ANCHOR_XPATH),
                "has_trend": self._exists(TREND_SECTION_ANCHOR_XPATH),
            }

        def header_aria_label(self) -> str:
            try:
                el = WebDriverWait(self.driver, 0.7).until(
                    EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
                )
                return (el.get_attribute("aria-label") or "").strip()
            except Exception:
                return ""

        def object_header_text(self) -> str:
            try:
                return self.driver.execute_script("""
                    try{
                    var el = document.querySelector("[id*='ObjectPageDynamicHeaderTitle-inner']");
                    return (el && (el.innerText||el.textContent)||'').trim();
                    }catch(e){return '';}
                """) or ""
            except Exception:
                return ""

        def is_create_mode(self) -> bool:
            try:
                return bool(self.driver.execute_script("""
                    try{
                    function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                        if(cs.display==='none'||cs.visibility==='hidden') return false;
                        var r=el.getBoundingClientRect(); return r.width>0 && r.height>0;
                    }
                    var nodes=[...document.querySelectorAll('button,bdi')];
                    return nodes.some(n=>{
                        var t=(n.innerText||n.textContent||'').trim();
                        if(!/\bCreate\b/i.test(t)) return false;
                        var b=n.tagName==='BDI' ? n.closest('button') : n;
                        return vis(b);
                    });
                    }catch(e){return false;}
                """))
            except Exception:
                return False

        def is_draft_url(self) -> bool:
            try:
                return bool(self.driver.execute_script("return location.href.includes('IsActiveEntity=false');"))
            except Exception:
                return False

        def is_persisted_object_page(self) -> bool:
            title = self.object_header_text()
            if not title:
                return False
            if self.is_create_mode():
                return False
            if not self.is_draft_url():
                return True
            btns = self.buttons_state()
            return (btns["has_edit"] and not btns["has_discard_draft"])

        def success(self) -> bool:
            active = self.is_active_entity()
            if active is True:
                return True

            btns = self.buttons_state()
            if btns["has_edit"] and not btns["has_discard_draft"]:# Discard Draft disappeared
                return True

            secs = self.sections_present()
            if secs["has_log"] or secs["has_trend"]:
                return True

            aria = self.header_aria_label()
            if aria and "Header area" in aria and "New" not in aria:
                return True

            if self.is_persisted_object_page():
                return True

            return False


    # pages\CurrencyExchangeRates\elements\Status\selectors.py

    # elements/Status/selectors.py

    # Action buttons that flip after activation
    HEADER_EDIT_BTN_XPATH = (
        "//bdi[normalize-space()='Edit']/ancestor::button[1] | "
        "//button[substring(@id,string-length(@id)-string-length('--edit')+1)='--edit']"
    )
    HEADER_DELETE_BTN_XPATH = (
        "//bdi[normalize-space()='Delete']/ancestor::button[1] | "
        "//button[substring(@id,string-length(@id)-string-length('--delete')+1)='--delete']"
    )
    HEADER_COPY_BTN_XPATH = (
        "//bdi[normalize-space()='Copy']/ancestor::button[1] | "
        "//button[substring(@id,string-length(@id)-string-length('--copy')+1)='--copy']"
    )
    FOOTER_DISCARD_DRAFT_BTN_XPATH = (
        "//bdi[normalize-space()='Discard Draft']/ancestor::button[1] | "
        "//button[substring(@id,string-length(@id)-string-length('--discard')+1)='--discard']"
    )

    # Sections that typically appear post-activation
    CHANGE_LOG_SECTION_ANCHOR_XPATH = (
        "//a[contains(@id,'ExchangeRateLog') and contains(@id,'Section-anchor')] | "
        "//a[contains(normalize-space(.), 'Change Log') and contains(@id,'Section-anchor')]"
    )
    TREND_SECTION_ANCHOR_XPATH = (
        "//a[contains(@id,'CurrencyExchangeRateTrend') and contains(@id,'Section-anchor')] | "
        "//a[contains(normalize-space(.), 'Trend') and contains(@id,'Section-anchor')]"
    )

    # Object header root for reading aria-label
    OBJECT_HEADER_CONTENT_XPATH = (
        "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
        "'--objectPage-OPHeaderContent']"
    )


    # pages\CurrencyExchangeRates\elements\Toast\element.py

    from core.base import Element
    from .selectors import MESSAGE_TOAST_CSS

    class ToastReader(Element):
        def read_last(self) -> str:
            try:
                txt = self.driver.execute_script(
                    "var nodes=document.querySelectorAll(arguments[0]);"
                    "if(!nodes||nodes.length===0) return '';"
                    "var t=nodes[nodes.length-1];"
                    "return (t.innerText||t.textContent||'').trim();",
                    MESSAGE_TOAST_CSS,
                )
                return (txt or "").strip()
            except Exception:
                return ""


    # pages\CurrencyExchangeRates\elements\Toast\selectors.py

    MESSAGE_TOAST_CSS = ".sapMMessageToast"


    # pages\CurrencyExchangeRates\elements\Toast\__init__.py



    # pages\CurrencyExchangeRates\elements\Validation\element.py

    from selenium.webdriver.common.by import By
    from core.base import Element
    from .selectors import ANY_INVALID_INPUT_XPATH, ANY_ERROR_WRAPPER_XPATH

    class ValidationInspector(Element):
        def collect(self) -> str | None:
            try:
                bad_inputs = self.driver.find_elements(By.XPATH, ANY_INVALID_INPUT_XPATH)
                if bad_inputs:
                    messages = []
                    for el_ in bad_inputs:
                        try:
                            err_id = el_.get_attribute("aria-errormessage") or ""
                            msg = self.driver.execute_script(
                                "var id=arguments[0];"
                                "var n=id?document.getElementById(id):null;"
                                "return n? (n.innerText || n.textContent || '').trim():'';", err_id)
                            if msg: messages.append(msg)
                        except Exception:
                            continue
                    if messages: return "; ".join(sorted(set(messages)))
                    return f"{len(bad_inputs)} invalid field(s)."
                wrappers = self.driver.find_elements(By.XPATH, ANY_ERROR_WRAPPER_XPATH)
                if wrappers: return f"{len(wrappers)} field wrapper(s) in error state."
            except Exception:
                pass
            return None


    # pages\CurrencyExchangeRates\elements\Validation\selectors.py

    ANY_INVALID_INPUT_XPATH = "//*[(@aria-invalid='true') and (self::input or self::textarea)]"
    ANY_ERROR_WRAPPER_XPATH = "//*[contains(@class,'sapMInputBaseContentWrapperError')]"


    # pages\CurrencyExchangeRates\elements\Validation\__init__.py



    # pages\Index\ProcurementOverviewTile\element.py

    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import GRID_READY_XPATH, BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH

    class ProcurementOverviewTile(Element):
        def _find_tile_quick(self, timeout_s: float):
            wait = WebDriverWait(self.driver, timeout_s)
            # Ensure tiles grid exists
            wait.until(EC.presence_of_element_located((By.XPATH, GRID_READY_XPATH)))

            # Try a few reliable selectors with short caps
            for xp in (BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH):
                try:
                    return WebDriverWait(self.driver, timeout_s).until(
                        EC.presence_of_element_located((By.XPATH, xp))
                    )
                except Exception:
                    continue
            return None

        def click(self):
            # Keep things brisk
            short = min(self._timeout, 6)
            wait_ui5_idle(self.driver, timeout=short)

            el = self._find_tile_quick(timeout_s=short)
            if el:
                href = (el.get_attribute("href") or "").strip()
                # Try normal click → JS click
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                    WebDriverWait(self.driver, short).until(EC.element_to_be_clickable((By.XPATH, BY_TITLE_TEXT_XPATH)))
                    el.click()
                    wait_ui5_idle(self.driver, timeout=short)
                    return
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", el)
                        wait_ui5_idle(self.driver, timeout=short)
                        return
                    except Exception:
                        if href:
                            self.driver.execute_script("window.location.href = arguments[0];", href)
                            wait_ui5_idle(self.driver, timeout=self._timeout)
                            return
                        raise RuntimeError("Found tile but could not activate it.")
            else:
                # Hard fallback: navigate directly by hash (fastest)
                self.driver.execute_script(
                    "location.href = location.origin + '/ui?sap-ushell-config=lean#Procurement-displayOverviewPage';"
                )
                wait_ui5_idle(self.driver, timeout=self._timeout)


    # pages\Index\ProcurementOverviewTile\selectors.py

    # pages/Index/elements/ProcurementOverviewTile/selectors.py

    # Grid container (ensures tiles were rendered)
    GRID_READY_XPATH = ("//div[starts-with(@id,'__section') and "
                        "contains(@id,'-defaultArea-listUl') and @role='list']")

    # Primary: match by the hash target in the href (most stable between tenants)
    BY_HREF_XPATH = ("//a[contains(@class,'sapMGT') and "
                    "contains(@href, '#Procurement-displayOverviewPage')]")

    # Secondary: visible title text (from your HTML)
    BY_TITLE_TEXT_XPATH = ("//a[contains(@class,'sapMGT')]"
                        "[.//span[normalize-space()='Procurement Overview']]")

    # Tertiary: aria-label starts with title
    BY_ARIA_LABEL_XPATH = ("//a[contains(@class,'sapMGT') and "
                        "starts-with(normalize-space(@aria-label),'Procurement Overview')]")


    # pages\Index\ProcurementOverviewTile\__init__.py



    # pages\Index\PurchasingTab\element.py

    from selenium.webdriver.common.by import By
    from core.base import Element
    from services.ui import wait_ui5_idle
    from .selectors import PURCHASING_TAB_XPATH

    class PurchasingTab(Element):
        def click(self):
            wait_ui5_idle(self.driver, timeout=self._timeout)
            el = self.wait_clickable(By.XPATH, PURCHASING_TAB_XPATH)
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                el.click()
            except Exception:
                self.js_click(el)


    # pages\Index\PurchasingTab\selectors.py

    # pages/Index/elements/PurchasingTab/selectors.py
    PURCHASING_TAB_XPATH = (
        "//div[contains(@class,'sapMITBFilterWrapper')]"
        "[.//span[normalize-space()='Purchasing']]"
    )


    # pages\Index\PurchasingTab\__init__.py



    # pages\Login\elements\__init__.py



    # pages\Login\elements\Password\element.py

    from selenium.webdriver.common.by import By
    from core.base import Element
    from .selectors import PASSWORD_INPUT

    class Password(Element):
        def set(self, value: str):
            el = self.wait_visible(By.CSS_SELECTOR, PASSWORD_INPUT)
            el.clear()
            el.send_keys(value)


    # pages\Login\elements\Password\selectors.py

    PASSWORD_INPUT = "#j_password"


    # pages\Login\elements\Password\__init__.py



    # pages\Login\elements\Submit\element.py

    from selenium.webdriver.common.by import By
    from core.base import Element
    from .selectors import SUBMIT_BTN

    class Submit(Element):
        def click(self):
            el = self.wait_clickable(By.CSS_SELECTOR, SUBMIT_BTN)
            try:
                el.click()
            except Exception:
                self.js_click(el)


    # pages\Login\elements\Submit\selectors.py

    SUBMIT_BTN = "#logOnFormSubmit"


    # pages\Login\elements\Submit\__init__.py



    # pages\Login\elements\Username\element.py

    from selenium.webdriver.common.by import By
    from core.base import Element
    from .selectors import USERNAME_INPUT

    class Username(Element):
        def set(self, value: str):
            el = self.wait_visible(By.CSS_SELECTOR, USERNAME_INPUT)
            el.clear()
            el.send_keys(value)


    # pages\Login\elements\Username\selectors.py

    USERNAME_INPUT = "#j_username"


    # pages\Login\elements\Username\__init__.py



    # pages\Shell\Search\element.py

    # pages/Shell/Search/element.py
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import InvalidElementStateException, TimeoutException

    from core.base import Element
    from services.ui import wait_ui5_idle, wait_shell_search_ready, open_shell_search_via_js
    from .selectors import (
        SEARCH_TOGGLE_CSS_PRIMARY,
        SEARCH_TOGGLE_CSS_ALT_HELP,
        SEARCH_TOGGLE_CSS_ALT_ARIA,
        SEARCH_INPUT_INNER_CSS,
        SUGGEST_TABLE_XPATH,
        APP_ROW_BY_TEXT_XPATH,
        APP_ROW_BY_TEXT_ALT_XPATH,
    )

    class ShellSearch(Element):
        def _wait_input_interactable(self):
            """
            Wait until the shell search input is present, visible, and not disabled/readOnly.
            Also ensure it has non-zero size (animation finished).
            """
            wait = WebDriverWait(self.driver, max(self._timeout, 25))
            inp = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
            # Visible
            inp = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
            # Enabled + not readOnly + has size
            wait.until(lambda d: d.execute_script(
                "var el=arguments[0];"
                "if(!el) return false;"
                "var cs=window.getComputedStyle(el);"
                "var ok=!!(el.offsetParent) && cs.visibility!=='hidden' && cs.display!=='none' && "
                "!el.disabled && !el.readOnly && el.clientWidth>0 && el.clientHeight>0;"
                "return ok;", inp))
            # Focus it
            try:
                inp.click()
            except Exception:
                self.js_click(inp)
            try:
                self.driver.execute_script("arguments[0].focus();", inp)
            except Exception:
                pass
            return inp

        def open_search(self):
            # Give UI5/FLP time to render the header/search
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
            wait_shell_search_ready(self.driver, timeout=max(self._timeout, 25))

            # Try clicking toggle; else JS renderer fallback
            candidates = (SEARCH_TOGGLE_CSS_PRIMARY, SEARCH_TOGGLE_CSS_ALT_HELP, SEARCH_TOGGLE_CSS_ALT_ARIA)
            clicked = False
            for css in candidates:
                try:
                    el = WebDriverWait(self.driver, max(self._timeout, 25)).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, css))
                    )
                    try:
                        el.click()
                    except Exception:
                        self.js_click(el)
                    clicked = True
                    break
                except Exception:
                    continue

            if not clicked:
                if not open_shell_search_via_js(self.driver):
                    raise TimeoutError("Shell search toggle not found and JS fallback failed.")

            # Wait until input is truly interactable (not just present)
            self._wait_input_interactable()
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
            return self

        def type_and_choose_app(self, query_text: str):
            inp = self._wait_input_interactable()

            # Clear safely
            try:
                inp.clear()
            except InvalidElementStateException:
                # JS clear fallback
                self.driver.execute_script(
                    "arguments[0].value=''; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                    inp
                )

            # Type the query; if Selenium send_keys bounces, use JS then send ENTER to trigger suggestions
            try:
                inp.send_keys(query_text)
            except InvalidElementStateException:
                self.driver.execute_script(
                    "arguments[0].value=arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                    inp, query_text
                )
                inp.send_keys(Keys.ENTER)

            # Wait for suggestions table to show up
            wait = WebDriverWait(self.driver, max(self._timeout, 10))
            try:
                wait.until(EC.presence_of_element_located((By.XPATH, SUGGEST_TABLE_XPATH)))
            except TimeoutException:
                # If suggestions didn't appear, fallback: open the app directly by intent hash
                self.driver.execute_script(
                    "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
                )
                wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
                return self

            # Click the suggestion row (exact text), else fallback to contains()
            for xp in (APP_ROW_BY_TEXT_XPATH, APP_ROW_BY_TEXT_ALT_XPATH):
                try:
                    row = wait.until(EC.element_to_be_clickable((By.XPATH, xp)))
                    try:
                        row.click()
                    except Exception:
                        self.js_click(row)
                    wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
                    return self
                except TimeoutException:
                    continue

            # Last resort: deep-link by hash
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
            )
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
            return self


    # pages\Shell\Search\selectors.py

    # pages/Shell/Search/selectors.py

    # Shell search toggle (try a few stable variants)
    SEARCH_TOGGLE_CSS_PRIMARY = "a#sf.sapUshellShellHeadItm"
    SEARCH_TOGGLE_CSS_ALT_HELP = "a.sapUshellShellHeadItm[data-help-id='shellHeader-search']"
    SEARCH_TOGGLE_CSS_ALT_ARIA = "a.sapUshellShellHeadItm[role='button'][aria-label*='Search']"

    # The input that appears after opening search (robust id pattern)
    SEARCH_INPUT_INNER_CSS = "input[id*='searchFieldInShell'][id$='-inner']"

    # Suggestion table + target row
    SUGGEST_TABLE_XPATH = "//table[contains(@id,'searchFieldInShell-input-popup-table-listUl')]"
    # Prefer exact text; fall back to contains if localized slightly
    APP_ROW_BY_TEXT_XPATH = (
        SUGGEST_TABLE_XPATH +
        "//span[normalize-space()='Currency Exchange Rates']/ancestor::*[self::tr or self::li][1]"
    )
    APP_ROW_BY_TEXT_ALT_XPATH = (
        SUGGEST_TABLE_XPATH +
        "//span[contains(normalize-space(),'Currency Exchange Rate')]/ancestor::*[self::tr or self::li][1]"
    )


    # pages\Shell\Search\__init__.py



    ## .txt / .csv / .json files (names only)

    requirements.txt
    snapshot.txt
    pages\snapshot.txt