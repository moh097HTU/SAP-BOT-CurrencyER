================  DIRECTORY TREE  ================
SAP-BOT - Currency - Test
├── core
│   ├── __init__.py
│   └── base.py
├── pages
│   ├── CurrencyExchangeRates
│   │   ├── elements
│   │   │   ├── Dialog
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Factors
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Fields
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Footer
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Header
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── ListToolbar
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Messages
│   │   │   │   └── element.py
│   │   │   ├── Quotation
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Rate
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── SideColumn
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Status
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Toast
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Validation
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   └── __init__.py
│   │   ├── __init__.py
│   │   ├── page.py
│   │   └── selectors.py
│   ├── Index
│   │   ├── ProcurementOverviewTile
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── PurchasingTab
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── __init__.py
│   │   └── page.py
│   ├── Login
│   │   ├── elements
│   │   │   ├── Password
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Submit
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   ├── Username
│   │   │   │   ├── __init__.py
│   │   │   │   ├── element.py
│   │   │   │   └── selectors.py
│   │   │   └── __init__.py
│   │   ├── __init__.py
│   │   └── page.py
│   ├── Shell
│   │   ├── Search
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   └── __init__.py
│   ├── __init__.py
│   └── snapshot.txt
├── routes
│   ├── __init__.py
│   ├── auth.py
│   └── currency.py
├── services
│   ├── __init__.py
│   ├── auth.py
│   ├── commit.py
│   ├── config.py
│   ├── daily.py
│   ├── driver.py
│   ├── notify.py
│   ├── reporting.py
│   ├── runner.py
│   ├── safe.py
│   ├── schemas.py
│   ├── tracking.py
│   ├── ui.py
│   └── worker.py
├── .env
├── .gitignore
├── main.py
├── README.md
├── requirements.txt
├── run_demo.py
└── snapshot.txt

================  FILE CONTENTS  =================

# .env

#SAP_URL=https://my413369.s4hana.cloud.sap/ui#Shell-home
#SAP_USERNAME=y.ghanem@esnadinternational.com
#SAP_PASSWORD=Esnadinternational020

SAP_URL=https://my417424.s4hana.cloud.sap/ui#Shell-home
SAP_USERNAME=SAP10000
SAP_PASSWORD=+-*/321zxc

HEADLESS=False
EXPLICIT_WAIT_SECONDS=7
PAGELOAD_TIMEOUT_SECONDS=4000
KEEP_BROWSER=False
SCREENSHOT_PATH=after_click.png

# How many parallel browsers to run
NUM_WORKERS=2

# How many workers may login at the same time (protect IdP)
LOGIN_CONCURRENCY=2

# Where to store per-worker Chrome profiles
CHROME_USER_DATA_BASE=chrome_profile

# Kill-and-recover if a single item takes longer than this
WATCHDOG_SECONDS=4000

COMMIT_CONCURRENCY=1

################ EMAIL SETTINGS ################
EMAIL_ENABLED=true
OUTLOOK_TENANT_ID=mail.alghanem.com.jo
OUTLOOK_CLIENT_ID=al-ghanem.com\m.almasri
OUTLOOK_CLIENT_SECRET=MKI*UJmki8uj
OUTLOOK_SENDER=m.almasri@alghanem.com.jo
OUTLOOK_TO=m.almasri@alghanem.com.jo
OUTLOOK_CC=
EMAIL_MAX_ATTACH_MB=5
REPORTS_DIR=reports
###################################################
LOCK_RETRY_MAX=3
LOCK_RETRY_DELAY_SEC=8

TRACK_DIR=WebService/TrackDrivers
TRACK_FINISHED_DIR=WebService/TrackFinished
TRACK_LIVE_MAX=10


# .gitignore

__pycache__/
*.py[cod]
.env
.venv/
venv/
env/
.chromedriver/
chrome_profile/
.DS_Store
*.log
*.png


# main.py

from fastapi import FastAPI
from routes import router as api_router

app = FastAPI(title="AIP-BOT API", version="1.0")
app.include_router(api_router)


# README.md

uvicorn main:app --host 0.0.0.0 --port 8000 --timeout-keep-alive 1200 --log-level info




# Force pull repo steps
## Make sure you’re on the branch you want (e.g. main)
git checkout main

## Fetch latest from remote
git fetch origin

## Reset local branch to be identical to remote
git reset --hard origin/main

## Clean up untracked files & dirs (optional but ensures exact match)
git clean -fd


# run_demo.py

# run_demo.py
from services.config import config
from services.driver import get_driver
from services.auth import login
from services.ui import wait_for_shell_home, wait_ui5_idle, wait_url_contains
from pages.Index.page import IndexPage

def main():
    cfg = config()
    driver = get_driver(headless=cfg["HEADLESS"])
    try:
        print("[1/3] Logging in …")
        login(driver)

        print("[2/3] Waiting for Fiori Shell …")
        ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
        print(f"Shell-home detected: {ok}")
        wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

        print("[3/3] Opening Purchasing → Procurement Overview …")
        idx = IndexPage(driver, root=cfg["SAP_URL"])
        idx.to_purchasing()
        idx.open_procurement_overview()
        wait_ui5_idle(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])

        # confirm navigation by hash
        if not wait_url_contains(driver, "#Procurement-displayOverviewPage", cfg["EXPLICIT_WAIT_SECONDS"]):
            print("[WARN] Did not see target hash yet; UI might still be loading.")
        input("\n✅ Navigated. Press Enter to close…")
    finally:
        if not cfg["KEEP_BROWSER"]:
            driver.quit()

if __name__ == "__main__":
    main()


# core\base.py

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Tuple

from selenium.webdriver.common.by import By
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from services.config import config

def fluent_wait(driver: WebDriver, timeout: float, poll: float = 0.25, ignored_exceptions: tuple = ()):
    """
    Thin helper for Selenium's fluent wait (custom poll interval + ignored exceptions).
    """
    return WebDriverWait(driver, timeout, poll_frequency=poll, ignored_exceptions=ignored_exceptions)

def _all_frames(driver: WebDriver):
    try:
        return driver.find_elements(By.CSS_SELECTOR, "iframe, frame")
    except Exception:
        return []

def _scan_frames_for(driver: WebDriver, locator: Tuple[str, str], timeout: int):
    """
    Fast path: look in default content first (with a very short wait).
    Only then peek into iframes with a tiny per-frame cap.
    """
    # 1) Default content (quick)
    driver.switch_to.default_content()
    try:
        return WebDriverWait(driver, min(3, timeout)).until(
            EC.presence_of_element_located(locator)
        )
    except Exception:
        pass

    # 2) Light iframe sweep (FLP typically doesn't need this)
    frames = _all_frames(driver)
    per_frame = 1.5  # seconds max per frame
    for f in frames:
        try:
            driver.switch_to.default_content()
            driver.switch_to.frame(f)
            el = WebDriverWait(driver, per_frame).until(
                EC.presence_of_element_located(locator)
            )
            return el
        except Exception:
            continue

    driver.switch_to.default_content()
    raise TimeoutError(f"Element not found for {locator}")

@dataclass
class Element:
    driver: WebDriver
    timeout: Optional[int] = None

    def __post_init__(self):
        if self.timeout is None:
            try:
                self.timeout = config()["EXPLICIT_WAIT_SECONDS"]
            except Exception:
                self.timeout = 30

    @property
    def _timeout(self) -> int:
        return self.timeout or config()["EXPLICIT_WAIT_SECONDS"]

    def find(self, by: By, value: str):
        return _scan_frames_for(self.driver, (by, value), self._timeout)

    def wait_visible(self, by: By, value: str):
        el = _scan_frames_for(self.driver, (by, value), self._timeout)
        return WebDriverWait(self.driver, self._timeout).until(EC.visibility_of(el))

    def wait_clickable(self, by: By, value: str):
        _ = _scan_frames_for(self.driver, (by, value), self._timeout)
        return WebDriverWait(self.driver, self._timeout).until(EC.element_to_be_clickable((by, value)))

    def js_click(self, el) -> None:
        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
        self.driver.execute_script("arguments[0].click();", el)

class Page:
    def __init__(self, driver: WebDriver, root: Optional[str] = None):
        self.driver = driver
        self.root = root

    def open(self, url: str):
        if self.root and not url.lower().startswith(("http://", "https://")):
            url = self.root.rstrip("/") + "/" + url.lstrip("/")
        self.driver.get(url)

    def ensure_url_contains(self, needle: str, timeout: Optional[int] = None):
        t = timeout or config()["EXPLICIT_WAIT_SECONDS"]
        WebDriverWait(self.driver, t).until(
            lambda d: needle.lower() in (d.current_url or "").lower()
        )


# core\__init__.py



# pages\__init__.py



# routes\auth.py

from fastapi import APIRouter
from services.driver import get_driver
from services.auth import login
from services.config import config
from services.ui import wait_for_shell_home

router = APIRouter()

@router.get("/auth/test-login")
async def test_login():
    cfg = config()
    driver = get_driver(headless=cfg["HEADLESS"])
    try:
        login(driver)
        ok = wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])
        return {
            "ok": ok,
            "current_url": driver.current_url,
        }
    except Exception as e:
        return {"ok": False, "error": str(e)}
    finally:
        if not cfg["KEEP_BROWSER"]:
            driver.quit()


# routes\currency.py

# routes/currency.py
from __future__ import annotations

import logging
import time
import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any

from fastapi import APIRouter
from fastapi.responses import StreamingResponse

from services.config import config
from services.schemas import ExchangeRateItem
from services.runner import BatchRunner
from services.reporting import ensure_reports_dir, write_json, write_failed_csv
from services.daily import finalize_batch_tracking, prune_live_trackers, daily_rollup_collect
from services.tracking import read_live_status_summary, PENDING, DONE, SKIPPED

log = logging.getLogger("sapbot")
if not log.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(threadName)s %(message)s"
    )

router = APIRouter()

@router.post("/currency/exchange-rates/batch")
async def create_exchange_rates(items: List[ExchangeRateItem]) -> Dict[str, Any]:
    cfg = config()
    workers = int(cfg.get("NUM_WORKERS", 6)) or 6

    received_count = len(items)
    batch_id = datetime.now().strftime("%Y%m%d-%H%M%S") + "-" + str(uuid.uuid4())[:8]
    reports_root = ensure_reports_dir(Path(cfg.get("REPORTS_DIR") or "reports"))

    runner = BatchRunner(cfg=cfg, batch_id=batch_id, reports_root=reports_root, workers=workers)
    runner.write_request_summary([it.dict() for it in items[:5]], workers)

    start_ts = time.time()
    result = runner.run_force_all_done(items)
    duration_sec = time.time() - start_ts

    # Persist standard artifacts
    result_path = Path(runner.batch_dir) / "result.json"
    failed_json_path = Path(runner.batch_dir) / "failed.json"
    failed_csv_path = Path(runner.batch_dir) / "failed.csv"

    # "Failures" now means anything not Done (i.e., Pending or errors mapped to Pending)
    failed_rows = [r for r in result.get("results", []) if (r.get("status") or "").strip().lower() not in ("created", "skipped")]
    write_json(result_path, result)
    write_json(failed_json_path, failed_rows)
    write_failed_csv(failed_csv_path, failed_rows)

    # Move trackers to finished/<day>/<batch_id>, prune live, and (optionally) daily rollup
    finalize_batch_tracking(batch_id, runner.track_dir)
    try:
        prune_live_trackers()
    except Exception:
        pass
    try:
        if cfg.get("DAILY_REPORTS_ENABLED"):
            _ = daily_rollup_collect()  # compile daily summary/failed.csv
    except Exception:
        pass

    # Strong guarantee: API is "done" only if live tracker summary shows zero Pending
    try:
        live = read_live_status_summary(track_dir=Path(runner.batch_dir).parent.parent / "live" / batch_id)
        # if we moved it already, read_live_status_summary may not find live dir; in that case, trust result["pending"]
    except Exception:
        live = {"Pending": result.get("pending", 0)}

    out = {
        **result,
        "duration_sec": round(duration_sec, 2),
        "reports": {
            "dir": str(runner.batch_dir),
            "result_json": str(result_path),
            "failed_json": str(failed_json_path),
            "failed_csv": str(failed_csv_path),
        },
        "api_ok": (result.get("pending", 0) == 0),  # hardened: only Done/Skipped left
    }
    return out

@router.post("/currency/exchange-rates/batch/stream")
async def create_exchange_rates_stream(items: List[ExchangeRateItem]):
    cfg = config()
    workers = int(cfg.get("NUM_WORKERS", 6)) or 6

    batch_id = datetime.now().strftime("%Y%m%d-%H%M%S") + "-" + str(uuid.uuid4())[:8]
    reports_root = ensure_reports_dir(Path(cfg.get("REPORTS_DIR") or "reports"))

    runner = BatchRunner(cfg=cfg, batch_id=batch_id, reports_root=reports_root, workers=workers)
    runner.write_request_summary([it.dict() for it in items[:5]], workers)

    HEARTBEAT_SEC = int(cfg.get("STREAM_HEARTBEAT_SEC", 5))

    def _gen():
        for line in runner.stream_events(items, heartbeat_sec=HEARTBEAT_SEC):
            yield line

    return StreamingResponse(_gen(), media_type="application/x-ndjson")


# routes\__init__.py

from fastapi import APIRouter
from . import auth
from . import currency

router = APIRouter()
router.include_router(auth.router, tags=["auth"])
router.include_router(currency.router, tags=["currency"])


# services\auth.py

from services.config import config
from pages.Login.page import LoginPage
from services.ui import wait_for_shell_home

def login(driver) -> None:
    cfg = config()
    LoginPage(driver).login(cfg["SAP_USERNAME"], cfg["SAP_PASSWORD"])
    # Let caller verify with wait_for_shell_home
    wait_for_shell_home(driver, timeout=cfg["EXPLICIT_WAIT_SECONDS"])


# services\commit.py

# services/commit.py
from __future__ import annotations
import os
import threading
from contextlib import contextmanager

# How many concurrent "Create/Activate" commits may run at once?
# Default = 1 (fully serialized). You can set COMMIT_CONCURRENCY=2..N if SAP allows it.
_COMMIT_CONCURRENCY = max(1, int(os.getenv("COMMIT_CONCURRENCY", "1")))
_SEM = threading.Semaphore(_COMMIT_CONCURRENCY)

@contextmanager
def commit_gate():
    """
    Narrow critical section for the exact click(s) that commit/activate
    the object. Everything else (typing, navigation) runs concurrently.
    """
    _SEM.acquire()
    try:
        yield
    finally:
        _SEM.release()


# services\config.py

# services/config.py
from dotenv import load_dotenv
import os

load_dotenv()

_BOOL = {"1", "true", "yes", "on", "y", "t"}

def _as_bool(v: str, default=False) -> bool:
    if v is None:
        return default
    return v.strip().lower() in _BOOL

def _as_int(v: str, default: int) -> int:
    try:
        return int(v)
    except Exception:
        return default

def config():
    sap_url = os.getenv("SAP_URL", "https://my413369.s4hana.cloud.sap/ui#Shell-home")
    return {
        # SAP / browser
        "SAP_URL": sap_url,
        "ROOT_URL": sap_url,
        "SAP_USERNAME": os.getenv("SAP_USERNAME", ""),
        "SAP_PASSWORD": os.getenv("SAP_PASSWORD", ""),

        "HEADLESS": _as_bool(os.getenv("HEADLESS", "false")),
        "EXPLICIT_WAIT_SECONDS": _as_int(os.getenv("EXPLICIT_WAIT_SECONDS", "30"), 30),
        "PAGELOAD_TIMEOUT_SECONDS": _as_int(os.getenv("PAGELOAD_TIMEOUT_SECONDS", "90"), 90),
        "KEEP_BROWSER": _as_bool(os.getenv("KEEP_BROWSER", "true")),

        # Multithreading / pacing
        "NUM_WORKERS": _as_int(os.getenv("NUM_WORKERS", "4"), 4),
        "LOGIN_CONCURRENCY": _as_int(os.getenv("LOGIN_CONCURRENCY", "2"), 2),
        "WATCHDOG_SECONDS": _as_int(os.getenv("WATCHDOG_SECONDS", "2000"), 2000),
        "CHROME_USER_DATA_BASE": os.getenv("CHROME_USER_DATA_BASE", "chrome_profile"),

        # Reporting
        "REPORTS_DIR": os.getenv("REPORTS_DIR", "reports"),
        "DAILY_REPORTS_ENABLED": _as_bool(os.getenv("DAILY_REPORTS_ENABLED", "true")),
        "NUM_LIVE_TRACKERS": _as_int(os.getenv("NUM_LIVE_TRACKERS", "8"), 8),  # keep last N live trackers

        # Email (Outlook via Microsoft Graph)
        "EMAIL_ENABLED": _as_bool(os.getenv("EMAIL_ENABLED", "false")),
        "OUTLOOK_TENANT_ID": os.getenv("OUTLOOK_TENANT_ID", ""),
        "OUTLOOK_CLIENT_ID": os.getenv("OUTLOOK_CLIENT_ID", ""),
        "OUTLOOK_CLIENT_SECRET": os.getenv("OUTLOOK_CLIENT_SECRET", ""),
        "OUTLOOK_SENDER": os.getenv("OUTLOOK_SENDER", ""),
        "OUTLOOK_TO": os.getenv("OUTLOOK_TO", ""),
        "OUTLOOK_CC": os.getenv("OUTLOOK_CC", ""),
        "EMAIL_MAX_ATTACH_MB": _as_int(os.getenv("EMAIL_MAX_ATTACH_MB", "3"), 3),

        # Legacy lock/ retry knobs (kept)
        "LOCK_RETRY_MAX": _as_int(os.getenv("LOCK_RETRY_MAX", "3"), 3),
        "LOCK_RETRY_DELAY_SEC": _as_int(os.getenv("LOCK_RETRY_DELAY_SEC", "8"), 8),

        # Tracking
        "TRACK_DIR": os.getenv("TRACK_DIR", "WebService/TrackDrivers"),

        # Force-all-done loop
        "FORCE_ALL_DONE_ENABLED": _as_bool(os.getenv("FORCE_ALL_DONE_ENABLED", "true")),
        "FORCE_ALL_DONE_MAX_ROUNDS": _as_int(os.getenv("FORCE_ALL_DONE_MAX_ROUNDS", "25"), 25),
        "FORCE_ALL_DONE_MAX_MINUTES": _as_int(os.getenv("FORCE_ALL_DONE_MAX_MINUTES", "60"), 60),
        "FORCE_ALL_DONE_BASE_SLEEP_SEC": _as_int(os.getenv("FORCE_ALL_DONE_BASE_SLEEP_SEC", "8"), 8),

        # Page commit flow
        "LOCK_MAX_RETRIES": _as_int(os.getenv("LOCK_MAX_RETRIES", "3"), 3),
    }

# Legacy convenience
ROOT_URL = config()["ROOT_URL"]
EXPLICIT_WAIT_SEC = config()["EXPLICIT_WAIT_SECONDS"]


# services\daily.py

# services/daily.py
from __future__ import annotations

from pathlib import Path
from typing import Dict, Any, List
import json
from datetime import datetime

from services.config import config
from services.tracking import move_live_to_finished, prune_live_trackers_keep_last_n, finished_dir_for_day

def finalize_batch_tracking(batch_id: str, track_dir: Path | None = None) -> Dict[str, Any]:
    """
    If batch is fully processed (no Pending), move its tracker to Finished/YYYY-MM-DD.
    """
    return move_live_to_finished(batch_id=batch_id, track_dir=track_dir)

def prune_live_trackers(keep_n: int | None = None) -> Dict[str, Any]:
    """
    Prune live trackers, keeping at most keep_n (defaults to NUM_LIVE_TRACKERS or TRACK_LIVE_MAX or 10).
    """
    cfg = config()
    default_keep = cfg.get("NUM_LIVE_TRACKERS", cfg.get("TRACK_LIVE_MAX", 10))
    kn = keep_n if keep_n is not None else int(default_keep)
    return prune_live_trackers_keep_last_n(keep_n=kn)

def daily_rollup_collect(day: str | None = None) -> Dict[str, Any]:
    """
    Return a parsed list of rollup entries for a given day (default = today).
    """
    d = day or datetime.now().strftime("%Y-%m-%d")
    from services.reporting import _reports_root  # local import to avoid cycle
    path = _reports_root() / "daily" / d / "rollup.ndjson"
    if not path.exists():
        return {"ok": True, "day": d, "items": []}
    items: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            try:
                items.append(json.loads(s))
            except Exception:
                pass
    return {"ok": True, "day": d, "items": items}


# services\driver.py

# services/driver.py
from __future__ import annotations

import os
import threading
from pathlib import Path
import shutil
import stat
import time
import random
import gc

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import SessionNotCreatedException, WebDriverException
from webdriver_manager.chrome import ChromeDriverManager

from services.config import config

_DRIVER_PATH_CACHE: str | None = None
_DRIVER_INIT_LOCK = threading.Lock()

_PROFILE_SET_LOCK = threading.Lock()
_PROFILE_DIRS_USED: set[str] = set()

def ensure_driver_binary_ready() -> str:
    global _DRIVER_PATH_CACHE
    if _DRIVER_PATH_CACHE:
        return _DRIVER_PATH_CACHE
    with _DRIVER_INIT_LOCK:
        if _DRIVER_PATH_CACHE:
            return _DRIVER_PATH_CACHE
        _DRIVER_PATH_CACHE = ChromeDriverManager().install()
        return _DRIVER_PATH_CACHE

def _base_profile_dir() -> Path:
    return Path(os.getenv("CHROME_USER_DATA_BASE", "chrome_profile")).resolve()

def _register_profile_dir(p: str) -> None:
    with _PROFILE_SET_LOCK:
        _PROFILE_DIRS_USED.add(p)

def list_profile_dirs_used() -> list[str]:
    with _PROFILE_SET_LOCK:
        return list(_PROFILE_DIRS_USED)

def _per_thread_profile_dir() -> str:
    base = _base_profile_dir()
    base.mkdir(parents=True, exist_ok=True)
    d = base / f"w-{threading.get_ident()}"
    d.mkdir(parents=True, exist_ok=True)
    p = str(d.resolve())
    _register_profile_dir(p)
    return p

def _random_debug_port() -> int:
    return random.randint(9223, 9550)

def get_driver(headless: bool = True) -> webdriver.Chrome:
    cfg = config()

    driver_path = ensure_driver_binary_ready()
    service = Service(driver_path)

    options = Options()
    if headless:
        options.add_argument("--headless=new")
    else:
        options.add_argument("--start-maximized")

    user_data_dir = _per_thread_profile_dir()
    options.add_argument(f"--user-data-dir={user_data_dir}")
    options.add_argument("--profile-directory=Default")

    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-extensions")
    options.add_argument("--disable-gpu")
    options.add_argument("--disable-features=Translate,BackForwardCache,Prerender2,VizDisplayCompositor")
    options.add_argument("--window-size=1366,768")
    options.add_argument("--lang=en-US")
    options.add_argument("--no-first-run")
    options.add_argument("--no-default-browser-check")

    options.add_argument("--log-level=3")
    options.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
    options.add_experimental_option("useAutomationExtension", False)
    options.add_experimental_option("prefs", {
        "credentials_enable_service": False,
        "profile.password_manager_enabled": False,
    })

    try:
        options.add_argument(f"--remote-debugging-port={_random_debug_port()}")
    except Exception:
        pass

    try:
        driver = webdriver.Chrome(service=service, options=options)
    except SessionNotCreatedException as e:
        raise RuntimeError(
            "Chrome/ChromeDriver version mismatch (SessionNotCreated). "
            "Install matching major versions of Chrome and Chromedriver. "
            f"Original: {e}"
        )
    except WebDriverException as e:
        raise RuntimeError(f"WebDriver failed to start: {type(e).__name__}: {e}")

    try:
        pl_timeout = int(cfg.get("PAGELOAD_TIMEOUT_SECONDS", 90)) or 90
        driver.set_page_load_timeout(pl_timeout)
    except Exception:
        try:
            driver.set_page_load_timeout(90)
        except Exception:
            pass

    if not headless:
        try:
            driver.maximize_window()
        except Exception:
            pass

    try:
        driver.execute_cdp_cmd(
            "Page.addScriptToEvaluateOnNewDocument",
            {"source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"},
        )
    except Exception:
        pass

    try:
        setattr(driver, "_user_data_dir", user_data_dir)  # nosec
    except Exception:
        pass

    return driver

def _on_rm_error(func, path, exc_info):
    try:
        os.chmod(path, stat.S_IWRITE)
    except Exception:
        pass
    try:
        func(path)
    except Exception:
        pass

def _rmtree_force(p: Path, retries: int = 3, delay: float = 0.25):
    for _ in range(max(1, retries)):
        try:
            if p.exists():
                shutil.rmtree(p, onerror=_on_rm_error)
            return
        except Exception:
            time.sleep(delay)
    try:
        if p.exists():
            shutil.rmtree(p, onerror=_on_rm_error)
    except Exception:
        pass

def cleanup_profiles(also_base: bool = True) -> dict:
    deleted = []
    errors = []
    with _PROFILE_SET_LOCK:
        dirs = list(_PROFILE_DIRS_USED)
        _PROFILE_DIRS_USED.clear()
    for d in dirs:
        try:
            _rmtree_force(Path(d))
            deleted.append(d)
        except Exception as e:
            errors.append({"dir": d, "error": f"{type(e).__name__}: {e}"})
    base = _base_profile_dir()
    if also_base:
        try:
            if base.exists() and base.is_dir() and not any(base.iterdir()):
                _rmtree_force(base)
        except Exception:
            pass
    gc.collect()
    return {"deleted": deleted, "errors": errors}


# services\notify.py

# services/notify.py
from __future__ import annotations

import base64
import json
import os
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

from services.config import config

GRAPH_BASE = "https://graph.microsoft.com/v1.0"
_SCOPES = ["https://graph.microsoft.com/.default"]

def _split_csv(s: str) -> list[str]:
    return [x.strip() for x in s.split(",") if x.strip()]

def _get_token() -> str:
    """
    Acquire an app-only token using MSAL (client credentials).
    Import msal lazily so the project runs even if emailing is disabled.
    """
    cfg = config()
    try:
        import msal
    except Exception as e:
        raise RuntimeError("Emailing is enabled but 'msal' is not installed.") from e

    app = msal.ConfidentialClientApplication(
        client_id=cfg["OUTLOOK_CLIENT_ID"],
        authority=f"https://login.microsoftonline.com/{cfg['OUTLOOK_TENANT_ID']}",
        client_credential=cfg["OUTLOOK_CLIENT_SECRET"],
    )
    result = app.acquire_token_silent(_SCOPES, account=None)
    if not result:
        result = app.acquire_token_for_client(scopes=_SCOPES)
    if not result or "access_token" not in result:
        raise RuntimeError(f"Could not acquire Graph token: {result}")
    return result["access_token"]

def _file_attachment_dict(path: Path, max_mb: int) -> Optional[Dict[str, Any]]:
    """
    Build Graph fileAttachment payload for files up to max_mb (simple attach limit).
    Returns None if too large or missing.
    """
    try:
        if not path.exists() or not path.is_file():
            return None
        size = path.stat().st_size
        if size > max_mb * 1024 * 1024:
            return None
        content = path.read_bytes()
        return {
            "@odata.type": "#microsoft.graph.fileAttachment",
            "name": path.name,
            "contentBytes": base64.b64encode(content).decode("ascii"),
        }
    except Exception:
        return None

def _build_html_body(batch_id: str,
                     received_count: int,
                     created_count: int,
                     failed_rows: List[Dict[str, Any]],
                     duration_sec: Optional[float]) -> str:
    rows = []
    for r in failed_rows:
        p = r.get("payload", {})
        err = r.get("error") or r.get("dialog_text") or ""
        rows.append(f"""
          <tr>
            <td>{r.get('index','')}</td>
            <td>{p.get('ExchangeRateType','')}</td>
            <td>{p.get('FromCurrency','')}</td>
            <td>{p.get('ToCurrency','')}</td>
            <td>{p.get('ValidFrom','')}</td>
            <td>{p.get('Quotation','')}</td>
            <td>{p.get('ExchangeRate','')}</td>
            <td>{r.get('status','')}</td>
            <td>{(err or '').replace('<','&lt;').replace('>','&gt;')}</td>
          </tr>
        """)
    rows_html = "\n".join(rows) or "<tr><td colspan='10'>—</td></tr>"
    dur = f"{duration_sec:.1f}s" if duration_sec is not None else "n/a"
    created_pct = f"{(created_count/received_count*100):.1f}%" if received_count else "n/a"
    return f"""
    <div style="font-family:Segoe UI,Arial,sans-serif">
      <h2>[SAP-BOT] Batch {batch_id} completed</h2>
      <p><b>Received:</b> {received_count} &nbsp;|&nbsp; <b>Created:</b> {created_count} ({created_pct}) &nbsp;|&nbsp; <b>Failed:</b> {len(failed_rows)} &nbsp;|&nbsp; <b>Duration:</b> {dur}</p>
      <h3>Failures</h3>
      <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;font-size:13px">
        <thead>
          <tr>
            <th>#</th><th>Type</th><th>From</th><th>To</th><th>Date</th>
            <th>Quotation</th><th>Rate</th><th>Status</th><th>Error</th>
          </tr>
        </thead>
        <tbody>{rows_html}</tbody>
      </table>
      <p style="margin-top:12px">Full JSON/CSV attached. attached when size allowed; if any were too large, their paths are listed in the table.</p>
    </div>
    """

def send_batch_email(
    batch_id: str,
    received_count: int,
    result_obj: Dict[str, Any],
    failed_rows: List[Dict[str, Any]],
    attachment_paths: List[str],
    duration_sec: Optional[float] = None,
) -> Dict[str, Any]:
    """
    Sends a summary email via Microsoft Graph to OUTLOOK_TO/CC.
    attachment_paths: list of files to attach (failed json/csv).
    Returns a dict with 'ok' and 'attached' lists.
    """
    cfg = config()
    if not cfg.get("EMAIL_ENABLED"):
        return {"ok": False, "reason": "email_disabled"}

    # Prepare recipients
    to_list = _split_csv(cfg.get("OUTLOOK_TO", ""))
    if not to_list:
        return {"ok": False, "reason": "no_to_recipients"}
    cc_list = _split_csv(cfg.get("OUTLOOK_CC", ""))

    # Subject/body
    created_count = int(result_obj.get("created", 0))
    subject = f"[SAP-BOT] Batch {batch_id}: {created_count}/{received_count} created – {len(failed_rows)} failed"
    html_body = _build_html_body(batch_id, received_count, created_count, failed_rows, duration_sec)

    # Build attachments (respect simple attach size)
    max_mb = int(cfg.get("EMAIL_MAX_ATTACH_MB") or 3)
    attached = []
    attachments = []
    for p in attachment_paths:
        att = _file_attachment_dict(Path(p), max_mb=max_mb)
        if att:
            attachments.append(att)
            attached.append(os.path.basename(p))
    # Graph API payload
    message = {
        "subject": subject,
        "body": {"contentType": "HTML", "content": html_body},
        "toRecipients": [{"emailAddress": {"address": a}} for a in to_list],
    }
    if cc_list:
        message["ccRecipients"] = [{"emailAddress": {"address": a}} for a in cc_list]
    if attachments:
        message["attachments"] = attachments

    # Send
    token = _get_token()
    import requests  
    sender_upn = cfg["OUTLOOK_SENDER"] or to_list[0]  # fallback
    url = f"{GRAPH_BASE}/users/{sender_upn}/sendMail"
    resp = requests.post(
        url,
        headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"},
        data=json.dumps({"message": message, "saveToSentItems": True}),
        timeout=30,
    )
    if resp.status_code not in (202, 200):
        return {"ok": False, "reason": f"graph_send_failed {resp.status_code}: {resp.text}"}

    return {"ok": True, "attached": attached, "to": to_list, "cc": cc_list}


# services\reporting.py

# services/reporting.py
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List
import json
import csv
from datetime import datetime

from services.config import config
from services.tracking import move_live_to_finished, prune_live_trackers_keep_last_n

# ---------- file utils ----------

def ensure_reports_dir(path: Path) -> Path:
    path.mkdir(parents=True, exist_ok=True)
    return path

def _reports_root() -> Path:
    base = Path(config().get("REPORTS_DIR") or "reports").resolve()
    base.mkdir(parents=True, exist_ok=True)
    return base

def write_json(path: Path, obj: Any) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(obj, indent=2, ensure_ascii=False), encoding="utf-8")

def write_failed_csv(path: Path, failed_rows: List[Dict[str, Any]]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    cols = [
        "index", "status",
        "ExchangeRateType", "FromCurrency", "ToCurrency",
        "ValidFrom", "Quotation", "ExchangeRate",
        "error", "dialog_text", "lock_table", "lock_owner", "round",
    ]
    with path.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=cols)
        w.writeheader()
        for r in failed_rows:
            p = r.get("payload", {}) or {}
            w.writerow({
                "index": r.get("index"),
                "status": r.get("status"),
                "ExchangeRateType": p.get("ExchangeRateType"),
                "FromCurrency": p.get("FromCurrency"),
                "ToCurrency": p.get("ToCurrency"),
                "ValidFrom": p.get("ValidFrom"),
                "Quotation": p.get("Quotation"),
                "ExchangeRate": p.get("ExchangeRate"),
                "error": r.get("error"),
                "dialog_text": r.get("dialog_text"),
                "lock_table": r.get("lock_table"),
                "lock_owner": r.get("lock_owner"),
                "round": r.get("round"),
            })

def write_skipped_csv(path: Path, skipped_rows: List[Dict[str, Any]]) -> None:
    """
    Mirror of write_failed_csv but for Skipped rows so we persist the SAP message.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    cols = [
        "index", "status",
        "ExchangeRateType", "FromCurrency", "ToCurrency",
        "ValidFrom", "Quotation", "ExchangeRate",
        "dialog_text", "round",
    ]
    with path.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=cols)
        w.writeheader()
        for r in skipped_rows:
            p = r.get("payload", {}) or {}
            w.writerow({
                "index": r.get("index"),
                "status": r.get("status"),
                "ExchangeRateType": p.get("ExchangeRateType"),
                "FromCurrency": p.get("FromCurrency"),
                "ToCurrency": p.get("ToCurrency"),
                "ValidFrom": p.get("ValidFrom"),
                "Quotation": p.get("Quotation"),
                "ExchangeRate": p.get("ExchangeRate"),
                "dialog_text": r.get("dialog_text") or r.get("error"),
                "round": r.get("round"),
            })

# ---------- daily rollup (by records' day) ----------

def _daily_dir(day: str | None = None) -> Path:
    """
    Day directory under reports/daily/<YYYY-MM-DD>.
    NOTE: 'day' should be the records' day (derived from ValidFrom), not 'today'.
    """
    d = day or datetime.now().strftime("%Y-%m-%d")
    return _reports_root() / "daily" / d

def _read_rollup_items(day: str | None = None) -> List[Dict[str, Any]]:
    ddir = _daily_dir(day)
    path = ddir / "rollup.ndjson"
    if not path.exists():
        return []
    items: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            try:
                items.append(json.loads(s))
            except Exception:
                pass
    return items

def rebuild_daily_final(day: str | None = None) -> Dict[str, Any]:
    """
    Build/overwrite reports/daily/<day>/final.json from the rollup file.
    Aggregates per-batch stats into day totals + a compact list of batches.
    """
    d = day or datetime.now().strftime("%Y-%m-%d")
    ddir = _daily_dir(d)
    ddir.mkdir(parents=True, exist_ok=True)

    items = _read_rollup_items(d)
    batches: List[Dict[str, Any]] = []
    totals = {"batches": 0, "received": 0, "created": 0, "failed": 0, "skipped": 0, "ok_batches": 0, "nok_batches": 0}

    for it in items:
        batch_id = it.get("batch_id")
        total = int(it.get("total", it.get("received", 0)) or 0)
        created = int(it.get("created", 0) or 0)
        failed = int(it.get("failed", 0) or 0)
        skipped = int(it.get("skipped", 0) or 0)
        ok = bool(it.get("ok"))

        batches.append({
            "batch_id": batch_id,
            "received": total,
            "created": created,
            "failed": failed,
            "skipped": skipped,
            "ok": ok,
            "reports_dir": (it.get("reports") or {}).get("dir") or "",
        })

        totals["batches"] += 1
        totals["received"] += total
        totals["created"] += created
        totals["failed"] += failed
        totals["skipped"] += skipped
        totals["ok_batches"] += 1 if ok else 0
        totals["nok_batches"] += 0 if ok else 1

    final_doc = {
        "day": d,
        "generated_at": datetime.now().isoformat(),
        "totals": totals,
        "batches": batches,
    }
    write_json(ddir / "final.json", final_doc)
    return {"ok": True, "path": str(ddir / "final.json"), "counts": totals}

def append_daily_rollup(batch_id: str, result_obj: Dict[str, Any], day: str | None = None) -> Dict[str, Any]:
    """
    Appends one JSON line per batch to reports/daily/<day>/rollup.ndjson,
    then (re)builds reports/daily/<day>/final.json.

    'day' MUST be the records' day (YYYY-MM-DD) when available.
    """
    ddir = _daily_dir(day)
    ddir.mkdir(parents=True, exist_ok=True)
    path = ddir / "rollup.ndjson"
    line = json.dumps({"batch_id": batch_id, "ts": datetime.now().isoformat(), **result_obj}, ensure_ascii=False)
    with path.open("a", encoding="utf-8") as f:
        f.write(line + "\n")

    try:
        rebuild_daily_final(day)
    except Exception:
        pass

    return {"ok": True, "path": str(path)}

# ---------- tracker archiving/pruning (wrappers) ----------

def move_tracker_if_finished(cfg: Dict[str, Any], batch_id: str, track_dir: Path) -> Dict[str, Any]:
    return move_live_to_finished(batch_id=batch_id, track_dir=track_dir)

def prune_live_trackers(cfg: Dict[str, Any], keep_n: int = 10) -> Dict[str, Any]:
    return prune_live_trackers_keep_last_n(keep_n=keep_n)


# services\runner.py

# services/runner.py
from __future__ import annotations

import logging
import random
import shutil
import time
import threading
from pathlib import Path
from typing import Any, Dict, List, Tuple, Iterable
from concurrent.futures import ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED
from datetime import datetime

from services.schemas import ExchangeRateItem
from services.driver import ensure_driver_binary_ready, cleanup_profiles
from services.tracking import (
    tracking_dir_for_batch,
    tracking_path_for_worker,
    init_tracking_files,
    pending_rows_for_report,
)
from services.worker import worker_process, chunk_evenly
from services.reporting import (
    ensure_reports_dir,
    write_json,
    write_failed_csv,
    write_skipped_csv,
    append_daily_rollup,
    move_tracker_if_finished,
    prune_live_trackers,
)

log = logging.getLogger("sapbot")


class BatchRunner:
    def __init__(self, cfg: Dict[str, Any], batch_id: str, reports_root: Path, workers: int):
        self.cfg = cfg
        self.batch_id = batch_id
        self.workers = max(1, int(workers))
        self.reports_root = ensure_reports_dir(reports_root)
        self.batch_dir = ensure_reports_dir(self.reports_root / batch_id)
        self.track_dir = tracking_dir_for_batch(cfg, batch_id)

    # ---------- helpers: records' day (from ValidFrom) + relocate ----------

    @staticmethod
    def _as_record_day(v: str | None) -> str | None:
        """
        Normalize ValidFrom (DD.MM.YYYY) -> YYYY-MM-DD
        """
        if not v:
            return None
        try:
            return datetime.strptime(v.strip(), "%d.%m.%Y").strftime("%Y-%m-%d")
        except Exception:
            return None

    def _record_day_from_items(self, items: List[ExchangeRateItem]) -> str | None:
        days = {self._as_record_day(it.ValidFrom) for it in items if self._as_record_day(it.ValidFrom)}
        return list(days)[0] if len(days) == 1 else None

    def _record_day_from_results(self, results: List[Dict[str, Any]]) -> str | None:
        days = set()
        for r in results:
            p = r.get("payload") or {}
            d = self._as_record_day(p.get("ValidFrom"))
            if d:
                days.add(d)
        return list(days)[0] if len(days) == 1 else None

    def _relocate_batch_under_day(self, day: str | None) -> None:
        """
        Move reports/<batch_id> → reports/<YYYY-MM-DD>/<batch_id>
        (no-op if day is None).
        """
        if not day:
            return
        target_root = ensure_reports_dir(self.reports_root / day)
        target = target_root / self.batch_id
        if str(target.resolve()) == str(self.batch_dir.resolve()):
            return
        try:
            if target.exists():
                shutil.rmtree(target, ignore_errors=True)
            shutil.move(str(self.batch_dir), str(target))
            self.batch_dir = target
        except Exception as e:
            log.error("[relocate] failed moving batch_dir into day folder %s: %s: %s", day, type(e).__name__, e)

    # ---------- internal helpers ----------

    def _run_multithread_once(self, items: List[ExchangeRateItem]) -> Dict[str, Any]:
        try:
            ensure_driver_binary_ready()
        except Exception:
            pass

        indexed = list(enumerate(items, start=1))
        shards = chunk_evenly(indexed, self.workers)
        stop_event = threading.Event()
        login_sem = threading.BoundedSemaphore(int(self.cfg.get("LOGIN_CONCURRENCY", min(2, self.workers))))

        init_tracking_files(self.track_dir, shards)

        track_files = {w_id: tracking_path_for_worker(self.track_dir, w_id)
                       for w_id, _ in enumerate(shards, start=1)}

        all_results: List[Dict[str, Any]] = []
        with ThreadPoolExecutor(max_workers=self.workers) as pool:
            futures = []
            for w_id, shard in enumerate(shards, start=1):
                track_file = track_files[w_id]
                futures.append(pool.submit(
                    worker_process, shard, stop_event, login_sem, self.cfg, w_id, track_file
                ))

            for fut in as_completed(futures):
                try:
                    r = fut.result()
                except Exception as e:
                    r = {"results": [{
                        "index": None,
                        "status": "error",
                        "error": f"worker_crashed: {type(e).__name__}: {e}",
                    }]}
                all_results.extend(r.get("results", []))

        have_idx = {r.get("index") for r in all_results if r.get("index") is not None}
        for tf in track_files.values():
            try:
                for prow in pending_rows_for_report(tf):
                    idx = prow.get("index")
                    if idx is not None and idx not in have_idx:
                        all_results.append(prow)
                        have_idx.add(idx)
            except Exception:
                pass

        try:
            cleanup_profiles(also_base=True)
        except Exception:
            pass

        all_results.sort(key=lambda x: x.get("index") or 0)
        return {"results": all_results}

    # ---------------- PUBLIC: non-streaming ----------------
    def run_force_all_done(self, items: List[ExchangeRateItem]) -> Dict[str, Any]:
        workers = self.workers
        base_sleep = max(0, int(self.cfg.get("FORCE_ALL_DONE_BASE_SLEEP_SEC", 8)))
        max_rounds = int(self.cfg.get("FORCE_ALL_DONE_MAX_ROUNDS", 25))
        max_minutes = int(self.cfg.get("FORCE_ALL_DONE_MAX_MINUTES", 60))

        start_ts = time.time()
        time_cap = (max_minutes > 0)

        aggregate_results: Dict[int, Dict[str, Any]] = {}
        pending: List[Tuple[int, ExchangeRateItem]] = list(enumerate(items, start=1))
        round_no = 0

        try:
            while pending:
                if max_rounds > 0 and round_no >= max_rounds:
                    break
                if time_cap and (time.time() - start_ts) > (max_minutes * 60):
                    break

                round_no += 1
                round_items = [it for _, it in pending]
                r = self._run_multithread_once(round_items)
                round_rows = r.get("results", [])

                lim = min(len(round_rows), len(pending))
                for i in range(lim):
                    orig_idx = pending[i][0]
                    row = {**round_rows[i], "round": round_no}
                    aggregate_results[orig_idx] = row

                next_pending: List[Tuple[int, ExchangeRateItem]] = []
                for i in range(lim):
                    orig_idx, orig_item = pending[i]
                    row = aggregate_results.get(orig_idx, {})
                    st = (row.get("status") or "").strip().lower()
                    if st == "pending":
                        next_pending.append((orig_idx, orig_item))

                if next_pending:
                    time.sleep(base_sleep + random.uniform(0, 2.0))
                    pending = next_pending
                else:
                    pending = []

            for idx in range(1, len(items) + 1):
                aggregate_results.setdefault(idx, {
                    "index": idx,
                    "payload": items[idx - 1].dict(),
                    "status": "error",
                    "error": "no_result",
                    "round": round_no,
                })

            final_rows = [aggregate_results[i] for i in sorted(aggregate_results.keys())]
            created = sum(1 for r in final_rows if (r.get("status") or "").lower() == "created")
            failed_rows = [r for r in final_rows if (r.get("status") or "").lower() not in ("created", "skipped")]
            failed = len(failed_rows)
            skipped = sum(1 for r in final_rows if (r.get("status") or "").lower() == "skipped")
            skipped_rows = [r for r in final_rows if (r.get("status") or "").lower() == "skipped"]

            return {
                "ok": failed == 0,
                "workers": workers,
                "total": len(items),
                "created": created,
                "failed": failed,
                "skipped": skipped,
                "results": final_rows,
                "skipped_rows": skipped_rows,
                "force_all_done_rounds_used": round_no,
                "force_all_done_max_rounds": max_rounds,
                "force_all_done_time_cap_minutes": max_minutes,
                "track_dir": str(self.track_dir),
            }
        finally:
            try:
                if self.track_dir.exists():
                    shutil.rmtree(self.track_dir, ignore_errors=True)
            except Exception:
                pass

    # ---------------- PUBLIC: streaming ----------------
    def stream_events(self, items: List[ExchangeRateItem], heartbeat_sec: int = 5) -> Iterable[str]:
        start_ts = time.time()
        workers = self.workers
        base_sleep = max(0, int(self.cfg.get("FORCE_ALL_DONE_BASE_SLEEP_SEC", 8)))
        max_rounds = int(self.cfg.get("FORCE_ALL_DONE_MAX_ROUNDS", 25))
        max_minutes = int(self.cfg.get("FORCE_ALL_DONE_MAX_MINUTES", 60))
        time_cap = (max_minutes > 0)

        yield self._json_line({
            "event": "start",
            "batch_id": self.batch_id,
            "received": len(items),
            "workers": workers,
            "ts": self._iso_now(),
        })

        pending_pairs: List[Tuple[int, ExchangeRateItem]] = list(enumerate(items, start=1))
        aggregate: Dict[int, Dict[str, Any]] = {}
        round_no = 0
        all_rows_this_batch: List[Dict[str, Any]] = []

        try:
            while pending_pairs:
                if max_rounds > 0 and round_no >= max_rounds:
                    break
                if time_cap and (time.time() - start_ts) > (max_minutes * 60):
                    break

                round_no += 1
                shards = chunk_evenly(pending_pairs, workers)

                init_tracking_files(self.track_dir, shards)

                stop_event = threading.Event()
                login_sem = threading.BoundedSemaphore(int(self.cfg.get("LOGIN_CONCURRENCY", min(2, workers))))

                with ThreadPoolExecutor(max_workers=workers) as pool:
                    futures = [
                        pool.submit(
                            worker_process, shard, stop_event, login_sem, self.cfg, w_id,
                            tracking_path_for_worker(self.track_dir, w_id)
                        )
                        for w_id, shard in enumerate(shards, start=1)
                    ]

                    pending_futs = set(futures)
                    last_emit = time.time()

                    while pending_futs:
                        done, pending_futs = wait(pending_futs, timeout=heartbeat_sec, return_when=FIRST_COMPLETED)

                        for fut in done:
                            try:
                                r = fut.result()
                            except Exception as e:
                                r = {"results": [
                                    {"index": None, "status": "error",
                                     "error": f"worker_crashed: {type(e).__name__}: {e}", "round": round_no}
                                ]}
                            rows = r.get("results", [])
                            for row in rows:
                                row["round"] = round_no
                            all_rows_this_batch.extend(rows)
                            for row in rows:
                                yield self._json_line({"event": "row", **row})
                            last_emit = time.time()

                        if (time.time() - last_emit) >= heartbeat_sec:
                            yield self._json_line({"event": "tick", "ts": self._iso_now()})
                            last_emit = time.time()

            results_sorted = sorted(list(aggregate.values()), key=lambda x: (x.get("index") or 0))
            created = sum(1 for r in results_sorted if (r.get("status") or "").lower() == "created")
            failed_rows = [r for r in results_sorted if (r.get("status") or "").lower() not in ("created", "skipped")]
            failed = len(failed_rows)
            skipped = sum(1 for r in results_sorted if (r.get("status") or "").lower() == "skipped")
            skipped_rows = [r for r in results_sorted if (r.get("status") or "").lower() == "skipped"]
            duration_sec = time.time() - start_ts

            result = {
                "ok": (failed == 0),
                "workers": workers,
                "total": len(items),
                "created": created,
                "failed": failed,
                "skipped": skipped,
                "results": results_sorted,
                "track_dir": str(self.track_dir),
                "force_all_done_rounds_used": round_no,
                "force_all_done_max_rounds": max_rounds,
                "force_all_done_time_cap_minutes": max_minutes,
            }

            # persist per-batch artifacts
            result_path = self.batch_dir / "result.json"
            failed_json_path = self.batch_dir / "failed.json"
            failed_csv_path = self.batch_dir / "failed.csv"
            skipped_json_path = self.batch_dir / "skipped.json"
            skipped_csv_path = self.batch_dir / "skipped.csv"

            write_json(result_path, result)
            write_json(failed_json_path, failed_rows)
            write_failed_csv(failed_csv_path, failed_rows)
            write_json(skipped_json_path, skipped_rows)
            write_skipped_csv(skipped_csv_path, skipped_rows)

            # figure records' day from the batch items and MOVE under reports/<day>/<batch_id>
            rec_day = self._record_day_from_items(items)
            self._relocate_batch_under_day(rec_day)

            # daily rollup + archive/prune (by records' day)
            try:
                append_daily_rollup(self.batch_id, {**result, "duration_sec": round(duration_sec, 2)}, day=rec_day)
            except Exception:
                pass
            try:
                _td = tracking_dir_for_batch(self.cfg, self.batch_id)
                move_tracker_if_finished(self.cfg, self.batch_id, _td)
                prune_live_trackers(self.cfg, keep_n=int(self.cfg.get("NUM_LIVE_TRACKERS", 10)))
            except Exception:
                pass

            # recompute artifact paths after potential relocate
            result_path = self.batch_dir / "result.json"
            failed_json_path = self.batch_dir / "failed.json"
            failed_csv_path = self.batch_dir / "failed.csv"
            skipped_json_path = self.batch_dir / "skipped.json"
            skipped_csv_path = self.batch_dir / "skipped.csv"

            yield self._json_line({
                "event": "end",
                "batch_id": self.batch_id,
                "received": len(items),
                "duration_sec": round(duration_sec, 2),
                "created": created,
                "failed": failed,
                "skipped": skipped,
                "reports": {
                    "dir": str(self.batch_dir),
                    "result_json": str(result_path),
                    "failed_json": str(failed_json_path),
                    "failed_csv": str(failed_csv_path),
                    "skipped_json": str(skipped_json_path),
                    "skipped_csv": str(skipped_csv_path),
                },
                "email": {"ok": False, "reason": "not_requested"},
                "track_dir": str(self.track_dir),
                "records_day": rec_day,
            })

        finally:
            try:
                if self.track_dir.exists():
                    shutil.rmtree(self.track_dir, ignore_errors=True)
            except Exception:
                pass

    # ---------- reporting helpers used by routes ----------

    def write_request_summary(self, items_sample: List[Dict[str, Any]], workers: int) -> None:
        from datetime import datetime
        write_json(self.batch_dir / "request.json", {
            "batch_id": self.batch_id,
            "received": len(items_sample),
            "ts": datetime.now().isoformat(),
            "workers": workers,
            "sample": items_sample[:5],
        })

    def persist_and_email(self, result: Dict[str, Any], duration_sec: float) -> Dict[str, Any]:
        results = result.get("results", [])
        failed_rows = [r for r in results if (r.get("status") or "").lower() not in ("created", "skipped")]
        skipped_rows = [r for r in results if (r.get("status") or "").lower() == "skipped"]

        result_path = self.batch_dir / "result.json"
        failed_json_path = self.batch_dir / "failed.json"
        failed_csv_path = self.batch_dir / "failed.csv"
        skipped_json_path = self.batch_dir / "skipped.json"
        skipped_csv_path = self.batch_dir / "skipped.csv"

        write_json(result_path, result)
        write_json(failed_json_path, failed_rows)
        write_failed_csv(failed_csv_path, failed_rows)
        write_json(skipped_json_path, skipped_rows)
        write_skipped_csv(skipped_csv_path, skipped_rows)

        # relocate under records' day (derived from results payloads)
        rec_day = self._record_day_from_results(results)
        self._relocate_batch_under_day(rec_day)

        # Email summary if enabled & there are failures
        email_info = {"ok": False, "reason": "not_requested"}
        if self.cfg.get("EMAIL_ENABLED") and failed_rows:
            try:
                from services.notify import send_batch_email
                attachments = [str(self.batch_dir / "failed.json"), str(self.batch_dir / "failed.csv")]
                email_info = send_batch_email(
                    batch_id=self.batch_id,
                    received_count=result.get("total", 0),
                    result_obj=result,
                    failed_rows=failed_rows,
                    attachment_paths=attachments,
                    duration_sec=duration_sec,
                )
            except Exception as e:
                email_info = {"ok": False, "reason": f"send_error: {type(e).__name__}: {e}"}

        # paths may have changed after relocate
        result_out = dict(result)
        result_out.update({
            "batch_id": self.batch_id,
            "duration_sec": round(duration_sec, 2),
            "reports": {
                "dir": str(self.batch_dir),
                "result_json": str(self.batch_dir / "result.json"),
                "failed_json": str(self.batch_dir / "failed.json"),
                "failed_csv": str(self.batch_dir / "failed.csv"),
                "skipped_json": str(self.batch_dir / "skipped.json"),
                "skipped_csv": str(self.batch_dir / "skipped.csv"),
            },
            "email": email_info,
            "records_day": rec_day,
        })

        # Append to daily rollup for that records' day
        try:
            append_daily_rollup(self.batch_id, result_out, day=rec_day)
        except Exception:
            pass

        # Archive tracker & prune
        try:
            from services.tracking import tracking_dir_for_batch
            _td = tracking_dir_for_batch(self.cfg, self.batch_id)
            move_tracker_if_finished(self.cfg, self.batch_id, _td)
            prune_live_trackers(self.cfg, keep_n=int(self.cfg.get("NUM_LIVE_TRACKERS", 10)))
        except Exception:
            pass

        return result_out

    # ---------- small utils ----------

    @staticmethod
    def _json_line(obj: Dict[str, Any]) -> str:
        import json
        return json.dumps(obj) + "\n"

    @staticmethod
    def _iso_now() -> str:
        from datetime import datetime
        return datetime.now().isoformat()


# services\safe.py

from selenium.webdriver.support.ui import WebDriverWait

def wait_js(driver, predicate_js: str, timeout: int) -> bool:
    try:
        WebDriverWait(driver, timeout).until(lambda d: bool(d.execute_script(predicate_js)))
        return True
    except Exception:
        return False


# services\schemas.py

from __future__ import annotations

from pydantic import BaseModel, Field, validator
from decimal import Decimal, ROUND_HALF_UP


class ExchangeRateItem(BaseModel):
    ExchangeRateType: str = Field(..., description="e.g. M")
    FromCurrency: str = Field(..., description="e.g. USD")
    ToCurrency: str = Field(..., description="e.g. JOD")
    # Normalize to DD.MM.YYYY for SAP typing
    ValidFrom: str = Field(
        ...,
        description="Date like 31.12.2025 or 2025-12-31 or 12/31/2025; normalized to DD.MM.YYYY"
    )
    Quotation: str | None = Field("Direct", description="Direct or Indirect")
    ExchangeRate: str | float | Decimal = Field(..., description="> 0; rounded to 5 dp")

    @validator("ExchangeRateType", "FromCurrency", "ToCurrency")
    def _up(cls, v: str):  # noqa: N805
        return (v or "").strip().upper()

    @validator("Quotation", always=True)
    def _q(cls, v: str | None):  # noqa: N805
        s = (v or "Direct").strip().capitalize()
        return "Indirect" if s.startswith("Ind") else "Direct"

    @validator("ValidFrom")
    def _datefmt(cls, v: str):  # noqa: N805
        s = (v or "").strip()
        fmts = [
            "%m/%d/%Y",   # 12/31/2025
            "%Y-%m-%d",   # 2025-12-31
            "%Y/%m/%d",   # 2025/12/31
            "%d/%m/%Y",   # 31/12/2025
            "%Y%m%d",     # 20251231
            "%d.%m.%Y",   # 31.12.2025
            "%Y-%d-%m",   # legacy 2025-31-12
        ]
        from datetime import datetime as _dt
        for f in fmts:
            try:
                dt = _dt.strptime(s, f)
                return dt.strftime("%d.%m.%Y")
            except Exception:
                pass
        raise ValueError(f"Unrecognized date: {v}")

    @validator("ExchangeRate")
    def _5dp(cls, v):  # noqa: N805
        q = Decimal(str(v))
        if q <= 0:
            raise ValueError("ExchangeRate must be > 0")
        q = q.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
        return f"{q:.5f}"


# services\tracking.py

# services/tracking.py
from __future__ import annotations

from pathlib import Path
from typing import Dict, Any, List, Tuple, Optional
import json
import shutil
from datetime import datetime

from services.schemas import ExchangeRateItem
from services.config import config

# ---- Standardized tracker status tokens ----
PENDING = "Pending"
DONE    = "Done"
SKIPPED = "Skipped"

# ---- Directory layout helpers ----

def _root() -> Path:
    """Base tracking root from env TRACK_DIR (default WebService/TrackDrivers)."""
    return Path(config().get("TRACK_DIR") or "WebService/TrackDrivers").resolve()

def _live_root() -> Path:
    p = _root() / "Live"
    p.mkdir(parents=True, exist_ok=True)
    return p

def _finished_root_for_day(day: Optional[str] = None) -> Path:
    d = day or datetime.now().strftime("%Y-%m-%d")
    p = _root() / "Finished" / d
    p.mkdir(parents=True, exist_ok=True)
    return p

def finished_dir_for_day(day: Optional[str] = None) -> Path:
    """Public getter to be used by reporting/daily."""
    return _finished_root_for_day(day)

def tracking_dir_for_batch(cfg: Dict[str, Any], batch_id: str) -> Path:
    """Per-batch live tracker dir."""
    d = _live_root() / batch_id
    d.mkdir(parents=True, exist_ok=True)
    return d

def tracking_path_for_worker(track_dir: Path, worker_id: int) -> Path:
    return track_dir / f"driver-{worker_id}.json"

# ---- File IO helpers ----

def _load_tracking(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {"worker_id": None, "items": []}

def _save_tracking_atomic(path: Path, doc: Dict[str, Any]) -> None:
    tmp = path.with_suffix(".json.tmp")
    tmp.write_text(json.dumps(doc, indent=2, ensure_ascii=False), encoding="utf-8")
    tmp.replace(path)

# ---- Initialize / Update ----

def init_tracking_files(track_dir: Path, shards: List[List[Tuple[int, ExchangeRateItem]]]) -> None:
    """
    Create one JSON per worker with each row initialized as Pending.
    """
    track_dir.mkdir(parents=True, exist_ok=True)
    for w_id, shard in enumerate(shards, start=1):
        path = tracking_path_for_worker(track_dir, w_id)
        if path.exists():
            # keep existing (supports driver restarts)
            continue
        doc = {
            "worker_id": w_id,
            "items": [{"index": idx, "status": PENDING, "payload": it.dict()} for (idx, it) in shard],
        }
        _save_tracking_atomic(path, doc)

def mark_item_status(path: Path, index: int, status: str, extra: Optional[Dict[str, Any]] = None) -> None:
    """
    Update a single item inside a worker tracking file.
    status should be one of: Pending / Done / Skipped / Error ...
    """
    doc = _load_tracking(path)
    changed = False
    for row in doc.get("items", []):
        if row.get("index") == index:
            row["status"] = status
            if extra:
                row.update(extra)
            changed = True
            break
    if changed:
        _save_tracking_atomic(path, doc)

def iter_pending_items(path: Path) -> List[Tuple[int, ExchangeRateItem]]:
    """
    Only return items currently Pending in this track file.
    """
    doc = _load_tracking(path)
    out: List[Tuple[int, ExchangeRateItem]] = []
    changed = False
    for row in doc.get("items", []):
        st = (row.get("status") or "").strip()
        if st.lower() == PENDING.lower():
            payload = row.get("payload") or {}
            try:
                item = ExchangeRateItem(**payload)
                out.append((row.get("index"), item))
            except Exception:
                # malformed → mark Error to avoid loops
                row["status"] = "Error"
                changed = True
    if changed:
        _save_tracking_atomic(path, doc)
    return out

def pending_rows_for_report(path: Path) -> list[dict]:
    """
    Synthesize rows for reporting for remaining Pending items.
    """
    doc = _load_tracking(path)
    out: list[dict] = []
    for row in doc.get("items", []):
        if (row.get("status") or "").strip().lower() == PENDING.lower():
            out.append({
                "index": row.get("index"),
                "status": PENDING,
                "payload": row.get("payload") or {},
            })
    return out

# ---- Live -> Finished archiving & pruning ----

def _dir_has_any_pending(track_dir: Path) -> bool:
    for f in sorted(track_dir.glob("driver-*.json")):
        doc = _load_tracking(f)
        for row in doc.get("items", []):
            if (row.get("status") or "").strip().lower() == PENDING.lower():
                return True
    return False

def move_live_to_finished(batch_id: str, track_dir: Optional[Path] = None, day: Optional[str] = None) -> Dict[str, Any]:
    """
    If the batch's live tracker has NO Pending rows, move it under Finished/YYYY-MM-DD/<batch_id>.
    Returns a dict describing the action.
    """
    lr = _live_root()
    tdir = track_dir or (lr / batch_id)
    if not tdir.exists():
        return {"ok": False, "reason": "no_live_dir", "batch_id": batch_id}

    if _dir_has_any_pending(tdir):
        return {"ok": False, "reason": "still_pending", "batch_id": batch_id, "path": str(tdir)}

    dest_root = _finished_root_for_day(day)
    dest = dest_root / batch_id
    try:
        if dest.exists():
            shutil.rmtree(dest, ignore_errors=True)
        shutil.move(str(tdir), str(dest))
        return {"ok": True, "moved_to": str(dest), "batch_id": batch_id}
    except Exception as e:
        return {"ok": False, "reason": f"move_failed: {type(e).__name__}: {e}", "batch_id": batch_id}

def prune_live_trackers_keep_last_n(keep_n: int = 10) -> Dict[str, Any]:
    """
    Keep only the most-recent N live batch tracker dirs by mtime; delete older ones.
    """
    keep_n = max(0, int(keep_n))
    lr = _live_root()
    if not lr.exists():
        return {"ok": True, "deleted": [], "kept": []}

    dirs = [d for d in lr.iterdir() if d.is_dir()]
    dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

    to_keep = dirs[:keep_n] if keep_n > 0 else []
    to_delete = dirs[keep_n:] if keep_n >= 0 else []

    deleted = []
    for d in to_delete:
        try:
            shutil.rmtree(d, ignore_errors=True)
            deleted.append(str(d))
        except Exception:
            pass

    return {"ok": True, "deleted": deleted, "kept": [str(p) for p in to_keep]}

# ---- Live status summary (for routes/currency.py) ----

def _count_statuses_in_doc(doc: Dict[str, Any]) -> Dict[str, int]:
    """
    Count normalized statuses in a single tracking doc.
    Normalization: 'created' -> Done, 'skipped' -> Skipped, 'pending' -> Pending.
    Anything else -> Error.
    """
    counts = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
    for row in doc.get("items", []):
        raw = (row.get("status") or "").strip().lower()
        if raw == "done" or raw == "created":
            counts[DONE] += 1
        elif raw == "skipped":
            counts[SKIPPED] += 1
        elif raw == "pending":
            counts[PENDING] += 1
        else:
            counts["Error"] += 1
    return counts

def read_live_status_summary(batch_id: Optional[str] = None, track_dir: Optional[Path] = None) -> Dict[str, Any]:
    """
    Summarize the live tracker(s).
    - If track_dir is provided, summarize that directory.
    - Else if batch_id is provided, summarize Live/<batch_id>.
    - Else, summarize ALL batches under Live/.
    Returns dict with totals and per-worker breakdown (when summarizing a single batch).
    """
    lr = _live_root()
    if track_dir is None:
        if batch_id:
            track_dir = lr / batch_id
        else:
            # global summary across all live batches
            batches = []
            for bdir in sorted([d for d in lr.iterdir() if d.is_dir()]):
                b_tot = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
                for f in sorted(bdir.glob("driver-*.json")):
                    doc = _load_tracking(f)
                    c = _count_statuses_in_doc(doc)
                    for k, v in c.items():
                        b_tot[k] = b_tot.get(k, 0) + int(v)
                batches.append({"batch_id": bdir.name, "totals": b_tot, "path": str(bdir)})
            grand = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
            for b in batches:
                for k, v in b["totals"].items():
                    grand[k] = grand.get(k, 0) + int(v)
            return {"ok": True, "scope": "all", "totals": grand, "batches": batches, "live_root": str(lr)}

    # single batch dir summary
    if not track_dir.exists():
        return {"ok": False, "reason": "not_found", "path": str(track_dir)}
    by_worker = []
    totals = {DONE: 0, SKIPPED: 0, PENDING: 0, "Error": 0}
    for f in sorted(track_dir.glob("driver-*.json")):
        doc = _load_tracking(f)
        wid = doc.get("worker_id")
        c = _count_statuses_in_doc(doc)
        by_worker.append({"worker_id": wid, "file": f.name, "totals": c})
        for k, v in c.items():
            totals[k] = totals.get(k, 0) + int(v)

    return {
        "ok": True,
        "scope": "batch",
        "batch_id": batch_id or track_dir.name,
        "path": str(track_dir),
        "totals": totals,
        "by_worker": by_worker,
        "has_pending": totals.get(PENDING, 0) > 0,
    }


# services\ui.py

# services/ui.py
from selenium.webdriver.support.ui import WebDriverWait
from services.config import EXPLICIT_WAIT_SEC
from core.base import fluent_wait

def _wait_js(driver, script: str, timeout: int) -> bool:
    try:
        fluent_wait(driver, timeout).until(lambda d: bool(d.execute_script(script)))
        return True
    except Exception:
        return False

def wait_for_shell_home(driver, timeout: int | None = None) -> bool:
    """
    Ready when:
      - URL contains '#Shell-home', OR
      - UI5 core is initialized and ushell container is present.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    try:
        fluent_wait(driver, t).until(
            lambda d: "shell-home" in (d.current_url or "").lower()
        )
        return True
    except Exception:
        pass

    js = """
    try {
      if (!window.sap || !sap.ui) return false;
      if (sap.ushell && sap.ushell.Container) return true;
      var core = sap.ui.getCore && sap.ui.getCore();
      if (!core) return false;
      if (core.isInitialized && !core.isInitialized()) return false;
      return true;
    } catch (e) { return false; }
    """
    return _wait_js(driver, js, t)

def wait_ui5_idle(driver, timeout: int | None = None) -> bool:
    """
    Lightweight 'settled' check for UI5 renderer and DOM idle enough to interact.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    js = """
    try {
      if (document.readyState !== 'complete') return false;
      if (window.sap && sap.ui && sap.ui.getCore) {
        var core = sap.ui.getCore();
        if (core && core.isInitialized && !core.isInitialized()) return false;
        if (core && core.getUIDirty && core.getUIDirty()) return false;
      }
      return true;
    } catch (e) { return true; }
    """
    return _wait_js(driver, js, t)

def wait_url_contains(driver, needle: str, timeout: int | None = None) -> bool:
    t = timeout or EXPLICIT_WAIT_SEC
    try:
        fluent_wait(driver, t).until(
            lambda d: needle.lower() in (d.current_url or "").lower()
        )
        return True
    except Exception:
        return False

# ---------- Robust shell search readiness + JS fallback ----------

def wait_shell_search_ready(driver, timeout: int | None = None) -> bool:
    """
    Wait until the FLP header search control is available OR the renderer exists.
    """
    t = timeout or EXPLICIT_WAIT_SEC
    js = """
    try {
      var hasSearch = !!document.querySelector('a#sf.sapUshellShellHeadItm')
                   || !!document.querySelector("a.sapUshellShellHeadItm[data-help-id='shellHeader-search']")
                   || !!document.querySelector("a.sapUshellShellHeadItm[role='button'][aria-label*='Search']");
      if (hasSearch) return true;
      if (window.sap && sap.ushell && sap.ushell.Container) {
         var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
         if (r) return true;
      }
      return false;
    } catch(e){ return false; }
    """
    return _wait_js(driver, js, t)

def open_shell_search_via_js(driver) -> bool:
    """
    Ask the FLP renderer to open the global search.
    Returns True if we could call an API; False otherwise.
    """
    js = """
    try {
      if (window.sap && sap.ushell && sap.ushell.Container){
         var r = sap.ushell.Container.getRenderer && sap.ushell.Container.getRenderer();
         if (r){
            if (typeof r.showSearch === 'function'){ r.showSearch(true); return true; }
            if (typeof r.openSearch === 'function'){ r.openSearch(); return true; }
         }
      }
    } catch(e){}
    return false;
    """
    try:
        return bool(driver.execute_script(js))
    except Exception:
        return False


# services\worker.py

# services/worker.py
from __future__ import annotations

import logging
import threading
import time
from typing import Dict, Any, List, Tuple

from selenium.common.exceptions import (
    InvalidSessionIdException,
    WebDriverException,
    NoSuchWindowException,
    TimeoutException,
    StaleElementReferenceException,
    ElementClickInterceptedException,
    ElementNotInteractableException,
)

from services.schemas import ExchangeRateItem
from services.driver import get_driver
from services.auth import login
from services.ui import wait_ui5_idle, wait_for_shell_home, wait_shell_search_ready, wait_url_contains
from pages.Shell.Search.element import ShellSearch
from pages.CurrencyExchangeRates.page import CurrencyExchangeRatesPage
from services.commit import commit_gate
from services.tracking import mark_item_status, iter_pending_items

log = logging.getLogger("sapbot")


def _is_fatal_session_err(err: Exception) -> bool:
    msg = (str(err) or "").lower()
    return (
        isinstance(err, (InvalidSessionIdException, NoSuchWindowException))
        or any(s in msg for s in [
            "invalid session id",
            "chrome not reachable",
            "target closed",
            "disconnected: not connected to devtools",
            "cannot determine loading status",
        ])
    )


def _open_currency_app(drv) -> CurrencyExchangeRatesPage:
    if not wait_for_shell_home(drv, timeout=60):
        raise RuntimeError("Shell home not detected after login")
    wait_ui5_idle(drv, timeout=30)
    wait_shell_search_ready(drv, timeout=30)
    ShellSearch(drv).open_search().type_and_choose_app("Currency Exchange Rates")
    wait_ui5_idle(drv, timeout=30)
    wait_url_contains(drv, "#Currency-maintainExchangeRates", 40)
    page = CurrencyExchangeRatesPage(drv)
    page.ensure_in_app(max_attempts=3, settle_each=8)
    return page


def chunk_evenly(indexed: List[Tuple[int, ExchangeRateItem]], workers: int) -> List[List[Tuple[int, ExchangeRateItem]]]:
    n = max(1, min(workers, len(indexed))) if indexed else 1
    k, m = divmod(len(indexed), n)
    chunks: List[List[Tuple[int, ExchangeRateItem]]] = []
    start = 0
    for i in range(n):
        end = start + k + (1 if i < m else 0)
        if start < end:
            chunks.append(indexed[start:end])
        start = end
    return chunks


def worker_process(
    shard: List[Tuple[int, ExchangeRateItem]],
    stop_event: threading.Event,
    login_sem: threading.Semaphore,
    cfg: Dict[str, Any],
    worker_id: int,
    track_file_path,  # Path
) -> Dict[str, Any]:
    """
    Per-thread worker. Own Chrome session.
    Uses per-worker tracking file to persist progress. Status values:
      - Pending  → not finished, will be retried
      - Done     → created (success)
      - Skipped  → duplicate existed (policy)
      - Error    → terminal error for this batch
    """
    results: List[Dict[str, Any]] = []
    drv = None
    page = None

    WATCHDOG_SECONDS = int(cfg.get("WATCHDOG_SECONDS", 2000))
    MAX_OPEN_RETRIES = 3
    NONFATAL_RETRIES = 2  # soft retries inside SAME driver for flaky DOM

    # Build the pending queue from tracking (preferred) or from shard
    if track_file_path and track_file_path.exists():
        pending_list = iter_pending_items(track_file_path)
        if not pending_list:
            pending_list = shard[:]  # nothing pending, but keep structure
    else:
        pending_list = shard[:]

    def _kill_driver():
        nonlocal drv
        try:
            if drv:
                drv.quit()
        except Exception:
            pass
        drv = None

    def _recreate_driver_and_reopen(max_open_retries: int = MAX_OPEN_RETRIES):
        nonlocal drv, page
        log.warning("[reopen] worker=%s recreating driver (max_open_retries=%s)", worker_id, max_open_retries)
        _kill_driver()
        drv = get_driver(headless=cfg["HEADLESS"])
        with login_sem:
            login(drv)
        wait_ui5_idle(drv, timeout=30)
        last_exc = None
        for attempt in range(1, max_open_retries + 1):
            try:
                page_local = _open_currency_app(drv)
                log.info("[reopen] worker=%s reopened app on attempt=%s", worker_id, attempt)
                return page_local
            except Exception as e:
                last_exc = e
                log.error("[reopen] worker=%s attempt=%s failed: %s: %s", worker_id, attempt, type(e).__name__, e)
                time.sleep(1.0 * attempt)
        raise RuntimeError(f"open_app_failed after {max_open_retries} attempts: {last_exc}")

    def _track_skipped(idx: int, row: Dict[str, Any]):
        """
        Ensure dialog_text (or error) is persisted for Skipped rows, both in results and tracking.
        """
        # normalize & keep dialog_text in results
        if not row.get("dialog_text"):
            # sometimes the page may put the message in 'error'
            if row.get("error"):
                row["dialog_text"] = row["error"]
        results.append(row)
        if track_file_path:
            mark_item_status(
                track_file_path,
                idx,
                "Skipped",
                {
                    "notes": row.get("notes", {}),
                    "dialog_text": row.get("dialog_text") or "",
                },
            )

    try:
        try:
            page = _recreate_driver_and_reopen()
        except Exception as e:
            # Could not open a browser/app now. Leave rows Pending so the runner requeues.
            log.error("[init-failed] worker=%s could not open driver/app: %s: %s",
                      worker_id, type(e).__name__, e)
            return {"interrupted": False, "results": []}

        for idx, it in pending_list:
            if stop_event.is_set():
                stop_event.clear()

            def _watchdog_kill():
                log.critical("[watchdog] worker=%s idx=%s exceeded=%ss → killing driver", worker_id, idx, WATCHDOG_SECONDS)
                _kill_driver()

            def _do_one():
                timer = threading.Timer(WATCHDOG_SECONDS, _watchdog_kill)
                timer.daemon = True
                timer.start()
                try:
                    return page.create_rate(
                        exch_type=it.ExchangeRateType,
                        from_ccy=it.FromCurrency,
                        to_ccy=it.ToCurrency,
                        valid_from_mmddyyyy=it.ValidFrom,
                        quotation=it.Quotation,
                        rate_value=it.ExchangeRate,
                        commit_gate=commit_gate,
                    )
                finally:
                    try:
                        timer.cancel()
                    except Exception:
                        pass

            soft_attempt = 0
            while True:
                try:
                    res = _do_one()
                    row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                    # normalize status coming from page
                    st = (row.get("status") or "").strip().lower()
                    if st == "created":
                        results.append(row)
                        if track_file_path:
                            mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                    elif st == "skipped":
                        _track_skipped(idx, row)
                    elif st == "pending":
                        results.append(row)
                        if track_file_path:
                            mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                    else:
                        results.append({**row, "status": "error"})
                        if track_file_path:
                            mark_item_status(track_file_path, idx, "Error",
                                             {"error": row.get("error") | row.get("dialog_text") if isinstance(row.get("error"), str) else (row.get("dialog_text") or "")})
                    time.sleep(0.2)
                    break

                except TimeoutException as e:
                    log.error("[driver-recreate] worker=%s idx=%s cause=TimeoutException msg=%r", worker_id, idx, str(e))
                    try:
                        page = _recreate_driver_and_reopen(max_open_retries=2)
                        res = _do_one()
                        row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                        st = (row.get("status") or "").strip().lower()
                        if st == "created":
                            results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                        elif st == "skipped":
                            _track_skipped(idx, row)
                        elif st == "pending":
                            results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                        else:
                            results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                          {"error": row.get("error") or row.get("dialog_text") or ""})
                    except Exception as e2:
                        row = {
                            "index": idx, "payload": it.dict(), "status": "error",
                            "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                            "worker": worker_id,
                        }
                        results.append(row)
                        if track_file_path:
                            mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                    break

                except (StaleElementReferenceException, ElementClickInterceptedException, ElementNotInteractableException) as e:
                    if soft_attempt < NONFATAL_RETRIES:
                        soft_attempt += 1
                        log.warning("[soft-retry] worker=%s idx=%s attempt=%s cls=%s msg=%r",
                                    worker_id, idx, soft_attempt, type(e).__name__, str(e))
                        try:
                            page.ensure_in_app_quick()
                        except Exception:
                            try:
                                page.ensure_in_app(max_attempts=2, settle_each=8)
                            except Exception:
                                pass
                        time.sleep(0.3)
                        continue
                    else:
                        log.error("[soft-retry-exhausted] worker=%s idx=%s cls=%s → recreating driver",
                                  worker_id, idx, type(e).__name__)
                        try:
                            page = _recreate_driver_and_reopen(max_open_retries=2)
                            res = _do_one()
                            row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                            st = (row.get("status") or "").strip().lower()
                            if st == "created":
                                results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                            elif st == "skipped":
                                _track_skipped(idx, row)
                            elif st == "pending":
                                results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                            else:
                                results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                              {"error": row.get("error") or row.get("dialog_text") or ""})
                        except Exception as e2:
                            row = {
                                "index": idx, "payload": it.dict(), "status": "error",
                                "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                "worker": worker_id,
                            }
                            results.append(row)
                            if track_file_path:
                                mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                        break

                except WebDriverException as e:
                    fatal = _is_fatal_session_err(e)
                    log.error("[driver-exc] worker=%s idx=%s fatal=%s cls=%s msg=%r",
                              worker_id, idx, fatal, type(e).__name__, str(e))
                    if fatal:
                        try:
                            page = _recreate_driver_and_reopen(max_open_retries=2)
                            res = _do_one()
                            row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                            st = (row.get("status") or "").strip().lower()
                            if st == "created":
                                results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                            elif st == "skipped":
                                _track_skipped(idx, row)
                            elif st == "pending":
                                results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                            else:
                                results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                              {"error": row.get("error") or row.get("dialog_text") or ""})
                        except Exception as e2:
                            row = {
                                "index": idx, "payload": it.dict(), "status": "error",
                                "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                "worker": worker_id,
                            }
                            results.append(row)
                            if track_file_path:
                                mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                    else:
                        if soft_attempt < NONFATAL_RETRIES:
                            soft_attempt += 1
                            log.warning("[soft-retry] worker=%s idx=%s attempt=%s nonfatal-webdriver cls=%s msg=%r",
                                        worker_id, idx, soft_attempt, type(e).__name__, str(e))
                            try:
                                page.ensure_in_app_quick()
                            except Exception:
                                try:
                                    page.ensure_in_app(max_attempts=2, settle_each=8)
                                except Exception:
                                    pass
                            time.sleep(0.3)
                            continue
                        else:
                            log.error("[soft-retry-exhausted] worker=%s idx=%s nonfatal-webdriver → recreating driver",
                                      worker_id, idx)
                            try:
                                page = _recreate_driver_and_reopen(max_open_retries=2)
                                res = _do_one()
                                row = {"index": idx, "payload": it.dict(), **res, "worker": worker_id}
                                st = (row.get("status") or "").strip().lower()
                                if st == "created":
                                    results.append(row); mark_item_status(track_file_path, idx, "Done", {"notes": row.get("notes", {})})
                                elif st == "skipped":
                                    _track_skipped(idx, row)
                                elif st == "pending":
                                    results.append(row); mark_item_status(track_file_path, idx, "Pending", {"notes": row.get("notes", {})})
                                else:
                                    results.append({**row, "status": "error"}); mark_item_status(track_file_path, idx, "Error",
                                                                                                {"error": row.get("error") or row.get("dialog_text") or ""})
                            except Exception as e2:
                                row = {
                                    "index": idx, "payload": it.dict(), "status": "error",
                                    "error": f"recover_failed(w{worker_id}): {type(e2).__name__}: {e2}",
                                    "worker": worker_id,
                                }
                                results.append(row)
                                if track_file_path:
                                    mark_item_status(track_file_path, idx, "Error", {"error": row["error"]})
                    break

    finally:
        try:
            if drv:
                drv.quit()
        except Exception:
            pass

    return {"interrupted": False, "results": results}


# services\__init__.py

from .config import config
from .driver import get_driver
from .auth import login

__all__ = ["config", "get_driver", "login"]


# pages\CurrencyExchangeRates\page.py

# pages/CurrencyExchangeRates/page.py

from urllib.parse import urlparse
from datetime import datetime
import os
import time
import re
from typing import Optional
from contextlib import nullcontext

from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Page, Element
from services.ui import wait_ui5_idle
from .selectors import APP_HASH

# Elements
from .elements.ListToolbar.element import ListToolbar
from .elements.Dialog.element import DialogWatcher
from .elements.Fields.element import Fields
from .elements.Factors.element import Factors
from .elements.Quotation.element import QuotationField
from .elements.Rate.element import ExchangeRateField
from .elements.Footer.element import FooterActions
from .elements.Toast.element import ToastReader
from .elements.Validation.element import ValidationInspector
from .elements.SideColumn.element import SideColumnController
from .elements.Header.element import ObjectHeaderVerifier

# For verify-after-set of Quotation
from .elements.Quotation.selectors import QUOTATION_INNER_INPUT_XPATH

# legacy constant (not used directly; Fields.EXCH_TYPE_INPUT_XPATH is used)
EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,"
                         "'ExchangeRateTypeForEdit::Field-input-inner')]")

# The exact label we want for the Exchange Rate Type field
TARGET_EXCH_TYPE_LABEL = "M (Standard translation at average rate)"

# --- tiny retry helper (local, non-invasive) ---
def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class CurrencyExchangeRatesPage(Page):
    def __init__(self, driver, root: Optional[str] = None):
        super().__init__(driver, root)
        self._app_ready_fast = False  # quick flag

    def _el(self) -> Element:
        return Element(self.driver)

    # -------- Utilities --------
    def _origin(self) -> str:
        try:
            return self.driver.execute_script("return location.origin;")
        except Exception:
            parsed = urlparse(self.driver.current_url or "")
            return f"{parsed.scheme}://{parsed.netloc}"

    def _app_root_url(self) -> str:
        return f"{self._origin()}/ui?sap-ushell-config=lean{APP_HASH}"

    def _wait_not_busy(self, timeout: int) -> bool:
        end = time.time() + max(1, timeout)
        while time.time() < end:
            try:
                busy = self.driver.execute_script(
                    """
                    try{
                      var core=sap && sap.ui && sap.ui.getCore ? sap.ui.getCore():null;
                      if(core && core.isInitialized && !core.isInitialized()) return true;
                      if(core && core.getUIDirty && core.getUIDirty()) return true;
                      var BI=sap && sap.ui && sap.ui.core && sap.ui.core.BusyIndicator;
                      if(BI && BI.oPopup && BI.oPopup.getOpenState && BI.oPopup.getOpenState() === 'OPEN'){return true;}
                      return false;
                    }catch(e){return false;}
                    """
                )
                if not busy:
                    return True
            except Exception:
                return True
            time.sleep(0.12)
        return False

    # --- EXACTLY set Exchange Rate Type to the full label ---
    def _set_exchange_rate_type_exact(self, fields: Fields, timeout: int = 12) -> dict:
        """
        Hard-sets Exchange Rate Type to the exact UI label:
          M (Standard translation at average rate)

        Returns:
          {"ok": True, "observed": "<value>"} when confirmed exact,
          {"ok": False, "observed": "<value>", "why": "<reason>"} otherwise.
        """
        el = self._el()
        t = max(timeout, el._timeout)

        def _get():
            try:
                return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
            except Exception:
                return ""

        def _blur(xpath: str):
            try:
                self.driver.execute_script(
                    """
                    try{
                      var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                      if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur && el.blur(); }
                    }catch(e){}
                    """,
                    xpath
                )
            except Exception:
                pass

        # fast path — already exact
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        # 1) Try simple 'M' + Enter + blur
        try:
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, "M", press_enter=True)
        except Exception:
            pass
        _blur(fields.EXCH_TYPE_INPUT_XPATH)
        wait_ui5_idle(self.driver, timeout=t)
        self._wait_not_busy(t)
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        # 2) Open value-help and pick exact label
        try:
            vhi_xpath = fields.EXCH_TYPE_INPUT_XPATH.replace("-inner", "-vhi")
            vhi = el.wait_clickable(By.XPATH, vhi_xpath)
            el.js_click(vhi)

            WebDriverWait(self.driver, t).until(
                EC.presence_of_element_located((By.XPATH,
                    "//*[contains(@class,'sapMDialog') or contains(@class,'sapUiMdcValueHelpDialog') or contains(@class,'sapMPopup')]"))
            )
            exact_cell = WebDriverWait(self.driver, t).until(
                EC.element_to_be_clickable((By.XPATH, f"//span[normalize-space(text())='{TARGET_EXCH_TYPE_LABEL}']"))
            )
            el.js_click(exact_cell)

            # If value-help has an OK button, click it
            try:
                ok_btn = WebDriverWait(self.driver, 2).until(
                    EC.element_to_be_clickable((By.XPATH, "//button[.//bdi[normalize-space()='OK'] or .//span[normalize-space()='OK']]"))
                )
                el.js_click(ok_btn)
            except Exception:
                pass
        except Exception:
            pass

        _blur(fields.EXCH_TYPE_INPUT_XPATH)
        wait_ui5_idle(self.driver, timeout=t)
        self._wait_not_busy(t)
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        return {"ok": False, "observed": cur, "why": "could_not_select_exact_label"}

    # -------- App navigation (hardened) --------
    def ensure_in_app(self, max_attempts: int = 2, settle_each: int = 8):
        attempts = max(1, max_attempts)
        listbar = ListToolbar(self.driver)
        sidecol = SideColumnController(self.driver)

        for _ in range(attempts):
            cur = (self.driver.current_url or "")
            if APP_HASH.lower() not in cur.lower():
                self.driver.execute_script("location.href = arguments[0];", self._app_root_url())

            wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, settle_each))
            self._wait_not_busy(max(self._el()._timeout, settle_each))

            sidecol.close_if_present(timeout=min(10, max(8, self._el()._timeout)))

            try:
                listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
                self._app_ready_fast = True
                return
            except TimeoutException:
                self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
                time.sleep(0.5)

        self._app_ready_fast = False
        raise TimeoutException(f"ensure_in_app failed after {attempts} attempts.")

    def ensure_in_app_quick(self):
        if self._app_ready_fast:
            try:
                if ListToolbar(self.driver).is_at_list(quick=1.0):
                    return
            except Exception:
                pass
        self.ensure_in_app(max_attempts=3, settle_each=8)

    def back_to_list(self):
        listbar = ListToolbar(self.driver)
        self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
        wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, 20))
        listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
        self._app_ready_fast = True

    # -------- Internal helpers --------
    def _click_list_create(self, timeout: int | None = None):
        listbar = ListToolbar(self.driver)
        listbar.click_create(timeout or self._el()._timeout)
        wait_ui5_idle(self.driver, timeout=timeout or self._el()._timeout)
        self._wait_not_busy(timeout or self._el()._timeout)

    def _read_last_toast_text(self) -> str:
        return ToastReader(self.driver).read_last()

    def _wait_object_header_ready(self, timeout: int) -> bool:
        return ObjectHeaderVerifier(self.driver).wait_ready(timeout=timeout)

    def _wait_for_success_toast_or_list(self, timeout: int) -> dict:
        listbar = ListToolbar(self.driver)
        dlg = DialogWatcher(self.driver)
        end = time.time() + max(timeout, self._el()._timeout)
        info = {"toast": "", "dialog": "", "at_list": False}
        while time.time() < end:
            if dlg.is_open():
                info["dialog"] = dlg.text() or "Dialog open (no text captured)."
                return info
            txt = ToastReader(self.driver).read_last()
            if txt:
                info["toast"] = txt
                lt = txt.lower()
                if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                    return info
            try:
                listbar.wait_create_clickable(timeout=0.8)
                info["at_list"] = True
                return info
            except Exception:
                pass
            time.sleep(0.18)
        return info

    # -------- SOFT guard: ensure type contains 'M' (do not abort) --------
    def _soft_ensure_exch_type_contains_M(self, fields: Fields, desired_exch_type: str) -> dict:
        """
        Ensure the Exchange Rate Type *contains* 'M' BEFORE clicking Create,
        but do NOT abort the row pre-commit.
        """
        def _get():
            try:
                return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
            except Exception:
                return ""

        cur = _get()
        if "m" in cur.lower():
            return {"ok": True, "observed": cur}

        # corrective retype
        try:
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, desired_exch_type, press_enter=True)
        except Exception:
            pass
        # explicit blur to fire change bindings
        try:
            self.driver.execute_script(
                """
                try{
                  var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                  if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur&&el.blur(); }
                }catch(e){}
                """,
                fields.EXCH_TYPE_INPUT_XPATH
            )
        except Exception:
            pass

        wait_ui5_idle(self.driver, timeout=self._el()._timeout)
        self._wait_not_busy(self._el()._timeout)

        cur2 = _get()
        return {"ok": ("m" in cur2.lower()), "observed": cur2}

    # ---------------- NEW helpers for your policy ----------------
    def _detect_lock_info(self, text: str) -> dict | None:
        if not text:
            return None
        low = text.lower()
        if "locked by user" in low and "table" in low and "tcurr" in low:
            m = re.search(r"Table\s+(\w+)\s+is\s+locked\s+by\s+user\s+([A-Za-z0-9_]+)", text, re.IGNORECASE)
            table = None
            owner = None
            if m:
                table = m.group(1)
                owner = m.group(2)
            return {"table": table or "TCURR", "owner": owner or ""}
        return None

    def _is_required_fields_dialog(self, s: str) -> bool:
        return "fill out all required entry fields" in (s or "").lower()

    def _is_duplicate_exists(self, s: str) -> bool:
        low = (s or "").lower()
        return ("exchange rate" in low) and ("already exists in the system" in low)

    # -------- Public: create + submit --------
    def create_entry_and_submit(
        self,
        exch_type: str,
        from_ccy: str,
        to_ccy: str,
        valid_from_ddmmyyyy: str,     # IMPORTANT: pass DD.MM.YYYY
        quotation: str,
        rate_str: str,
        commit_gate=None,
    ) -> dict:
        fields = Fields(self.driver)
        factors = Factors(self.driver)
        quote = QuotationField(self.driver)
        rate = ExchangeRateField(self.driver)
        footer = FooterActions(self.driver)
        listbar = ListToolbar(self.driver)
        dlg = DialogWatcher(self.driver)
        sidecol = SideColumnController(self.driver)
        validate = ValidationInspector(self.driver)

        el = self._el()

        # QUICK ensure to avoid heavy waits on every item
        self.ensure_in_app_quick()

        # ---------- local helpers ----------
        def _noop_gate_ctx():
            class _C:
                def __enter__(self): return None
                def __exit__(self, *a): return False
            return _C()

        def _verify_or_retype(xpath: str, expected: str) -> None:
            if expected is None:
                return
            got = (fields.get_input_value(xpath) or "").strip()
            if got.lower() != (expected or "").strip().lower():
                fields.set_plain_input(xpath, expected, press_enter=True)
                _ = fields.get_input_value(xpath)

        def _verify_quotation(expected: str) -> None:
            try:
                cur = _retry_stale(lambda: (self.driver.find_element(By.XPATH, QUOTATION_INNER_INPUT_XPATH).get_attribute("value") or "").strip())
            except Exception:
                cur = ""
            if cur.lower() != (expected or "").strip().lower():
                quote.set_value(expected)

        def _fill_all_fields(prefer_ui5_for_rate: bool = False):
            # 1) Exchange Rate Type
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, exch_type, press_enter=True)
            _verify_or_retype(fields.EXCH_TYPE_INPUT_XPATH, exch_type)

            # 2) From Currency
            fields.set_plain_input(fields.FROM_CCY_INPUT_XPATH, from_ccy, press_enter=True)
            _verify_or_retype(fields.FROM_CCY_INPUT_XPATH, from_ccy)

            # 3) To Currency
            fields.set_plain_input(fields.TO_CCY_INPUT_XPATH, to_ccy, press_enter=True)
            _verify_or_retype(fields.TO_CCY_INPUT_XPATH, to_ccy)

            # 4) Valid From — **DD.MM.YYYY**
            fields.set_plain_input(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy, press_enter=True)
            _verify_or_retype(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy)

            # 5) Quotation
            quote.set_value(quotation)
            _verify_quotation(quotation)

            # 6) Factors and Rate
            factors.try_set_from("1")
            factors.try_set_to("1")
            if prefer_ui5_for_rate:
                rate.set_via_ui5(rate_str)
                rate.commit(times=1)
            else:
                rate.set_via_typing(rate_str)
                rate.commit(times=2)

        def _looks_like_required_fields_issue(msgs: list[dict]) -> bool:
            if not msgs:
                return False
            blob = " | ".join(
                f"{(m.get('message') or '')} {m.get('description') or ''}".lower()
                for m in msgs
            )
            keys = (
                "fill out all required",
                "required entry fields",
                "required field",
                "mandatory field",
                "exchange rate type",
                "from currency",
            )
            return any(k in blob for k in keys)

        def _commit_flow_under_gate() -> dict:
            gate_ctx = commit_gate() if callable(commit_gate) else _noop_gate_ctx()
            with gate_ctx:
                first_phase = footer.click_create(clicks=1)

                header_ready = self._wait_object_header_ready(timeout=min(10, max(8, el._timeout)))
                if header_ready:
                    sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))
                    return {
                        "status": "created",
                        "footer_clicks": 1,
                        "intermediate_toasts": first_phase.get("toasts", []),
                        "toast": self._read_last_toast_text(),
                        "at_list": True,
                        "dialog_open": False,
                        "dialog_text": "",
                    }

                loop_res = footer.ensure_created_by_loop_clicking(
                    object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                    at_list=lambda: listbar.is_at_list(quick=0.8),
                    close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                    total_timeout=max(35, el._timeout),
                    max_clicks=5,
                )
                if loop_res.get("status") in ("created", "dialog_open", "activation_error"):
                    return loop_res

                final_phase = self._wait_for_success_toast_or_list(timeout=max(el._timeout, 18))
                if not final_phase.get("at_list"):
                    sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))

                if final_phase.get("dialog"):
                    return {
                        "status": "dialog_open",
                        "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                        "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                        "toast": final_phase.get("toast", ""),
                        "dialog_open": True,
                        "dialog_text": final_phase.get("dialog", ""),
                    }

                status_guess = "created" if (
                    final_phase.get("at_list")
                    or (final_phase.get("toast") and any(k in final_phase.get("toast", "").lower()
                        for k in ("created", "activated", "successfully")))
                ) else "unknown"

                if status_guess != "created":
                    strict = footer.ensure_created_by_loop_clicking(
                        object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                        at_list=lambda: listbar.is_at_list(quick=0.8),
                        close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                        total_timeout=max(30, el._timeout),
                        max_clicks=5,
                    )
                    if strict.get("status") == "created":
                        return strict

                return {
                    "status": status_guess,
                    "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                    "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                    "toast": final_phase.get("toast", ""),
                    "at_list": True,
                    "dialog_open": False,
                    "dialog_text": "",
                }

        # 1) Open form
        self._click_list_create(timeout=el._timeout)

        # 2) Fill fields (DD.MM.YYYY is passed straight through)
        _fill_all_fields(prefer_ui5_for_rate=False)

        # 2.5) SOFT GUARD: ensure Exchange Rate Type *contains* "M"
        m_check = self._soft_ensure_exch_type_contains_M(fields, exch_type)

        # 3) Pre-submit validation (client)
        err = ValidationInspector(self.driver).collect()
        if err and "greater than zero" in (err or "").lower():
            Factors(self.driver).try_set_from("1")
            Factors(self.driver).try_set_to("1")
            ExchangeRateField(self.driver).set_via_ui5(rate_str)
            ExchangeRateField(self.driver).commit(times=1)
            err = ValidationInspector(self.driver).collect()

        # 4) COMMIT attempt
        res = _commit_flow_under_gate()
        status = (res.get("status") or "").lower()

        # 5) Post-commit note if M was missing pre-commit
        if not m_check.get("ok", True):
            res.setdefault("notes", {})
            res["notes"]["exch_type_missing_M_precommit"] = True
            res["notes"]["observed_exch_type"] = m_check.get("observed", "")

        # --- Build a combined message blob for policy checks
        msgs_from_res = res.get("messages", []) or []
        joined_msgs = " | ".join(f"{(m.get('message') or '')} {m.get('description') or ''}".strip() for m in msgs_from_res)
        joined_all = " | ".join([res.get("dialog_text") or "", joined_msgs]).strip()

        # *** NEW *** also read the Message Popover (this is where "already exists" lives)
        pop_msgs = []
        try:
            pop_msgs = footer.open_and_read_messages(timeout=max(6, el._timeout))
        except Exception:
            pop_msgs = []
        if pop_msgs:
            # add to the joined blob for the same downstream checks
            joined_all = " | ".join(filter(None, [joined_all, " | ".join(pop_msgs)]))
        # close popover (so footer buttons stay clickable)
        try:
            footer.close_message_popover_if_open(timeout=3)
        except Exception:
            pass

        # === POLICY REMAP ===
        # TCURR lock anywhere → Pending (not Locked)
        lock = self._detect_lock_info(joined_all)
        if lock:
            try: DialogWatcher(self.driver).close(timeout=1.0)
            except Exception: pass
            SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
            try: self.back_to_list()
            except Exception: pass
            return {
                "status": "pending",
                "dialog_open": False,
                "dialog_text": res.get("dialog_text", ""),
                "notes": {
                    "lock_table": lock.get("table", "TCURR"),
                    "lock_owner": lock.get("owner", ""),
                    "reason": "table_lock_tcurr"
                }
            }

        # Duplicate exists → Skipped **AND discard draft** (new behavior)
        # keep your existing detector, but now it sees popover text too
        if self._is_duplicate_exists(joined_all) or ("already exists" in joined_all.lower()):
            # close any popover/dialog so the footer is clickable
            try: DialogWatcher(self.driver).close(timeout=1.2)
            except Exception: pass
            try: footer.close_message_popover_if_open(timeout=2)
            except Exception: pass

            # attempt to discard the draft quietly
            try:
                _discarded = footer.discard_draft(timeout=max(8, el._timeout))
            except Exception:
                _discarded = False

            # close side column (no-op if already closed) and go back to list
            SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
            try: self.back_to_list()
            except Exception: pass

            out = {
                "status": "skipped",
                "dialog_open": False,
                "dialog_text": res.get("dialog_text", ""),
                "notes": {
                    "already_existed": True,
                    "draft_discarded": bool(_discarded),
                    "message_count": len(pop_msgs) if pop_msgs else len(msgs_from_res),
                },
            }
            return out

        # Created passes through as Created (runner/worker mapping unchanged)
        if status == "created":
            return res

        # Unknown: re-queue → map to 'pending'
        if status == "unknown":
            res["status"] = "pending"
            return res

        # anything else → return as-is (error/activation_error/dialog_open, etc.)
        return res

    def create_rate(
        self,
        exch_type: str,
        from_ccy: str,
        to_ccy: str | None = None,
        valid_from_mmddyyyy: str = "",
        quotation: str = "",
        rate_value: str | float = "",
        to_cy: str | None = None,
        commit_gate=None,
    ) -> dict:
        """
        NOTE: pass date in **DD.MM.YYYY**. We DO NOT convert here.
        services.schemas.ExchangeRateItem already normalizes to DD.MM.YYYY.
        """
        if to_ccy is None and to_cy is not None:
            to_ccy = to_cy
        if to_ccy is None:
            raise TypeError("create_rate() missing required argument: 'to_ccy'")

        valid_from_ddmmyyyy = valid_from_mmddyyyy

        return self.create_entry_and_submit(
            exch_type=exch_type,
            from_ccy=from_ccy,
            to_ccy=to_ccy,
            valid_from_ddmmyyyy=valid_from_ddmmyyyy,   # typed as-is
            quotation=quotation,
            rate_str=str(rate_value),
            commit_gate=commit_gate,
        )


# pages\CurrencyExchangeRates\selectors.py

# pages/CurrencyExchangeRates/selectors.py
APP_HASH = "#Currency-maintainExchangeRates"


# pages\CurrencyExchangeRates\__init__.py



# pages\Index\page.py

# pages/Index/page.py
from core.base import Page
from services.ui import wait_ui5_idle
from .PurchasingTab.element import PurchasingTab
from .ProcurementOverviewTile.element import ProcurementOverviewTile

class IndexPage(Page):
    """Fiori Launchpad 'Shell-home' landing."""

    def ensure_home(self):
        wait_ui5_idle(self.driver)

    def to_purchasing(self):
        PurchasingTab(self.driver).click()
        wait_ui5_idle(self.driver)

    def open_procurement_overview(self):
        ProcurementOverviewTile(self.driver).click()
        wait_ui5_idle(self.driver)


# pages\Index\__init__.py



# pages\Login\page.py

from core.base import Page
from services.config import config
from .elements.Username.element import Username
from .elements.Password.element import Password
from .elements.Submit.element import Submit

class LoginPage(Page):
    def go(self):
        self.open(config()["SAP_URL"])

    def login(self, username: str, password: str):
        self.go()
        Username(self.driver).set(username)
        Password(self.driver).set(password)
        Submit(self.driver).click()
        # Post-click, S/4HANA may keep same URL but replace DOM; verification is in services.ui


# pages\Login\__init__.py



# pages\Shell\__init__.py



# pages\CurrencyExchangeRates\elements\__init__.py



# pages\CurrencyExchangeRates\elements\Dialog\element.py

# pages/CurrencyExchangeRates/elements/Dialog/element.py
from __future__ import annotations

from typing import Optional
import time

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    StaleElementReferenceException,
    NoSuchElementException,
)

from core.base import Element

# Robust selectors for the Message Popover
_POPOVER_WRAPPER_CSS = ".sapMPopoverWrapper"
_POPOVER_CONT_CSS    = ".sapMPopoverCont"
_CLOSE_BTN_CSS       = "button.sapMMsgPopoverCloseBtn"   # the “X” button
# Title/span for message text (works for list view items)
_MSG_ITEM_TITLE_XP   = "//li[contains(@class,'sapMMsgViewItem')]" \
                        "//span[contains(@id,'-titleText')]"

# Generic dialog “Close” button by visible text
_CLOSE_BDI_BTN_XP    = "//bdi[normalize-space()='Close']/ancestor::button[1] | //button[.//bdi[normalize-space()='Close']]"
# Generic OK button (fallbacks)
_OK_BDI_BTN_XP       = "//bdi[normalize-space()='OK']/ancestor::button[1] | //button[.//bdi[normalize-space()='OK']]"

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class DialogWatcher:
    """
    Handles both classic sap.m.Dialog and the Message Popover.
    Now also knows how to click a <bdi>Close</bdi> button exactly like:
      <span class="sapMBtnContent"><bdi>Close</bdi></span>
    """

    def __init__(self, driver):
        self.driver = driver
        self._el = Element(driver)

    # ---------- basic checks ----------
    def _any_popover_present(self) -> bool:
        def _see():
            els = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
            return any((e.is_displayed() for e in els))
        try:
            return _retry_stale(_see)
        except Exception:
            return False

    def is_open(self) -> bool:
        if self._any_popover_present():
            return True
        try:
            return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _CLOSE_BDI_BTN_XP)))
        except Exception:
            pass
        try:
            return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _OK_BDI_BTN_XP)))
        except Exception:
            pass
        return False

    # ---------- text scraping ----------
    def text(self, timeout: float = 0.5) -> str:
        end = time.time() + timeout
        while time.time() < end:
            try:
                el = WebDriverWait(self.driver, 0.25, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.presence_of_element_located((By.XPATH, _MSG_ITEM_TITLE_XP))
                )
                if el.is_displayed():
                    try:
                        return el.text.strip()
                    except StaleElementReferenceException:
                        pass
                break
            except Exception:
                pass
        try:
            return (self.driver.execute_script("""
                try{
                  var dlg = document.querySelector("div[role='dialog']");
                  if(!dlg) return '';
                  var h = dlg.querySelector(".sapMDialogTitle, .sapMTitle, [role='heading']");
                  return (h && (h.innerText||h.textContent)||'').trim();
                }catch(e){ return ''; }
            """) or "").strip()
        except Exception:
            return ""

    # ---------- close helpers ----------
    def _try_click_close_button_once(self) -> bool:
        try:
            pops = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
            for pop in pops:
                try:
                    if not pop.is_displayed():
                        continue
                except StaleElementReferenceException:
                    continue
                try:
                    btn = pop.find_element(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                except NoSuchElementException:
                    try:
                        btns = self.driver.find_elements(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                        btn  = next((b for b in btns if b.is_displayed()), None)
                    except StaleElementReferenceException:
                        btn = None
                if btn:
                    try:
                        self._el.js_click(btn)
                        return True
                    except StaleElementReferenceException:
                        pass
        except StaleElementReferenceException:
            return False
        except Exception:
            return False
        return False

    def _js_fallback_close_all_popovers(self) -> bool:
        try:
            return bool(self.driver.execute_script("""
                try{
                  var closed = 0;
                  document.querySelectorAll('button.sapMMsgPopoverCloseBtn').forEach(function(b){
                    try{
                      var r = b.getBoundingClientRect();
                      var visible = !!(r.width || r.height) && window.getComputedStyle(b).visibility !== 'hidden';
                      if (visible) { b.click(); closed++; }
                    }catch(e){}
                  });
                  return closed > 0;
                }catch(e){ return false; }
            """))
        except Exception:
            return False

    def _click_bdi_close(self) -> bool:
        try:
            btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, _CLOSE_BDI_BTN_XP))
            )
            try:
                self._el.js_click(btn)
            except Exception:
                try:
                    btn.click()
                except Exception:
                    pass
            return True
        except Exception:
            return False

    def _click_ok(self) -> bool:
        try:
            btn = WebDriverWait(self.driver, 1.0, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, _OK_BDI_BTN_XP))
            )
            try:
                self._el.js_click(btn)
            except Exception:
                try:
                    btn.click()
                except Exception:
                    pass
            return True
        except Exception:
            return False

    # ---------- public API ----------
    def close(self, timeout: float = 2.0) -> bool:
        end = time.time() + max(0.2, timeout)

        while time.time() < end:
            # Popover?
            if self._any_popover_present():
                for _ in (1, 2):
                    if self._try_click_close_button_once():
                        try:
                            WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                                EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                            )
                        except Exception:
                            pass
                        if not self._any_popover_present():
                            return True
                if self._js_fallback_close_all_popovers():
                    try:
                        WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                            EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                        )
                    except Exception:
                        pass
                    if not self._any_popover_present():
                        return True

            # Dialog “Close”
            if self._click_bdi_close():
                time.sleep(0.15)
                if not self.is_open():
                    return True

            # Dialog “OK” fallback
            if self._click_ok():
                time.sleep(0.15)
                if not self.is_open():
                    return True

            time.sleep(0.12)

        return not self.is_open()


# pages\CurrencyExchangeRates\elements\Dialog\selectors.py

# Generic dialog root
DIALOG_ROOT_CSS = "div[role='dialog']"


# pages\CurrencyExchangeRates\elements\Dialog\__init__.py



# pages\CurrencyExchangeRates\elements\Factors\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import FROM_FACTOR_BY_LABEL_XPATH, TO_FACTOR_BY_LABEL_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class Factors(Element):
    def _try_set_by_label(self, label_xpath: str, value: str = "1") -> bool:
        def _find():
            return self.driver.find_element(By.XPATH, label_xpath)

        try:
            inp = _retry_stale(_find)
        except Exception:
            return False

        try:
            for fn in (
                lambda: inp.clear(),
                lambda: inp.send_keys(Keys.CONTROL, "a"),
                lambda: inp.send_keys(Keys.DELETE),
                lambda: self.driver.execute_script(
                    "arguments[0].value='';"
                    "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
            ):
                try:
                    _retry_stale(fn)
                except Exception:
                    pass

            _retry_stale(lambda: inp.send_keys(value))
            try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
            except Exception: pass
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            return True
        except Exception:
            return False

    def try_set_from(self, value: str = "1") -> bool:
        return self._try_set_by_label(FROM_FACTOR_BY_LABEL_XPATH, value)

    def try_set_to(self, value: str = "1") -> bool:
        return self._try_set_by_label(TO_FACTOR_BY_LABEL_XPATH, value)


# pages\CurrencyExchangeRates\elements\Factors\selectors.py

FROM_FACTOR_BY_LABEL_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='From Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Unit')]]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Factor')]]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)
TO_FACTOR_BY_LABEL_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='To Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Unit')]]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Factor')]]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)


# pages\CurrencyExchangeRates\elements\Factors\__init__.py



# pages\CurrencyExchangeRates\elements\Fields\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import (
    EXCH_TYPE_INPUT_XPATH,
    FROM_CCY_INPUT_XPATH,
    TO_CCY_INPUT_XPATH,
    VALID_FROM_INPUT_XPATH,
)

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class Fields(Element):
    EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,'ExchangeRateTypeForEdit::Field-input-inner')]")
    FROM_CCY_INPUT_XPATH  = ("//input[contains(@id,'SourceCurrencyForEdit::Field-input-inner')]")
    TO_CCY_INPUT_XPATH    = ("//input[contains(@id,'TargetCurrencyForEdit::Field-input-inner')]")
    VALID_FROM_INPUT_XPATH= ("//input[contains(@id,'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')]")

    def _hard_clear(self, web_el):
        for fn in (
            lambda: web_el.clear(),
            lambda: web_el.send_keys(Keys.CONTROL, "a"),
            lambda: web_el.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", web_el),
        ):
            try: _retry_stale(fn)
            except Exception: pass

    def get_input_value(self, xpath: str) -> str:
        def _get():
            el = self.find(By.XPATH, xpath)
            return el.get_attribute("value") or ""
        try:
            return _retry_stale(_get)
        except Exception:
            return ""

    def set_plain_input(self, xpath: str, text: str, press_enter: bool = False) -> None:
        def _get():
            return self.wait_clickable(By.XPATH, xpath)
        inp = _retry_stale(_get)

        def _focus_click():
            try:
                self.js_click(inp)
            except Exception:
                inp.click()
        _retry_stale(_focus_click)

        _retry_stale(lambda: inp.clear())
        _retry_stale(lambda: inp.send_keys(str(text or "")))
        if press_enter:
            _retry_stale(lambda: inp.send_keys(Keys.ENTER))
        try:
            self.driver.execute_script(
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true})); arguments[0].blur && arguments[0].blur();",
                inp
            )
        except Exception:
            pass
        # tiny settle helps UI5 bindings stabilize before subsequent reads
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 3))


# pages\CurrencyExchangeRates\elements\Fields\selectors.py

EXCH_TYPE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateTypeForEdit::Field-input-inner')+1)="
    "'ExchangeRateTypeForEdit::Field-input-inner']"
)
FROM_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('SourceCurrencyForEdit::Field-input-inner')+1)="
    "'SourceCurrencyForEdit::Field-input-inner']"
)
TO_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('TargetCurrencyForEdit::Field-input-inner')+1)="
    "'TargetCurrencyForEdit::Field-input-inner']"
)
VALID_FROM_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')+1)="
    "'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner']"
)


# pages\CurrencyExchangeRates\elements\Fields\__init__.py



# pages\CurrencyExchangeRates\elements\Footer\element.py

# elements/Footer/element.py
import time
from typing import Callable, Dict

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException, StaleElementReferenceException

from core.base import Element, fluent_wait
from services.ui import wait_ui5_idle
from ..Dialog.element import DialogWatcher
from ..Toast.element import ToastReader
from ..Messages.element import Ui5Messages
from ..Status.element import StatusProbe
from .selectors import (
    ACTIVATE_CREATE_BTN_XPATH,
    FORM_CREATE_OR_SAVE_BTN_XPATH,
    ACTIVATE_CREATE_BTN_CSS,
    HEADER_TITLE_ID_SUFFIX,
    EDIT_BTN_ID_SUFFIX,
    DISCARD_BTN_ID_SUFFIX,
    COPY_BTN_ID_CONTAINS,
    MESSAGE_BTN_SUFFIX,
    MSG_POPOVER_CLOSE_BTN_XP,
    MSG_ITEMS_XP, 
)

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class FooterActions(Element):
    """
    Submit logic with:
      - first attempt click
      - loop clicking with DOM/MessageManager checks
      - uses StatusProbe for robust success detection
    """

    EXTRA_SETTLE_SEC = 0.2  # trimmed
    def open_and_read_messages(self, timeout: int = 8) -> list[str]:
        """
        Clicks the footer 'Messages' button to open the Message Popover (if badge > 0),
        returns a list of visible message titles (strings). Leaves the popover open.
        """
        # Find the footer messages button
        try:
            msg_btn_id = self._query_visible_by_suffix(MESSAGE_BTN_SUFFIX)
        except Exception:
            msg_btn_id = None

        if not msg_btn_id:
            return []

        # Read the badge text quickly (optional; if not found, still click)
        badge_text = ""
        try:
            badge_bdi = self.driver.find_element(By.ID, f"{msg_btn_id}-BDI-content")
            badge_text = (badge_bdi.text or "").strip()
        except Exception:
            pass

        # If nothing to show (badge empty/0), bail early
        if badge_text and badge_text.isdigit() and int(badge_text) == 0:
            return []

        # Open the popover (toggle)
        try:
            btn = WebDriverWait(self.driver, 3, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.ID, msg_btn_id))
            )
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                btn.click()
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", btn)
                except Exception:
                    pass
        except Exception:
            return []

        # Wait for message items to render
        try:
            WebDriverWait(self.driver, timeout, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.presence_of_element_located((By.XPATH, MSG_ITEMS_XP))
            )
        except TimeoutException:
            return []

        # Collect item titles
        texts = []
        try:
            items = self.driver.find_elements(By.XPATH, MSG_ITEMS_XP)
            for it in items:
                try:
                    txt = (it.text or "").strip()
                    if txt:
                        texts.append(txt)
                except Exception:
                    continue
        except Exception:
            pass
        return texts


    # ---------- finding & UI5 press helpers ----------
    def _query_visible_by_suffix(self, suffix: str) -> str | None:
        try:
            return self.driver.execute_script(
                """
                var suffix = arguments[0];
                var nodes = document.querySelectorAll("[id$='"+suffix.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                return null;
                """,
                suffix,
            )
        except Exception:
            return None

    def _header_aria_label(self) -> str:
        try:
            return self.driver.execute_script(
                """
                var suf = arguments[0];
                var nodes = document.querySelectorAll("[id$='"+suf.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ var el=nodes[i]; if(!vis(el)) continue;
                  var a=(el.getAttribute('aria-label')||'').trim(); if(a) return a; }
                return '';
                """,
                HEADER_TITLE_ID_SUFFIX,
            ) or ""
        except Exception:
            return ""

    def _query_activate_id(self) -> str | None:
        try:
            return self.driver.execute_script(
                """
                var sel = arguments[0], nodes = document.querySelectorAll(sel);
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                return null;
                """,
                ACTIVATE_CREATE_BTN_CSS,
            )
        except Exception:
            return None

    def _really_clickable(self, dom_id: str) -> bool:
        try:
            return bool(self.driver.execute_script(
                """
                try {
                  var el=document.getElementById(arguments[0]); if(!el) return false;
                  var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  if(el.disabled) return false;
                  if((' '+el.className+' ').indexOf(' sapMBtnDisabled ')>=0) return false;
                  var r=el.getBoundingClientRect();
                  if (r.width<=0 || r.height<=0) return false;
                  var cx=r.left+r.width/2, cy=r.top+r.height/2;
                  var at=document.elementFromPoint(Math.max(0,cx),Math.max(0,cy));
                  return !!(at && (at===el || el.contains(at)));
                }catch(e){ return false; }
                """,
                dom_id
            ))
        except Exception:
            return False

    def _ui5_press_by_id(self, dom_id: str) -> str:
        try:
            res = self.driver.execute_script(
                """
                try {
                  var id = arguments[0];
                  var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(id) : null;
                  if (ctrl && ctrl.firePress) { ctrl.firePress(); return 'ui5-firePress'; }
                  if (ctrl && ctrl.press)     { ctrl.press();     return 'ui5-press'; }
                  var el = document.getElementById(id);
                  if (el) { el.click(); return 'dom-click-fallback'; }
                  return 'ui5-miss';
                } catch(e){ return 'ui5-exc:'+String(e); }
                """,
                dom_id,
            )
            return str(res)
        except Exception as e:
            return f"ui5-exc:{type(e).__name__}"

    def _press_activate_best_effort(self) -> bool:
        act_id = self._query_activate_id()
        if act_id:
            try:
                def _get_el():
                    return self.driver.find_element(By.ID, act_id)
                el = _retry_stale(_get_el)

                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                except Exception:
                    pass

                if self._really_clickable(act_id):
                    try:
                        _retry_stale(lambda: el.click())
                        wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                        time.sleep(self.EXTRA_SETTLE_SEC)
                        return True
                    except Exception:
                        pass

                try:
                    self.driver.execute_script("arguments[0].click();", el)
                    wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                    time.sleep(self.EXTRA_SETTLE_SEC)
                    return True
                except Exception:
                    pass

                _ = self._ui5_press_by_id(act_id)
                wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)
                return True
            except Exception:
                pass

        # Fallback: generic Create/Save by text
        try:
            btn = fluent_wait(self.driver, 1.5, poll=0.15).until(
                EC.element_to_be_clickable((By.XPATH, FORM_CREATE_OR_SAVE_BTN_XPATH))
            )
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                _retry_stale(lambda: btn.click())
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", btn)
                except Exception:
                    pass
            wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)
            return True
        except Exception:
            pass

        # Final fallback: Ctrl+S
        try:
            ActionChains(self.driver).key_down(Keys.CONTROL).send_keys("s").key_up(Keys.CONTROL).perform()
            wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)
            return True
        except Exception:
            return False

    # Kept for backward compatibility as a last-resort fallback
    def _activated_dom(self) -> bool:
        try:
            has_edit    = bool(self._query_visible_by_suffix(EDIT_BTN_ID_SUFFIX))
            has_discard = bool(self._query_visible_by_suffix(DISCARD_BTN_ID_SUFFIX))
            aria        = (self._header_aria_label() or "")
            if has_edit and not has_discard:
                return True
            if aria and ("Header area" in aria) and ("New" not in aria):
                return True
            return False
        except Exception:
            return False

    def click_create(self, clicks: int = 1) -> dict:
        info = {"clicks": 0, "dialogs": [], "toasts": []}
        dlg = DialogWatcher(self.driver)
        reader = ToastReader(self.driver)

        for _ in range(max(1, clicks)):
            if dlg.is_open():
                info["dialogs"].append(dlg.text() or "")
                break

            pressed = self._press_activate_best_effort()
            if not pressed:
                continue

            info["clicks"] += 1
            wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)

            try:
                t = reader.read_last()
                if t:
                    info["toasts"].append(t)
            except Exception:
                pass

            if dlg.is_open():
                info["dialogs"].append(dlg.text() or "")
                break

        return info

    def close_message_popover_if_open(self, timeout: int = 3) -> bool:
        """
        Closes the Message Popover if it is open. Returns True if we believe it closed.
        """
        # Prefer the close button in the popover header
        try:
            close_btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, MSG_POPOVER_CLOSE_BTN_XP))
            )
            try:
                close_btn.click()
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", close_btn)
                except Exception:
                    pass
            # Wait until close button disappears
            WebDriverWait(self.driver, timeout, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                EC.presence_of_element_located((By.XPATH, MSG_POPOVER_CLOSE_BTN_XP))
            )
            return True
        except Exception:
            # Fallback: toggle the Messages button to close
            try:
                msg_btn_id = self._query_visible_by_suffix(MESSAGE_BTN_SUFFIX)
                if msg_btn_id:
                    btn = self.driver.find_element(By.ID, msg_btn_id)
                    try:
                        btn.click()
                    except Exception:
                        self.driver.execute_script("arguments[0].click();", btn)
                    return True
            except Exception:
                pass
            return False

    def discard_draft(self, timeout: int = 10) -> bool:
        """
        Clicks footer 'Discard Draft', then confirms 'Discard' in the confirmation popover.
        Returns True if confirmation popover disappears.
        """
        import time

        # 1) Click footer 'Discard Draft'
        disc_id = None
        try:
            disc_id = self._query_visible_by_suffix("--discard")
        except Exception:
            pass

        if disc_id:
            try:
                el = WebDriverWait(self.driver, 2, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.ID, disc_id))
                )
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                except Exception:
                    pass
                try:
                    el.click()
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", el)
                    except Exception:
                        pass
            except Exception:
                pass
            # UI5 press fallback
            _ = self._ui5_press_by_id(disc_id)

        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
        time.sleep(self.EXTRA_SETTLE_SEC)

        # 2) Confirm 'Discard' in popover
        CONFIRM_SUFFIX = "--DiscardDraftConfirmButton"

        def _click_confirm() -> bool:
            # by ID suffix
            try:
                cid = self._query_visible_by_suffix(CONFIRM_SUFFIX)
            except Exception:
                cid = None

            if cid:
                try:
                    btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                        EC.element_to_be_clickable((By.ID, cid))
                    )
                    try:
                        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                    except Exception:
                        pass
                    try:
                        btn.click()
                    except Exception:
                        try:
                            self.driver.execute_script("arguments[0].click();", btn)
                        except Exception:
                            pass
                    return True
                except Exception:
                    pass

            # by visible text
            try:
                xp = ("//bdi[normalize-space()='Discard']/ancestor::button[1]"
                    " | //button[.//bdi[normalize-space()='Discard']]")
                btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.element_to_be_clickable((By.XPATH, xp))
                )
                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
                except Exception:
                    pass
                try:
                    btn.click()
                except Exception:
                    try:
                        self.driver.execute_script("arguments[0].click();", btn)
                    except Exception:
                        pass
                return True
            except Exception:
                return False

        clicked = _click_confirm()
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
        time.sleep(self.EXTRA_SETTLE_SEC)

        # If confirm button no longer visible, assume success
        try:
            still = self._query_visible_by_suffix(CONFIRM_SUFFIX)
        except Exception:
            still = None
        return bool(clicked and not still)

    def ensure_created_by_loop_clicking(
        self,
        object_header_ready: Callable[[], bool],
        at_list: Callable[[], bool],
        close_side: Callable[[], bool],
        max_clicks: int = 5,       # was 10
        total_timeout: int = 35,   # default; caller may override
    ) -> Dict:
        dlg   = DialogWatcher(self.driver)
        reader= ToastReader(self.driver)
        msgs  = Ui5Messages(self.driver)
        probe = StatusProbe(self.driver)

        end = time.time() + max(total_timeout, self._timeout)
        clicks = 0
        toasts = []
        msgs.clear()

        while clicks < max(max_clicks,1) and time.time() < end:
            if dlg.is_open():
                return {
                    "status": "dialog_open",
                    "dialog_open": True,
                    "dialog_text": dlg.text(),
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.read_all(),
                    "popover_text": msgs.popover_text(),
                }

            if msgs.has_errors():
                return {
                    "status": "activation_error",
                    "dialog_open": False,
                    "dialog_text": "",
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.errors(),
                    "popover_text": msgs.popover_text(),
                }

            if (
                probe.success()
                or probe.is_persisted_object_page()
                or object_header_ready()
                or at_list()
                or self._activated_dom()
            ):
                close_side()
                return {
                    "status": "created",
                    "dialog_open": False,
                    "dialog_text": "",
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.read_all(),
                    "popover_text": msgs.popover_text(),
                }

            if self._press_activate_best_effort():
                clicks += 1
                wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)

            try:
                t = reader.read_last()
                if t:
                    toasts.append(t)
                    lt = (t or "").lower()
                    if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                        if not (probe.success() or probe.is_persisted_object_page()):
                            wait_ui5_idle(self.driver, timeout=min(2, self._timeout))
                        close_side()
                        return {
                            "status": "created",
                            "dialog_open": False,
                            "dialog_text": "",
                            "footer_clicks": clicks,
                            "intermediate_toasts": toasts,
                            "messages": msgs.read_all(),
                            "popover_text": msgs.popover_text(),
                        }
            except Exception:
                pass

            time.sleep(0.2)

        if not at_list():
            close_side()

        created = (
            probe.success()
            or probe.is_persisted_object_page()
            or at_list()
            or object_header_ready()
            or self._activated_dom()
        )
        return {
            "status": "created" if created else "unknown",
            "footer_clicks": clicks,
            "intermediate_toasts": toasts,
            "dialog_open": False if not dlg.is_open() else True,
            "dialog_text": dlg.text() if dlg.is_open() else "",
            "messages": msgs.read_all(),
            "popover_text": msgs.popover_text(),
        }


# pages\CurrencyExchangeRates\elements\Footer\selectors.py

# Prefer the specific Activate/Create button on the Object Page footer
ACTIVATE_CREATE_BTN_XPATH = (
    "//*[self::button or self::a]"
    "[substring(@id,string-length(@id)-string-length('--activate')+1)='--activate']"
)

# Backup: Create/Save button by text (kept for safety)
FORM_CREATE_OR_SAVE_BTN_XPATH = (
    "("
    "//bdi[normalize-space()='Create']/ancestor::button[1] | "
    "//bdi[normalize-space()='Save']/ancestor::button[1]"
    ")[1]"
)

# CSS variants (used by JS helpers)
ACTIVATE_CREATE_BTN_CSS = "button[id$='--activate'],a[id$='--activate']"

# DOM success signals (from your snippet)
HEADER_TITLE_ID_SUFFIX = "--objectPage-headerTitle"   # aria-label like "* Header area"
EDIT_BTN_ID_SUFFIX     = "--edit"
DELETE_BTN_ID_SUFFIX   = "--delete"
DISCARD_BTN_ID_SUFFIX  = "--discard"
COPY_BTN_ID_CONTAINS   = "::Copy"

MESSAGE_BTN_SUFFIX = "--showMessages"
MSG_POPOVER_CLOSE_BTN_XP = "//button[contains(@class,'sapMMsgPopoverCloseBtn')]"
MSG_ITEMS_XP = "//li[contains(@class,'sapMMsgViewItem')]//span[contains(@id,'-titleText')]"


# pages\CurrencyExchangeRates\elements\Footer\__init__.py



# pages\CurrencyExchangeRates\elements\Header\element.py

import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from core.base import Element
from .selectors import OBJECT_HEADER_CONTENT_XPATH, OBJECT_HEADER_RATE_VALUE_XPATH

class ObjectHeaderVerifier(Element):
    def wait_ready(self, timeout: int) -> bool:
        t0 = time.time()
        try:
            WebDriverWait(self.driver, min(6, timeout), ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
            )
        except TimeoutException:
            return False
        while time.time() - t0 < min(timeout, 10):
            try:
                span = self.driver.find_element(By.XPATH, OBJECT_HEADER_RATE_VALUE_XPATH)
                txt = ""
                try:
                    txt = (span.text or "").strip()
                except StaleElementReferenceException:
                    continue
                if txt:
                    return True
            except Exception:
                pass
            time.sleep(0.15)
        return False


# pages\CurrencyExchangeRates\elements\Header\selectors.py

OBJECT_HEADER_CONTENT_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
    "'--objectPage-OPHeaderContent']"
)
OBJECT_HEADER_RATE_VALUE_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--exchangeRate-text')+1)="
    "'--exchangeRate-text']"
)


# pages\CurrencyExchangeRates\elements\Header\__init__.py



# pages\CurrencyExchangeRates\elements\ListToolbar\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from core.base import Element, fluent_wait
from services.ui import wait_ui5_idle
from .selectors import CREATE_BUTTON_XPATH

class ListToolbar(Element):
    def wait_create_clickable(self, timeout: int):
        return fluent_wait(self.driver, timeout, poll=0.2).until(
            EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
        )

    def click_create(self, timeout: int):
        btn = self.wait_create_clickable(timeout)
        try:
            btn.click()
        except Exception:
            self.js_click(btn)
        wait_ui5_idle(self.driver, timeout=timeout)

    def is_at_list(self, quick: float = 0.8) -> bool:
        try:
            fluent_wait(self.driver, quick, poll=0.2).until(
                EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
            )
            return True
        except Exception:
            return False


# pages\CurrencyExchangeRates\elements\ListToolbar\selectors.py

# Create button in the list report toolbar
CREATE_BUTTON_XPATH = "//bdi[normalize-space()='Create']/ancestor::button[1]"


# pages\CurrencyExchangeRates\elements\ListToolbar\__init__.py



# pages\CurrencyExchangeRates\elements\Messages\element.py

from core.base import Element

class Ui5Messages(Element):
    """
    Reads UI5 MessageManager; surfaces backend errors (why activation fails).
    Also knows how to read the Message Popover DOM (title/subtitle/description)
    which is what your HTML snippet shows.
    """

    def _get_data(self):
        try:
            return self.driver.execute_script(
                """
                try{
                  var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                  if(!core) return {ok:false, data:[]};
                  var mm = core.getMessageManager && core.getMessageManager();
                  if(!mm) return {ok:false, data:[]};
                  var model = mm.getMessageModel && mm.getMessageModel();
                  if(!model) return {ok:false, data:[]};
                  var data = (model.getData && model.getData()) || model.oData || [];
                  var out = [];
                  for (var i=0;i<data.length;i++){
                    var m=data[i]||{};
                    out.push({
                      type: String(m.type||''),
                      message: String(m.message||m.text||'').trim(),
                      description: String(m.description||'').trim(),
                      code: String(m.code||'').trim(),
                      target: String(m.target||'').trim(),
                      technical: !!m.technical
                    });
                  }
                  return {ok:true, data:out};
                }catch(e){ return {ok:false, data:[], err:String(e)}; }
                """
            ) or {"ok": False, "data": []}
        except Exception:
            return {"ok": False, "data": []}

    def read_all(self):
        res = self._get_data()
        return res.get("data", []) if isinstance(res, dict) else []

    def errors(self):
        return [m for m in self.read_all() if (m.get("type") or "").lower() in ("error","fatal","critical")]

    def has_errors(self) -> bool:
        return len(self.errors()) > 0

    def clear(self) -> bool:
        try:
            return bool(self.driver.execute_script(
                """
                try{
                  var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                  var mm = core && core.getMessageManager && core.getMessageManager();
                  if(!mm) return false;
                  if(mm.removeAllMessages) { mm.removeAllMessages(); return true; }
                  return false;
                }catch(e){ return false; }
                """
            ))
        except Exception:
            return False

    # ---------- NEW: Message Popover DOM reader ----------

    def popover_text(self) -> str:
        try:
            txt = self.driver.execute_script(
                """
                try{
                  function visible(el){
                    if(!el) return false;
                    var cs = getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r = el.getBoundingClientRect();
                    return r.width>0 && r.height>0;
                  }

                  var wrap = document.querySelector('.sapMPopoverWrapper');
                  if(!wrap || !visible(wrap)) return '';

                  var errIcon = wrap.querySelector('.sapMMsgViewDescIconError');
                  var errStrip = document.querySelector('.sapMMsgStrip.sapMMsgStripError');
                  var isErr = !!(errIcon || errStrip);

                  var titleEl = wrap.querySelector('.sapMMsgView .sapMMsgViewTitleText .sapMLnkText');
                  var subEl   = wrap.querySelector('.sapMMsgView .sapMMsgViewSubtitleText');
                  var descEl  = wrap.querySelector('.sapMMsgView .sapMMsgViewDescriptionText');

                  var title = titleEl ? (titleEl.innerText||titleEl.textContent||'').trim() : '';
                  var sub   = subEl   ? (subEl.innerText||subEl.textContent||'').trim() : '';
                  var desc  = descEl  ? (descEl.innerText||descEl.textContent||'').trim() : '';

                  if(!isErr && !title && !desc) return '';
                  var parts = [];
                  if(title) parts.push(title);
                  if(sub)   parts.push(sub);
                  if(desc)  parts.push(desc);
                  return parts.join(' | ');
                }catch(e){ return ''; }
            """
            )
            return (txt or "").strip()
        except Exception:
            return ""


# pages\CurrencyExchangeRates\elements\Quotation\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import QUOTATION_INNER_INPUT_XPATH, QUOTATION_ARROW_BTN_XPATH, QUOTATION_OPTION_BY_TEXT_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class QuotationField(Element):
    def _hard_clear(self, inp):
        for fn in (
            lambda: inp.clear(),
            lambda: inp.send_keys(Keys.CONTROL, "a"),
            lambda: inp.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
        ):
            try: _retry_stale(fn)
            except Exception: pass

    def set_value(self, value: str):
        wait = WebDriverWait(self.driver, max(self._timeout, 20), ignored_exceptions=(StaleElementReferenceException,))
        inp = wait.until(EC.visibility_of_element_located((By.XPATH, QUOTATION_INNER_INPUT_XPATH)))

        try: _retry_stale(lambda: inp.click())
        except Exception: self.js_click(inp)

        self._hard_clear(inp)

        _retry_stale(lambda: inp.send_keys(value))
        _retry_stale(lambda: inp.send_keys(Keys.ENTER))
        _retry_stale(lambda: inp.send_keys(Keys.TAB))
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

        def _cur():
            return (inp.get_attribute("value") or "").strip()
        try:
            cur = _retry_stale(_cur)
        except Exception:
            cur = ""
        if cur.lower() != value.strip().lower():
            try:
                arrow = wait.until(EC.element_to_be_clickable((By.XPATH, QUOTATION_ARROW_BTN_XPATH)))
                try: _retry_stale(lambda: arrow.click())
                except Exception: self.js_click(arrow)
            except Exception:
                try: _retry_stale(lambda: inp.send_keys(Keys.ALT, Keys.DOWN))
                except Exception: pass
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            opt_xpath = QUOTATION_OPTION_BY_TEXT_XPATH.format(TEXT=value.strip())
            option = wait.until(EC.element_to_be_clickable((By.XPATH, opt_xpath)))
            try: _retry_stale(lambda: option.click())
            except Exception: self.js_click(option)
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))


# pages\CurrencyExchangeRates\elements\Quotation\selectors.py

QUOTATION_INNER_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-inner')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-inner']"
)
QUOTATION_ARROW_BTN_XPATH = (
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']/ancestor::button[1] | "
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']"
)
QUOTATION_OPTION_BY_TEXT_XPATH = (
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//bdi[normalize-space()='{TEXT}']/ancestor::li[1] | "
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//span[normalize-space()='{TEXT}']/ancestor::li[1]"
)


# pages\CurrencyExchangeRates\elements\Quotation\__init__.py



# pages\CurrencyExchangeRates\elements\Rate\element.py

from decimal import Decimal, ROUND_HALF_UP
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import EXCH_RATE_INPUT_XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class ExchangeRateField(Element):
    def _ui_lang_tag(self) -> str:
        try:
            return self.driver.execute_script(
                """
                try{
                  var c=sap && sap.ui && sap.ui.getCore && sap.ui.getCore().getConfiguration && sap.ui.getCore().getConfiguration();
                  if(!c) return (navigator.language || 'en-US');
                  if (c.getLanguageTag) return c.getLanguageTag();
                  if (c.getLanguage)    return c.getLanguage();
                  return (navigator.language || 'en-US');
                }catch(e){ return (navigator.language || 'en-US'); }
                """
            ) or "en-US"
        except Exception:
            return "en-US"

    def _format_rate_locale(self, num: Decimal) -> str:
        q = num.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
        lang = self._ui_lang_tag()
        try:
            from babel.numbers import format_decimal
            return format_decimal(q, format="0.00000", locale=(lang or "en-US").replace("-", "_"))
        except Exception:
            try:
                return self.driver.execute_script(
                    """
                    try{
                      var val = Number(arguments[0]);
                      var lang = arguments[1] || (navigator.language || 'en-US');
                      if (!isFinite(val)) return '';
                      return new Intl.NumberFormat(lang,
                               {minimumFractionDigits:5, maximumFractionDigits:5, useGrouping:false}
                              ).format(val);
                    }catch(e){ return String(arguments[0]); }
                    """,
                    float(q), lang
                )
            except Exception:
                return f"{q:.5f}"

    def _find_input(self):
        try:
            return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_XPATH)
            )
        except Exception:
            pass
        try:
            return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH)
            )
        except Exception:
            raise RuntimeError("Exchange Rate input not found (primary nor fallback).")

    def _hard_clear(self, el):
        for js in (
            lambda: el.clear(),
            lambda: el.send_keys(Keys.CONTROL, "a"),
            lambda: el.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", el),
        ):
            try: _retry_stale(js)
            except Exception: pass

    def commit(self, times: int = 1):
        inp = self._find_input()
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", inp)
        except Exception:
            pass
        try:
            _retry_stale(lambda: inp.click())
        except Exception:
            self.js_click(inp)

        try:
            ac = ActionChains(self.driver)
            for _ in range(max(1, times)):
                ac.send_keys(Keys.ENTER).pause(0.03)
            ac.send_keys(Keys.TAB)
            ac.perform()
        except Exception:
            try:
                _retry_stale(lambda: inp.send_keys(Keys.ENTER))
                _retry_stale(lambda: inp.send_keys(Keys.TAB))
            except Exception: pass

        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

    def set_via_typing(self, rate_val: str | float | Decimal):
        num = Decimal(str(rate_val))
        if num <= 0:
            raise ValueError("rate_val must be > 0")
        s = self._format_rate_locale(num)
        inp = self._find_input()
        self._hard_clear(inp)
        _retry_stale(lambda: inp.send_keys(s))
        try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
        except Exception: pass
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

    def set_via_ui5(self, rate_val: str | float | Decimal):
        inp = self._find_input()
        inner_id = inp.get_attribute("id")
        if not inner_id:
            raise RuntimeError("Exchange Rate input has no DOM id")

        res = self.driver.execute_script(
            """
            try{
              var innerId=arguments[0], num=Number(String(arguments[1]).replace(',','.'));
              if(!isFinite(num) || num<=0){ return {ok:false, reason:'nonpositive'}; }
              var ctrlId = innerId.endsWith('-inner') ? innerId.slice(0,-6) : innerId;
              var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(ctrlId) : null;
              var fmt = (sap && sap.ui && sap.ui.core && sap.ui.core.format && sap.ui.core.format.NumberFormat)
                        ? sap.ui.core.format.NumberFormat.getFloatInstance({maxFractionDigits:5,minFractionDigits:5,groupingEnabled:false})
                        : null;
              var s = fmt ? fmt.format(num) : num.toFixed(5);

              if(ctrl && ctrl.setValue){
                  ctrl.setValue(s);
                  if (ctrl.fireLiveChange) ctrl.fireLiveChange({ value: s });
                  if (ctrl.fireChange)     ctrl.fireChange({ value: s });
              }
              var el = document.getElementById(innerId);
              if(el){
                  el.focus();
                  el.value = s;
                  el.dispatchEvent(new Event('input',{bubbles:true}));
                  el.dispatchEvent(new Event('change',{bubbles:true}));
              }
              var parsed = fmt ? fmt.parse(s) : Number(s.replace(',','.'));
              return {ok:(typeof parsed==='number' && parsed>0), shown:s, parsed:parsed};
            }catch(e){ return {ok:false, reason:String(e)}; }
            """,
            inner_id, str(rate_val)
        )
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
        if not res or not res.get("ok"):
            raise RuntimeError(f"Could not set Exchange Rate via UI5. Result={res}.")


# pages\CurrencyExchangeRates\elements\Rate\selectors.py

EXCH_RATE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('AbsoluteExchangeRate::Field-input-inner')+1)="
    "'AbsoluteExchangeRate::Field-input-inner']"
)

EXCH_RATE_INPUT_FALLBACK_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='Exchange Rate']]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//span[normalize-space()='Exchange Rate']/ancestor::label[1]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//*[self::label or self::span][contains(normalize-space(.), 'Exchange Rate')]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)


# pages\CurrencyExchangeRates\elements\Rate\__init__.py



# pages\CurrencyExchangeRates\elements\SideColumn\element.py

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from ..ListToolbar.element import ListToolbar
from .selectors import CLOSE_COLUMN_BTN_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class SideColumnController(Element):
    def close_if_present(self, timeout: int | None = None) -> bool:
        t = timeout or max(self._timeout, 20)
        listbar = ListToolbar(self.driver)

        if listbar.is_at_list(quick=0.8):
            return True

        try:
            btn = WebDriverWait(self.driver, min(5, t), ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, CLOSE_COLUMN_BTN_XPATH))
            )
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                _retry_stale(lambda: btn.click())
            except Exception:
                self.js_click(btn)
            wait_ui5_idle(self.driver, timeout=min(6, t))
        except TimeoutException:
            try:
                did = self.driver.execute_script(
                    """
                    try{
                      var q = document.querySelectorAll(
                        "button[id$='--closeColumn'],button[id$='--closeColumnBtn'],button[id*='closeColumn']"
                      );
                      for (var i=q.length-1;i>=0;i--){
                        var b=q[i];
                        var cs=window.getComputedStyle(b);
                        if(b && b.offsetParent && cs.visibility!=='hidden' && cs.display!=='none'){ b.click(); return 'clicked-dom'; }
                      }
                      return 'none';
                    }catch(e){ return 'err:'+e; }
                    """
                )
            except Exception:
                did = "err"
            wait_ui5_idle(self.driver, timeout=2)

            if did != "clicked-dom":
                try:
                    _ = self.driver.execute_script(
                        """
                        try{
                          var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                          if(!core) return 'no-core';
                          var all = core && core.mElements ? Object.values(core.mElements) : [];
                          var fcl=null, name='';
                          for (var i=0;i<all.length;i++){
                            var c=all[i];
                            try{
                              name=c.getMetadata && c.getMetadata().getName && c.getMetadata().getName();
                              if(name==='sap.f.FlexibleColumnLayout'){ fcl=c; break; }
                            }catch(e){}
                          }
                          if(fcl && fcl.setLayout){
                            var LT = sap.f && sap.f.LayoutType;
                            var one = (LT && LT.OneColumn) || 'OneColumn';
                            fcl.setLayout(one);
                            return 'set-one-column';
                          }
                          return 'no-fcl';
                        }catch(e){ return 'err:'+e; }
                        """
                    )
                except Exception:
                    _ = "err"
                wait_ui5_idle(self.driver, timeout=2)

        if listbar.is_at_list(quick=1.0):
            return True
        return True


# pages\CurrencyExchangeRates\elements\SideColumn\selectors.py

CLOSE_COLUMN_BTN_XPATH = (
    "("
    "  //button[substring(@id,string-length(@id)-string-length('--closeColumn')+1)='--closeColumn']"
    "  | //button[substring(@id,string-length(@id)-string-length('--closeColumnBtn')+1)='--closeColumnBtn']"
    "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-inner')+1)='--closeColumn-inner']/ancestor::button[1]"
    "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-img')+1)='--closeColumn-img']/ancestor::button[1]"
    "  | //button[@title='Close' or @aria-label='Close' or @aria-label='Close Column']"
    ")[1]"
)


# pages\CurrencyExchangeRates\elements\SideColumn\__init__.py



# pages\CurrencyExchangeRates\elements\Status\element.py

# elements/Status/element.py
import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By

from core.base import Element
from .selectors import (
    HEADER_EDIT_BTN_XPATH, HEADER_DELETE_BTN_XPATH, HEADER_COPY_BTN_XPATH,
    FOOTER_DISCARD_DRAFT_BTN_XPATH,
    CHANGE_LOG_SECTION_ANCHOR_XPATH, TREND_SECTION_ANCHOR_XPATH,
    OBJECT_HEADER_CONTENT_XPATH,
)

class StatusProbe(Element):
    def _exists(self, xp: str, t: float = 0.7) -> bool:
        try:
            WebDriverWait(self.driver, t).until(EC.presence_of_element_located((By.XPATH, xp)))
            return True
        except Exception:
            return False

    def is_active_entity(self):
        try:
            res = self.driver.execute_script(
                """
                try{
                  var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                  if(!core) return {ok:false, why:'no-core'};
                  var els = core && core.mElements ? Object.values(core.mElements) : [];
                  for (var i=0;i<els.length;i++){
                    var c=els[i];
                    try{
                      var n=c.getMetadata&&c.getMetadata().getName&&c.getMetadata().getName();
                      if(n==='sap.uxap.ObjectPageLayout'){
                        var bc=c.getBindingContext&&c.getBindingContext();
                        if(bc){
                          var o=bc.getObject&&bc.getObject();
                          if(o && ('IsActiveEntity' in o)) return {ok:true, active: !!o.IsActiveEntity};
                          var p=bc.getProperty&&bc.getProperty('IsActiveEntity');
                          if(typeof p!=='undefined') return {ok:true, active: !!p};
                        }
                      }
                    }catch(e){}
                  }
                  for (var j=0;j<els.length;j++){
                    var c2=els[j];
                    try{
                      var bc2=c2.getBindingContext&&c2.getBindingContext();
                      if(bc2){
                        var p2=bc2.getProperty&&bc2.getProperty('IsActiveEntity');
                        if(typeof p2!=='undefined') return {ok:true, active: !!p2};
                      }
                    }catch(e){}
                  }
                  return {ok:false, why:'no-binding'};
                }catch(e){ return {ok:false, why:String(e)}; }
                """
            )
            if isinstance(res, dict) and res.get("ok"):
                return bool(res.get("active"))
        except Exception:
            pass
        return None

    def buttons_state(self) -> dict:
        return {
            "has_edit":   self._exists(HEADER_EDIT_BTN_XPATH),
            "has_delete": self._exists(HEADER_DELETE_BTN_XPATH),
            "has_copy":   self._exists(HEADER_COPY_BTN_XPATH),
            "has_discard_draft": self._exists(FOOTER_DISCARD_DRAFT_BTN_XPATH),
        }

    def sections_present(self) -> dict:
        return {
            "has_log":   self._exists(CHANGE_LOG_SECTION_ANCHOR_XPATH),
            "has_trend": self._exists(TREND_SECTION_ANCHOR_XPATH),
        }

    def header_aria_label(self) -> str:
        try:
            el = WebDriverWait(self.driver, 0.7).until(
                EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
            )
            return (el.get_attribute("aria-label") or "").strip()
        except Exception:
            return ""

    def object_header_text(self) -> str:
        try:
            return self.driver.execute_script("""
                try{
                  var el = document.querySelector("[id*='ObjectPageDynamicHeaderTitle-inner']");
                  return (el && (el.innerText||el.textContent)||'').trim();
                }catch(e){return '';}
            """) or ""
        except Exception:
            return ""

    def is_create_mode(self) -> bool:
        try:
            return bool(self.driver.execute_script("""
                try{
                  function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect(); return r.width>0 && r.height>0;
                  }
                  var nodes=[...document.querySelectorAll('button,bdi')];
                  return nodes.some(n=>{
                    var t=(n.innerText||n.textContent||'').trim();
                    if(!/\bCreate\b/i.test(t)) return false;
                    var b=n.tagName==='BDI' ? n.closest('button') : n;
                    return vis(b);
                  });
                }catch(e){return false;}
            """))
        except Exception:
            return False

    def is_draft_url(self) -> bool:
        try:
            return bool(self.driver.execute_script("return location.href.includes('IsActiveEntity=false');"))
        except Exception:
            return False

    def is_persisted_object_page(self) -> bool:
        title = self.object_header_text()
        if not title:
            return False
        if self.is_create_mode():
            return False
        if not self.is_draft_url():
            return True
        btns = self.buttons_state()
        return (btns["has_edit"] and not btns["has_discard_draft"])

    def success(self) -> bool:
        active = self.is_active_entity()
        if active is True:
            return True

        btns = self.buttons_state()
        if btns["has_edit"] and not btns["has_discard_draft"]:# Discard Draft disappeared
            return True

        secs = self.sections_present()
        if secs["has_log"] or secs["has_trend"]:
            return True

        aria = self.header_aria_label()
        if aria and "Header area" in aria and "New" not in aria:
            return True

        if self.is_persisted_object_page():
            return True

        return False


# pages\CurrencyExchangeRates\elements\Status\selectors.py

# elements/Status/selectors.py

# Action buttons that flip after activation
HEADER_EDIT_BTN_XPATH = (
    "//bdi[normalize-space()='Edit']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--edit')+1)='--edit']"
)
HEADER_DELETE_BTN_XPATH = (
    "//bdi[normalize-space()='Delete']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--delete')+1)='--delete']"
)
HEADER_COPY_BTN_XPATH = (
    "//bdi[normalize-space()='Copy']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--copy')+1)='--copy']"
)
FOOTER_DISCARD_DRAFT_BTN_XPATH = (
    "//bdi[normalize-space()='Discard Draft']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--discard')+1)='--discard']"
)

# Sections that typically appear post-activation
CHANGE_LOG_SECTION_ANCHOR_XPATH = (
    "//a[contains(@id,'ExchangeRateLog') and contains(@id,'Section-anchor')] | "
    "//a[contains(normalize-space(.), 'Change Log') and contains(@id,'Section-anchor')]"
)
TREND_SECTION_ANCHOR_XPATH = (
    "//a[contains(@id,'CurrencyExchangeRateTrend') and contains(@id,'Section-anchor')] | "
    "//a[contains(normalize-space(.), 'Trend') and contains(@id,'Section-anchor')]"
)

# Object header root for reading aria-label
OBJECT_HEADER_CONTENT_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
    "'--objectPage-OPHeaderContent']"
)


# pages\CurrencyExchangeRates\elements\Toast\element.py

from core.base import Element
from .selectors import MESSAGE_TOAST_CSS

class ToastReader(Element):
    def read_last(self) -> str:
        try:
            txt = self.driver.execute_script(
                "var nodes=document.querySelectorAll(arguments[0]);"
                "if(!nodes||nodes.length===0) return '';"
                "var t=nodes[nodes.length-1];"
                "return (t.innerText||t.textContent||'').trim();",
                MESSAGE_TOAST_CSS,
            )
            return (txt or "").strip()
        except Exception:
            return ""


# pages\CurrencyExchangeRates\elements\Toast\selectors.py

MESSAGE_TOAST_CSS = ".sapMMessageToast"


# pages\CurrencyExchangeRates\elements\Toast\__init__.py



# pages\CurrencyExchangeRates\elements\Validation\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import ANY_INVALID_INPUT_XPATH, ANY_ERROR_WRAPPER_XPATH

class ValidationInspector(Element):
    def collect(self) -> str | None:
        try:
            bad_inputs = self.driver.find_elements(By.XPATH, ANY_INVALID_INPUT_XPATH)
            if bad_inputs:
                messages = []
                for el_ in bad_inputs:
                    try:
                        err_id = el_.get_attribute("aria-errormessage") or ""
                        msg = self.driver.execute_script(
                            "var id=arguments[0];"
                            "var n=id?document.getElementById(id):null;"
                            "return n? (n.innerText || n.textContent || '').trim():'';", err_id)
                        if msg: messages.append(msg)
                    except Exception:
                        continue
                if messages: return "; ".join(sorted(set(messages)))
                return f"{len(bad_inputs)} invalid field(s)."
            wrappers = self.driver.find_elements(By.XPATH, ANY_ERROR_WRAPPER_XPATH)
            if wrappers: return f"{len(wrappers)} field wrapper(s) in error state."
        except Exception:
            pass
        return None


# pages\CurrencyExchangeRates\elements\Validation\selectors.py

ANY_INVALID_INPUT_XPATH = "//*[(@aria-invalid='true') and (self::input or self::textarea)]"
ANY_ERROR_WRAPPER_XPATH = "//*[contains(@class,'sapMInputBaseContentWrapperError')]"


# pages\CurrencyExchangeRates\elements\Validation\__init__.py



# pages\Index\ProcurementOverviewTile\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import GRID_READY_XPATH, BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH

class ProcurementOverviewTile(Element):
    def _find_tile_quick(self, timeout_s: float):
        wait = WebDriverWait(self.driver, timeout_s)
        # Ensure tiles grid exists
        wait.until(EC.presence_of_element_located((By.XPATH, GRID_READY_XPATH)))

        # Try a few reliable selectors with short caps
        for xp in (BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH):
            try:
                return WebDriverWait(self.driver, timeout_s).until(
                    EC.presence_of_element_located((By.XPATH, xp))
                )
            except Exception:
                continue
        return None

    def click(self):
        # Keep things brisk
        short = min(self._timeout, 6)
        wait_ui5_idle(self.driver, timeout=short)

        el = self._find_tile_quick(timeout_s=short)
        if el:
            href = (el.get_attribute("href") or "").strip()
            # Try normal click → JS click
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                WebDriverWait(self.driver, short).until(EC.element_to_be_clickable((By.XPATH, BY_TITLE_TEXT_XPATH)))
                el.click()
                wait_ui5_idle(self.driver, timeout=short)
                return
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", el)
                    wait_ui5_idle(self.driver, timeout=short)
                    return
                except Exception:
                    if href:
                        self.driver.execute_script("window.location.href = arguments[0];", href)
                        wait_ui5_idle(self.driver, timeout=self._timeout)
                        return
                    raise RuntimeError("Found tile but could not activate it.")
        else:
            # Hard fallback: navigate directly by hash (fastest)
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Procurement-displayOverviewPage';"
            )
            wait_ui5_idle(self.driver, timeout=self._timeout)


# pages\Index\ProcurementOverviewTile\selectors.py

# pages/Index/elements/ProcurementOverviewTile/selectors.py

# Grid container (ensures tiles were rendered)
GRID_READY_XPATH = ("//div[starts-with(@id,'__section') and "
                    "contains(@id,'-defaultArea-listUl') and @role='list']")

# Primary: match by the hash target in the href (most stable between tenants)
BY_HREF_XPATH = ("//a[contains(@class,'sapMGT') and "
                 "contains(@href, '#Procurement-displayOverviewPage')]")

# Secondary: visible title text (from your HTML)
BY_TITLE_TEXT_XPATH = ("//a[contains(@class,'sapMGT')]"
                       "[.//span[normalize-space()='Procurement Overview']]")

# Tertiary: aria-label starts with title
BY_ARIA_LABEL_XPATH = ("//a[contains(@class,'sapMGT') and "
                       "starts-with(normalize-space(@aria-label),'Procurement Overview')]")


# pages\Index\ProcurementOverviewTile\__init__.py



# pages\Index\PurchasingTab\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import PURCHASING_TAB_XPATH

class PurchasingTab(Element):
    def click(self):
        wait_ui5_idle(self.driver, timeout=self._timeout)
        el = self.wait_clickable(By.XPATH, PURCHASING_TAB_XPATH)
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
            el.click()
        except Exception:
            self.js_click(el)


# pages\Index\PurchasingTab\selectors.py

# pages/Index/elements/PurchasingTab/selectors.py
PURCHASING_TAB_XPATH = (
    "//div[contains(@class,'sapMITBFilterWrapper')]"
    "[.//span[normalize-space()='Purchasing']]"
)


# pages\Index\PurchasingTab\__init__.py



# pages\Login\elements\__init__.py



# pages\Login\elements\Password\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import PASSWORD_INPUT

class Password(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, PASSWORD_INPUT)
        el.clear()
        el.send_keys(value)


# pages\Login\elements\Password\selectors.py

PASSWORD_INPUT = "#j_password"


# pages\Login\elements\Password\__init__.py



# pages\Login\elements\Submit\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import SUBMIT_BTN

class Submit(Element):
    def click(self):
        el = self.wait_clickable(By.CSS_SELECTOR, SUBMIT_BTN)
        try:
            el.click()
        except Exception:
            self.js_click(el)


# pages\Login\elements\Submit\selectors.py

SUBMIT_BTN = "#logOnFormSubmit"


# pages\Login\elements\Submit\__init__.py



# pages\Login\elements\Username\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import USERNAME_INPUT

class Username(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, USERNAME_INPUT)
        el.clear()
        el.send_keys(value)


# pages\Login\elements\Username\selectors.py

USERNAME_INPUT = "#j_username"


# pages\Login\elements\Username\__init__.py



# pages\Shell\Search\element.py

# pages/Shell/Search/element.py
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import InvalidElementStateException, TimeoutException

from core.base import Element
from services.ui import wait_ui5_idle, wait_shell_search_ready, open_shell_search_via_js
from .selectors import (
    SEARCH_TOGGLE_CSS_PRIMARY,
    SEARCH_TOGGLE_CSS_ALT_HELP,
    SEARCH_TOGGLE_CSS_ALT_ARIA,
    SEARCH_INPUT_INNER_CSS,
    SUGGEST_TABLE_XPATH,
    APP_ROW_BY_TEXT_XPATH,
    APP_ROW_BY_TEXT_ALT_XPATH,
)

class ShellSearch(Element):
    def _wait_input_interactable(self):
        """
        Wait until the shell search input is present, visible, and not disabled/readOnly.
        Also ensure it has non-zero size (animation finished).
        """
        wait = WebDriverWait(self.driver, max(self._timeout, 25))
        inp = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Visible
        inp = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Enabled + not readOnly + has size
        wait.until(lambda d: d.execute_script(
            "var el=arguments[0];"
            "if(!el) return false;"
            "var cs=window.getComputedStyle(el);"
            "var ok=!!(el.offsetParent) && cs.visibility!=='hidden' && cs.display!=='none' && "
            "!el.disabled && !el.readOnly && el.clientWidth>0 && el.clientHeight>0;"
            "return ok;", inp))
        # Focus it
        try:
            inp.click()
        except Exception:
            self.js_click(inp)
        try:
            self.driver.execute_script("arguments[0].focus();", inp)
        except Exception:
            pass
        return inp

    def open_search(self):
        # Give UI5/FLP time to render the header/search
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        wait_shell_search_ready(self.driver, timeout=max(self._timeout, 25))

        # Try clicking toggle; else JS renderer fallback
        candidates = (SEARCH_TOGGLE_CSS_PRIMARY, SEARCH_TOGGLE_CSS_ALT_HELP, SEARCH_TOGGLE_CSS_ALT_ARIA)
        clicked = False
        for css in candidates:
            try:
                el = WebDriverWait(self.driver, max(self._timeout, 25)).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, css))
                )
                try:
                    el.click()
                except Exception:
                    self.js_click(el)
                clicked = True
                break
            except Exception:
                continue

        if not clicked:
            if not open_shell_search_via_js(self.driver):
                raise TimeoutError("Shell search toggle not found and JS fallback failed.")

        # Wait until input is truly interactable (not just present)
        self._wait_input_interactable()
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        return self

    def type_and_choose_app(self, query_text: str):
        inp = self._wait_input_interactable()

        # Clear safely
        try:
            inp.clear()
        except InvalidElementStateException:
            # JS clear fallback
            self.driver.execute_script(
                "arguments[0].value=''; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp
            )

        # Type the query; if Selenium send_keys bounces, use JS then send ENTER to trigger suggestions
        try:
            inp.send_keys(query_text)
        except InvalidElementStateException:
            self.driver.execute_script(
                "arguments[0].value=arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp, query_text
            )
            inp.send_keys(Keys.ENTER)

        # Wait for suggestions table to show up
        wait = WebDriverWait(self.driver, max(self._timeout, 10))
        try:
            wait.until(EC.presence_of_element_located((By.XPATH, SUGGEST_TABLE_XPATH)))
        except TimeoutException:
            # If suggestions didn't appear, fallback: open the app directly by intent hash
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
            )
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
            return self

        # Click the suggestion row (exact text), else fallback to contains()
        for xp in (APP_ROW_BY_TEXT_XPATH, APP_ROW_BY_TEXT_ALT_XPATH):
            try:
                row = wait.until(EC.element_to_be_clickable((By.XPATH, xp)))
                try:
                    row.click()
                except Exception:
                    self.js_click(row)
                wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
                return self
            except TimeoutException:
                continue

        # Last resort: deep-link by hash
        self.driver.execute_script(
            "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
        )
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 10))
        return self


# pages\Shell\Search\selectors.py

# pages/Shell/Search/selectors.py

# Shell search toggle (try a few stable variants)
SEARCH_TOGGLE_CSS_PRIMARY = "a#sf.sapUshellShellHeadItm"
SEARCH_TOGGLE_CSS_ALT_HELP = "a.sapUshellShellHeadItm[data-help-id='shellHeader-search']"
SEARCH_TOGGLE_CSS_ALT_ARIA = "a.sapUshellShellHeadItm[role='button'][aria-label*='Search']"

# The input that appears after opening search (robust id pattern)
SEARCH_INPUT_INNER_CSS = "input[id*='searchFieldInShell'][id$='-inner']"

# Suggestion table + target row
SUGGEST_TABLE_XPATH = "//table[contains(@id,'searchFieldInShell-input-popup-table-listUl')]"
# Prefer exact text; fall back to contains if localized slightly
APP_ROW_BY_TEXT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[normalize-space()='Currency Exchange Rates']/ancestor::*[self::tr or self::li][1]"
)
APP_ROW_BY_TEXT_ALT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[contains(normalize-space(),'Currency Exchange Rate')]/ancestor::*[self::tr or self::li][1]"
)


# pages\Shell\Search\__init__.py



## .txt / .csv / .json files (names only)

requirements.txt
snapshot.txt
pages\snapshot.txt