================  DIRECTORY TREE  ================
pages
├── CurrencyExchangeRates
│   ├── elements
│   │   ├── Dialog
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Factors
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Fields
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Footer
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Header
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── ListToolbar
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Messages
│   │   │   └── element.py
│   │   ├── Quotation
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Rate
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── SideColumn
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Status
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Toast
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Validation
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   └── __init__.py
│   ├── __init__.py
│   ├── page.py
│   └── selectors.py
├── Index
│   ├── ProcurementOverviewTile
│   │   ├── __init__.py
│   │   ├── element.py
│   │   └── selectors.py
│   ├── PurchasingTab
│   │   ├── __init__.py
│   │   ├── element.py
│   │   └── selectors.py
│   ├── __init__.py
│   └── page.py
├── Login
│   ├── elements
│   │   ├── Password
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Submit
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   ├── Username
│   │   │   ├── __init__.py
│   │   │   ├── element.py
│   │   │   └── selectors.py
│   │   └── __init__.py
│   ├── __init__.py
│   └── page.py
├── Shell
│   ├── Search
│   │   ├── __init__.py
│   │   ├── element.py
│   │   └── selectors.py
│   └── __init__.py
├── __init__.py
└── snapshot.txt

================  FILE CONTENTS  =================

# __init__.py



# CurrencyExchangeRates\page.py

# pages/CurrencyExchangeRates/page.py

from urllib.parse import urlparse
from datetime import datetime
import os
import time
import re
from typing import Optional
from contextlib import nullcontext

from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Page, Element
from services.ui import wait_ui5_idle
from .selectors import APP_HASH

# Elements
from .elements.ListToolbar.element import ListToolbar
from .elements.Dialog.element import DialogWatcher
from .elements.Fields.element import Fields
from .elements.Factors.element import Factors
from .elements.Quotation.element import QuotationField
from .elements.Rate.element import ExchangeRateField
from .elements.Footer.element import FooterActions
from .elements.Toast.element import ToastReader
from .elements.Validation.element import ValidationInspector
from .elements.SideColumn.element import SideColumnController
from .elements.Header.element import ObjectHeaderVerifier

# For verify-after-set of Quotation
from .elements.Quotation.selectors import QUOTATION_INNER_INPUT_XPATH

# legacy constant (not used directly; Fields.EXCH_TYPE_INPUT_XPATH is used)
EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,"
                         "'ExchangeRateTypeForEdit::Field-input-inner')]")

# The exact label we want for the Exchange Rate Type field
TARGET_EXCH_TYPE_LABEL = "M (Standard translation at average rate)"

# --- tiny retry helper (local, non-invasive) ---
def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class CurrencyExchangeRatesPage(Page):
    def __init__(self, driver, root: Optional[str] = None):
        super().__init__(driver, root)
        self._app_ready_fast = False  # quick flag

    def _el(self) -> Element:
        return Element(self.driver)

    # -------- Utilities --------
    def _origin(self) -> str:
        try:
            return self.driver.execute_script("return location.origin;")
        except Exception:
            parsed = urlparse(self.driver.current_url or "")
            return f"{parsed.scheme}://{parsed.netloc}"

    def _app_root_url(self) -> str:
        return f"{self._origin()}/ui?sap-ushell-config=lean{APP_HASH}"

    def _wait_not_busy(self, timeout: int) -> bool:
        end = time.time() + max(1, timeout)
        while time.time() < end:
            try:
                busy = self.driver.execute_script(
                    """
                    try{
                      var core=sap && sap.ui && sap.ui.getCore ? sap.ui.getCore():null;
                      if(core && core.isInitialized && !core.isInitialized()) return true;
                      if(core && core.getUIDirty && core.getUIDirty()) return true;
                      var BI=sap && sap.ui && sap.ui.core && sap.ui.core.BusyIndicator;
                      if(BI && BI.oPopup && BI.oPopup.getOpenState && BI.oPopup.getOpenState() === 'OPEN'){return true;}
                      return false;
                    }catch(e){return false;}
                    """
                )
                if not busy:
                    return True
            except Exception:
                return True
            time.sleep(0.12)
        return False

    # --- EXACTLY set Exchange Rate Type to the full label ---
    def _set_exchange_rate_type_exact(self, fields: Fields, timeout: int = 12) -> dict:
        """
        Hard-sets Exchange Rate Type to the exact UI label:
          M (Standard translation at average rate)

        Returns:
          {"ok": True, "observed": "<value>"} when confirmed exact,
          {"ok": False, "observed": "<value>", "why": "<reason>"} otherwise.
        """
        el = self._el()
        t = max(timeout, el._timeout)

        def _get():
            try:
                return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
            except Exception:
                return ""

        def _blur(xpath: str):
            try:
                self.driver.execute_script(
                    """
                    try{
                      var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                      if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur && el.blur(); }
                    }catch(e){}
                    """,
                    xpath
                )
            except Exception:
                pass

        # fast path — already exact
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        # 1) Try simple 'M' + Enter + blur
        try:
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, "M", press_enter=True)
        except Exception:
            pass
        _blur(fields.EXCH_TYPE_INPUT_XPATH)
        wait_ui5_idle(self.driver, timeout=t)
        self._wait_not_busy(t)
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        # 2) Open value-help and pick exact label
        try:
            vhi_xpath = fields.EXCH_TYPE_INPUT_XPATH.replace("-inner", "-vhi")
            vhi = el.wait_clickable(By.XPATH, vhi_xpath)
            el.js_click(vhi)

            WebDriverWait(self.driver, t).until(
                EC.presence_of_element_located((By.XPATH,
                    "//*[contains(@class,'sapMDialog') or contains(@class,'sapUiMdcValueHelpDialog') or contains(@class,'sapMPopup')]"))
            )
            exact_cell = WebDriverWait(self.driver, t).until(
                EC.element_to_be_clickable((By.XPATH, f"//span[normalize-space(text())='{TARGET_EXCH_TYPE_LABEL}']"))
            )
            el.js_click(exact_cell)

            # If value-help has an OK button, click it
            try:
                ok_btn = WebDriverWait(self.driver, 2).until(
                    EC.element_to_be_clickable((By.XPATH, "//button[.//bdi[normalize-space()='OK'] or .//span[normalize-space()='OK']]"))
                )
                el.js_click(ok_btn)
            except Exception:
                pass
        except Exception:
            pass

        _blur(fields.EXCH_TYPE_INPUT_XPATH)
        wait_ui5_idle(self.driver, timeout=t)
        self._wait_not_busy(t)
        cur = _get()
        if cur == TARGET_EXCH_TYPE_LABEL:
            return {"ok": True, "observed": cur}

        return {"ok": False, "observed": cur, "why": "could_not_select_exact_label"}

    # -------- App navigation (hardened) --------
    def ensure_in_app(self, max_attempts: int = 2, settle_each: int = 8):
        attempts = max(1, max_attempts)
        listbar = ListToolbar(self.driver)
        sidecol = SideColumnController(self.driver)

        for _ in range(attempts):
            cur = (self.driver.current_url or "")
            if APP_HASH.lower() not in cur.lower():
                self.driver.execute_script("location.href = arguments[0];", self._app_root_url())

            wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, settle_each))
            self._wait_not_busy(max(self._el()._timeout, settle_each))

            sidecol.close_if_present(timeout=min(10, max(8, self._el()._timeout)))

            try:
                listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
                self._app_ready_fast = True
                return
            except TimeoutException:
                self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
                time.sleep(0.5)

        self._app_ready_fast = False
        raise TimeoutException(f"ensure_in_app failed after {attempts} attempts.")

    def ensure_in_app_quick(self):
        if self._app_ready_fast:
            try:
                if ListToolbar(self.driver).is_at_list(quick=1.0):
                    return
            except Exception:
                pass
        self.ensure_in_app(max_attempts=3, settle_each=8)

    def back_to_list(self):
        listbar = ListToolbar(self.driver)
        self.driver.execute_script("location.href = arguments[0];", self._app_root_url())
        wait_ui5_idle(self.driver, timeout=max(self._el()._timeout, 20))
        listbar.wait_create_clickable(timeout=max(60, self._el()._timeout))
        self._app_ready_fast = True

    # -------- Internal helpers --------
    def _click_list_create(self, timeout: int | None = None):
        listbar = ListToolbar(self.driver)
        listbar.click_create(timeout or self._el()._timeout)
        wait_ui5_idle(self.driver, timeout=timeout or self._el()._timeout)
        self._wait_not_busy(timeout or self._el()._timeout)

    def _read_last_toast_text(self) -> str:
        return ToastReader(self.driver).read_last()

    def _wait_object_header_ready(self, timeout: int) -> bool:
        return ObjectHeaderVerifier(self.driver).wait_ready(timeout=timeout)

    def _wait_for_success_toast_or_list(self, timeout: int) -> dict:
        listbar = ListToolbar(self.driver)
        dlg = DialogWatcher(self.driver)
        end = time.time() + max(timeout, self._el()._timeout)
        info = {"toast": "", "dialog": "", "at_list": False}
        while time.time() < end:
            if dlg.is_open():
                info["dialog"] = dlg.text() or "Dialog open (no text captured)."
                return info
            txt = ToastReader(self.driver).read_last()
            if txt:
                info["toast"] = txt
                lt = txt.lower()
                if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                    return info
            try:
                listbar.wait_create_clickable(timeout=0.8)
                info["at_list"] = True
                return info
            except Exception:
                pass
            time.sleep(0.18)
        return info

    # -------- SOFT guard: ensure type contains 'M' (do not abort) --------
    def _soft_ensure_exch_type_contains_M(self, fields: Fields, desired_exch_type: str) -> dict:
        """
        Ensure the Exchange Rate Type *contains* 'M' BEFORE clicking Create,
        but do NOT abort the row pre-commit.
        """
        def _get():
            try:
                return _retry_stale(lambda: (fields.get_input_value(fields.EXCH_TYPE_INPUT_XPATH) or "").strip())
            except Exception:
                return ""

        cur = _get()
        if "m" in cur.lower():
            return {"ok": True, "observed": cur}

        # corrective retype
        try:
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, desired_exch_type, press_enter=True)
        except Exception:
            pass
        # explicit blur to fire change bindings
        try:
            self.driver.execute_script(
                """
                try{
                  var el=document.evaluate(arguments[0],document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
                  if (el){ el.dispatchEvent(new Event('change',{bubbles:true})); el.blur&&el.blur(); }
                }catch(e){}
                """,
                fields.EXCH_TYPE_INPUT_XPATH
            )
        except Exception:
            pass

        wait_ui5_idle(self.driver, timeout=self._el()._timeout)
        self._wait_not_busy(self._el()._timeout)

        cur2 = _get()
        return {"ok": ("m" in cur2.lower()), "observed": cur2}

    # ---------------- NEW helpers for your policy ----------------
    def _detect_lock_info(self, text: str) -> dict | None:
        if not text:
            return None
        low = text.lower()
        if "locked by user" in low and "table" in low and "tcurr" in low:
            m = re.search(r"Table\s+(\w+)\s+is\s+locked\s+by\s+user\s+([A-Za-z0-9_]+)", text, re.IGNORECASE)
            table = None
            owner = None
            if m:
                table = m.group(1)
                owner = m.group(2)
            return {"table": table or "TCURR", "owner": owner or ""}
        return None

    def _is_required_fields_dialog(self, s: str) -> bool:
        return "fill out all required entry fields" in (s or "").lower()

    def _is_duplicate_exists(self, s: str) -> bool:
        low = (s or "").lower()
        return ("exchange rate" in low) and ("already exists in the system" in low)

    # -------- Public: create + submit --------
    def create_entry_and_submit(
        self,
        exch_type: str,
        from_ccy: str,
        to_ccy: str,
        valid_from_ddmmyyyy: str,     # IMPORTANT: pass DD.MM.YYYY
        quotation: str,
        rate_str: str,
        commit_gate=None,
    ) -> dict:
        fields = Fields(self.driver)
        factors = Factors(self.driver)
        quote = QuotationField(self.driver)
        rate = ExchangeRateField(self.driver)
        footer = FooterActions(self.driver)
        listbar = ListToolbar(self.driver)
        dlg = DialogWatcher(self.driver)
        sidecol = SideColumnController(self.driver)
        validate = ValidationInspector(self.driver)

        el = self._el()

        # QUICK ensure to avoid heavy waits on every item
        self.ensure_in_app_quick()

        # ---------- local helpers ----------
        def _noop_gate_ctx():
            class _C:
                def __enter__(self): return None
                def __exit__(self, *a): return False
            return _C()

        def _verify_or_retype(xpath: str, expected: str) -> None:
            if expected is None:
                return
            got = (fields.get_input_value(xpath) or "").strip()
            if got.lower() != (expected or "").strip().lower():
                fields.set_plain_input(xpath, expected, press_enter=True)
                _ = fields.get_input_value(xpath)

        def _verify_quotation(expected: str) -> None:
            try:
                cur = _retry_stale(lambda: (self.driver.find_element(By.XPATH, QUOTATION_INNER_INPUT_XPATH).get_attribute("value") or "").strip())
            except Exception:
                cur = ""
            if cur.lower() != (expected or "").strip().lower():
                quote.set_value(expected)

        def _fill_all_fields(prefer_ui5_for_rate: bool = False):
            # 1) Exchange Rate Type
            fields.set_plain_input(fields.EXCH_TYPE_INPUT_XPATH, exch_type, press_enter=True)
            _verify_or_retype(fields.EXCH_TYPE_INPUT_XPATH, exch_type)

            # 2) From Currency
            fields.set_plain_input(fields.FROM_CCY_INPUT_XPATH, from_ccy, press_enter=True)
            _verify_or_retype(fields.FROM_CCY_INPUT_XPATH, from_ccy)

            # 3) To Currency
            fields.set_plain_input(fields.TO_CCY_INPUT_XPATH, to_ccy, press_enter=True)
            _verify_or_retype(fields.TO_CCY_INPUT_XPATH, to_ccy)

            # 4) Valid From — **DD.MM.YYYY** (typed EXACTLY as provided)
            fields.set_plain_input(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy, press_enter=True)
            _verify_or_retype(fields.VALID_FROM_INPUT_XPATH, valid_from_ddmmyyyy)

            # 5) Quotation
            quote.set_value(quotation)
            _verify_quotation(quotation)

            # 6) Factors and Rate
            factors.try_set_from("1")
            factors.try_set_to("1")
            if prefer_ui5_for_rate:
                rate.set_via_ui5(rate_str)
                rate.commit(times=1)
            else:
                rate.set_via_typing(rate_str)
                rate.commit(times=2)

        def _looks_like_required_fields_issue(msgs: list[dict]) -> bool:
            if not msgs:
                return False
            blob = " | ".join(
                f"{(m.get('message') or '')} {m.get('description') or ''}".lower()
                for m in msgs
            )
            keys = (
                "fill out all required",
                "required entry fields",
                "required field",
                "mandatory field",
                "exchange rate type",
                "from currency",
            )
            return any(k in blob for k in keys)

        def _commit_flow_under_gate() -> dict:
            # same provider
            gate_ctx = commit_gate() if callable(commit_gate) else _noop_gate_ctx()
            # Hold the gate for the ENTIRE commit attempt to prevent overlapping commits.
            with gate_ctx:
                first_phase = footer.click_create(clicks=1)

                header_ready = self._wait_object_header_ready(timeout=min(10, max(8, el._timeout)))
                if header_ready:
                    sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))
                    return {
                        "status": "created",
                        "footer_clicks": 1,
                        "intermediate_toasts": first_phase.get("toasts", []),
                        "toast": self._read_last_toast_text(),
                        "at_list": True,
                        "dialog_open": False,
                        "dialog_text": "",
                    }

                loop_res = footer.ensure_created_by_loop_clicking(
                    object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                    at_list=lambda: listbar.is_at_list(quick=0.8),
                    close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                    total_timeout=max(35, el._timeout),
                    max_clicks=5,
                )
                if loop_res.get("status") in ("created", "dialog_open", "activation_error"):
                    return loop_res

                final_phase = self._wait_for_success_toast_or_list(timeout=max(el._timeout, 18))
                if not final_phase.get("at_list"):
                    sidecol.close_if_present(timeout=min(12, max(10, el._timeout)))

                if final_phase.get("dialog"):
                    return {
                        "status": "dialog_open",
                        "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                        "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                        "toast": final_phase.get("toast", ""),
                        "dialog_open": True,
                        "dialog_text": final_phase.get("dialog", ""),
                    }

                status_guess = "created" if (
                    final_phase.get("at_list")
                    or (final_phase.get("toast") and any(k in final_phase.get("toast", "").lower()
                        for k in ("created", "activated", "successfully")))
                ) else "unknown"

                if status_guess != "created":
                    strict = footer.ensure_created_by_loop_clicking(
                        object_header_ready=lambda: self._wait_object_header_ready(timeout=4),
                        at_list=lambda: listbar.is_at_list(quick=0.8),
                        close_side=lambda: sidecol.close_if_present(timeout=max(8, el._timeout)),
                        total_timeout=max(30, el._timeout),
                        max_clicks=5,
                    )
                    if strict.get("status") == "created":
                        return strict

                return {
                    "status": status_guess,
                    "footer_clicks": 1 + loop_res.get("footer_clicks", 0),
                    "intermediate_toasts": first_phase.get("toasts", []) + loop_res.get("intermediate_toasts", []),
                    "toast": final_phase.get("toast", ""),
                    "at_list": True,
                    "dialog_open": False,
                    "dialog_text": "",
                }

        # 1) Open form
        self._click_list_create(timeout=el._timeout)

        # 2) Fill fields (DD.MM.YYYY is passed straight through)
        _fill_all_fields(prefer_ui5_for_rate=False)

        # 2.5) SOFT GUARD: ensure Exchange Rate Type *contains* "M"
        m_check = self._soft_ensure_exch_type_contains_M(fields, exch_type)
        # (we still proceed; just annotate later if needed)

        # 3) Pre-submit validation (client)
        err = ValidationInspector(self.driver).collect()
        if err and "greater than zero" in (err or "").lower():
            Factors(self.driver).try_set_from("1")
            Factors(self.driver).try_set_to("1")
            ExchangeRateField(self.driver).set_via_ui5(rate_str)
            ExchangeRateField(self.driver).commit(times=1)
            err = ValidationInspector(self.driver).collect()

        # ---------------- Commit with POLICY REMAP ----------------
        # NOTE: The old code retried locks; your policy maps TCURR locks to PENDING directly.

        # 4) COMMIT attempt
        res = _commit_flow_under_gate()
        status = (res.get("status") or "").lower()

        # 5) Post-commit note if M was missing pre-commit
        if not m_check.get("ok", True):
            res.setdefault("notes", {})
            res["notes"]["exch_type_missing_M_precommit"] = True
            res["notes"]["observed_exch_type"] = m_check.get("observed", "")

        # --- Build a combined message blob for policy checks
        msgs = res.get("messages", []) or []
        joined_msgs = " | ".join(f"{(m.get('message') or '')} {m.get('description') or ''}".strip() for m in msgs)
        joined_all = " | ".join([res.get("dialog_text") or "", joined_msgs]).strip()

        # === POLICY REMAP ===
        # TCURR lock anywhere → Pending (not Locked)
        lock = self._detect_lock_info(joined_all)
        if lock:
            try: DialogWatcher(self.driver).close(timeout=1.0)
            except Exception: pass
            SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
            try: self.back_to_list()
            except Exception: pass
            return {
                "status": "pending",
                "dialog_open": False,
                "dialog_text": res.get("dialog_text", ""),
                "notes": {
                    "lock_table": lock.get("table", "TCURR"),
                    "lock_owner": lock.get("owner", ""),
                    "reason": "table_lock_tcurr"
                }
            }

        # Duplicate exists → Skipped
        if self._is_duplicate_exists(joined_all):
            try: DialogWatcher(self.driver).close(timeout=1.0)
            except Exception: pass
            SideColumnController(self.driver).close_if_present(timeout=min(12, max(10, el._timeout)))
            try: self.back_to_list()
            except Exception: pass
            return {
                "status": "skipped",
                "dialog_open": False,
                "dialog_text": res.get("dialog_text", ""),
                "notes": {"already_existed": True}
            }

        # Created passes through as Created (Done by the worker/runner mapping)
        if status == "created":
            return res

        # Activation error: keep as 'error' (visible) unless policy conditions matched above
        # Unknown: your policy wants re-queue → map to 'pending'
        if status == "unknown":
            res["status"] = "pending"
            return res

        # anything else (dialog_open without recognized messages etc.) → return as-is
        return res

    def create_rate(
        self,
        exch_type: str,
        from_ccy: str,
        to_ccy: str | None = None,
        valid_from_mmddyyyy: str = "",
        quotation: str = "",
        rate_value: str | float = "",
        to_cy: str | None = None,
        commit_gate=None,
    ) -> dict:
        """
        NOTE: pass date in **DD.MM.YYYY**. We DO NOT convert here.
        services.schemas.ExchangeRateItem already normalizes to DD.MM.YYYY.
        """
        if to_ccy is None and to_cy is not None:
            to_ccy = to_cy
        if to_ccy is None:
            raise TypeError("create_rate() missing required argument: 'to_ccy'")

        valid_from_ddmmyyyy = valid_from_mmddyyyy

        return self.create_entry_and_submit(
            exch_type=exch_type,
            from_ccy=from_ccy,
            to_ccy=to_ccy,
            valid_from_ddmmyyyy=valid_from_ddmmyyyy,   # typed as-is
            quotation=quotation,
            rate_str=str(rate_value),
            commit_gate=commit_gate,
        )


# CurrencyExchangeRates\selectors.py

# pages/CurrencyExchangeRates/selectors.py
APP_HASH = "#Currency-maintainExchangeRates"


# CurrencyExchangeRates\__init__.py



# Index\page.py

# pages/Index/page.py
from core.base import Page
from services.ui import wait_ui5_idle
from .PurchasingTab.element import PurchasingTab
from .ProcurementOverviewTile.element import ProcurementOverviewTile

class IndexPage(Page):
    """Fiori Launchpad 'Shell-home' landing."""

    def ensure_home(self):
        wait_ui5_idle(self.driver)

    def to_purchasing(self):
        PurchasingTab(self.driver).click()
        wait_ui5_idle(self.driver)

    def open_procurement_overview(self):
        ProcurementOverviewTile(self.driver).click()
        wait_ui5_idle(self.driver)


# Index\__init__.py



# Login\page.py

from core.base import Page
from services.config import config
from .elements.Username.element import Username
from .elements.Password.element import Password
from .elements.Submit.element import Submit

class LoginPage(Page):
    def go(self):
        self.open(config()["SAP_URL"])

    def login(self, username: str, password: str):
        self.go()
        Username(self.driver).set(username)
        Password(self.driver).set(password)
        Submit(self.driver).click()
        # Post-click, S/4HANA may keep same URL but replace DOM; verification is in services.ui


# Login\__init__.py



# Shell\__init__.py



# CurrencyExchangeRates\elements\__init__.py



# CurrencyExchangeRates\elements\Dialog\element.py

# pages/CurrencyExchangeRates/elements/Dialog/element.py
from __future__ import annotations

from typing import Optional
import time

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import (
    TimeoutException,
    StaleElementReferenceException,
    NoSuchElementException,
)

from core.base import Element

# Robust selectors for the Message Popover
_POPOVER_WRAPPER_CSS = ".sapMPopoverWrapper"
_POPOVER_CONT_CSS    = ".sapMPopoverCont"
_CLOSE_BTN_CSS       = "button.sapMMsgPopoverCloseBtn"   # the “X” button
# Title/span for message text (works for list view items)
_MSG_ITEM_TITLE_XP   = "//li[contains(@class,'sapMMsgViewItem')]" \
                        "//span[contains(@id,'-titleText')]"

# Generic dialog “Close” button by visible text
_CLOSE_BDI_BTN_XP    = "//bdi[normalize-space()='Close']/ancestor::button[1] | //button[.//bdi[normalize-space()='Close']]"
# Generic OK button (fallbacks)
_OK_BDI_BTN_XP       = "//bdi[normalize-space()='OK']/ancestor::button[1] | //button[.//bdi[normalize-space()='OK']]"

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class DialogWatcher:
    """
    Handles both classic sap.m.Dialog and the Message Popover.
    Now also knows how to click a <bdi>Close</bdi> button exactly like:
      <span class="sapMBtnContent"><bdi>Close</bdi></span>
    """

    def __init__(self, driver):
        self.driver = driver
        self._el = Element(driver)

    # ---------- basic checks ----------
    def _any_popover_present(self) -> bool:
        def _see():
            els = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
            return any((e.is_displayed() for e in els))
        try:
            return _retry_stale(_see)
        except Exception:
            return False

    def is_open(self) -> bool:
        if self._any_popover_present():
            return True
        try:
            return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _CLOSE_BDI_BTN_XP)))
        except Exception:
            pass
        try:
            return _retry_stale(lambda: any(b.is_displayed() for b in self.driver.find_elements(By.XPATH, _OK_BDI_BTN_XP)))
        except Exception:
            pass
        return False

    # ---------- text scraping ----------
    def text(self, timeout: float = 0.5) -> str:
        end = time.time() + timeout
        while time.time() < end:
            try:
                el = WebDriverWait(self.driver, 0.25, ignored_exceptions=(StaleElementReferenceException,)).until(
                    EC.presence_of_element_located((By.XPATH, _MSG_ITEM_TITLE_XP))
                )
                if el.is_displayed():
                    try:
                        return el.text.strip()
                    except StaleElementReferenceException:
                        pass
                break
            except Exception:
                pass
        try:
            return (self.driver.execute_script("""
                try{
                  var dlg = document.querySelector("div[role='dialog']");
                  if(!dlg) return '';
                  var h = dlg.querySelector(".sapMDialogTitle, .sapMTitle, [role='heading']");
                  return (h && (h.innerText||h.textContent)||'').trim();
                }catch(e){ return ''; }
            """) or "").strip()
        except Exception:
            return ""

    # ---------- close helpers ----------
    def _try_click_close_button_once(self) -> bool:
        try:
            pops = self.driver.find_elements(By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS)
            for pop in pops:
                try:
                    if not pop.is_displayed():
                        continue
                except StaleElementReferenceException:
                    continue
                try:
                    btn = pop.find_element(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                except NoSuchElementException:
                    try:
                        btns = self.driver.find_elements(By.CSS_SELECTOR, _CLOSE_BTN_CSS)
                        btn  = next((b for b in btns if b.is_displayed()), None)
                    except StaleElementReferenceException:
                        btn = None
                if btn:
                    try:
                        self._el.js_click(btn)
                        return True
                    except StaleElementReferenceException:
                        pass
        except StaleElementReferenceException:
            return False
        except Exception:
            return False
        return False

    def _js_fallback_close_all_popovers(self) -> bool:
        try:
            return bool(self.driver.execute_script("""
                try{
                  var closed = 0;
                  document.querySelectorAll('button.sapMMsgPopoverCloseBtn').forEach(function(b){
                    try{
                      var r = b.getBoundingClientRect();
                      var visible = !!(r.width || r.height) && window.getComputedStyle(b).visibility !== 'hidden';
                      if (visible) { b.click(); closed++; }
                    }catch(e){}
                  });
                  return closed > 0;
                }catch(e){ return false; }
            """))
        except Exception:
            return False

    def _click_bdi_close(self) -> bool:
        try:
            btn = WebDriverWait(self.driver, 1.5, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, _CLOSE_BDI_BTN_XP))
            )
            try:
                self._el.js_click(btn)
            except Exception:
                try:
                    btn.click()
                except Exception:
                    pass
            return True
        except Exception:
            return False

    def _click_ok(self) -> bool:
        try:
            btn = WebDriverWait(self.driver, 1.0, ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, _OK_BDI_BTN_XP))
            )
            try:
                self._el.js_click(btn)
            except Exception:
                try:
                    btn.click()
                except Exception:
                    pass
            return True
        except Exception:
            return False

    # ---------- public API ----------
    def close(self, timeout: float = 2.0) -> bool:
        end = time.time() + max(0.2, timeout)

        while time.time() < end:
            # Popover?
            if self._any_popover_present():
                for _ in (1, 2):
                    if self._try_click_close_button_once():
                        try:
                            WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                                EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                            )
                        except Exception:
                            pass
                        if not self._any_popover_present():
                            return True
                if self._js_fallback_close_all_popovers():
                    try:
                        WebDriverWait(self.driver, 0.5, ignored_exceptions=(StaleElementReferenceException,)).until_not(
                            EC.presence_of_element_located((By.CSS_SELECTOR, _POPOVER_WRAPPER_CSS))
                        )
                    except Exception:
                        pass
                    if not self._any_popover_present():
                        return True

            # Dialog “Close”
            if self._click_bdi_close():
                time.sleep(0.15)
                if not self.is_open():
                    return True

            # Dialog “OK” fallback
            if self._click_ok():
                time.sleep(0.15)
                if not self.is_open():
                    return True

            time.sleep(0.12)

        return not self.is_open()


# CurrencyExchangeRates\elements\Dialog\selectors.py

# Generic dialog root
DIALOG_ROOT_CSS = "div[role='dialog']"


# CurrencyExchangeRates\elements\Dialog\__init__.py



# CurrencyExchangeRates\elements\Factors\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import FROM_FACTOR_BY_LABEL_XPATH, TO_FACTOR_BY_LABEL_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class Factors(Element):
    def _try_set_by_label(self, label_xpath: str, value: str = "1") -> bool:
        def _find():
            return self.driver.find_element(By.XPATH, label_xpath)

        try:
            inp = _retry_stale(_find)
        except Exception:
            return False

        try:
            for fn in (
                lambda: inp.clear(),
                lambda: inp.send_keys(Keys.CONTROL, "a"),
                lambda: inp.send_keys(Keys.DELETE),
                lambda: self.driver.execute_script(
                    "arguments[0].value='';"
                    "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                    "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
            ):
                try:
                    _retry_stale(fn)
                except Exception:
                    pass

            _retry_stale(lambda: inp.send_keys(value))
            try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
            except Exception: pass
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            return True
        except Exception:
            return False

    def try_set_from(self, value: str = "1") -> bool:
        return self._try_set_by_label(FROM_FACTOR_BY_LABEL_XPATH, value)

    def try_set_to(self, value: str = "1") -> bool:
        return self._try_set_by_label(TO_FACTOR_BY_LABEL_XPATH, value)


# CurrencyExchangeRates\elements\Factors\selectors.py

FROM_FACTOR_BY_LABEL_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='From Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Unit')]]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'From') and contains(normalize-space(.),'Factor')]]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)
TO_FACTOR_BY_LABEL_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='To Currency Unit']]/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Unit')]]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//label[.//bdi[contains(normalize-space(.),'To') and contains(normalize-space(.),'Factor')]]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)


# CurrencyExchangeRates\elements\Factors\__init__.py



# CurrencyExchangeRates\elements\Fields\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import (
    EXCH_TYPE_INPUT_XPATH,
    FROM_CCY_INPUT_XPATH,
    TO_CCY_INPUT_XPATH,
    VALID_FROM_INPUT_XPATH,
)

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class Fields(Element):
    EXCH_TYPE_INPUT_XPATH = ("//input[contains(@id,'ExchangeRateTypeForEdit::Field-input-inner')]")
    FROM_CCY_INPUT_XPATH  = ("//input[contains(@id,'SourceCurrencyForEdit::Field-input-inner')]")
    TO_CCY_INPUT_XPATH    = ("//input[contains(@id,'TargetCurrencyForEdit::Field-input-inner')]")
    VALID_FROM_INPUT_XPATH= ("//input[contains(@id,'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')]")

    def _hard_clear(self, web_el):
        for fn in (
            lambda: web_el.clear(),
            lambda: web_el.send_keys(Keys.CONTROL, "a"),
            lambda: web_el.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", web_el),
        ):
            try: _retry_stale(fn)
            except Exception: pass

    def get_input_value(self, xpath: str) -> str:
        def _get():
            el = self.find(By.XPATH, xpath)
            return el.get_attribute("value") or ""
        try:
            return _retry_stale(_get)
        except Exception:
            return ""

    def set_plain_input(self, xpath: str, text: str, press_enter: bool = False) -> None:
        def _get():
            return self.wait_clickable(By.XPATH, xpath)
        inp = _retry_stale(_get)

        def _focus_click():
            try:
                self.js_click(inp)
            except Exception:
                inp.click()
        _retry_stale(_focus_click)

        _retry_stale(lambda: inp.clear())
        _retry_stale(lambda: inp.send_keys(str(text or "")))
        if press_enter:
            _retry_stale(lambda: inp.send_keys(Keys.ENTER))
        try:
            self.driver.execute_script(
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true})); arguments[0].blur && arguments[0].blur();",
                inp
            )
        except Exception:
            pass
        # tiny settle helps UI5 bindings stabilize before subsequent reads
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 3))


# CurrencyExchangeRates\elements\Fields\selectors.py

EXCH_TYPE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateTypeForEdit::Field-input-inner')+1)="
    "'ExchangeRateTypeForEdit::Field-input-inner']"
)
FROM_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('SourceCurrencyForEdit::Field-input-inner')+1)="
    "'SourceCurrencyForEdit::Field-input-inner']"
)
TO_CCY_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('TargetCurrencyForEdit::Field-input-inner')+1)="
    "'TargetCurrencyForEdit::Field-input-inner']"
)
VALID_FROM_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateEffectiveDateFoEd::Field-datePicker-inner')+1)="
    "'ExchangeRateEffectiveDateFoEd::Field-datePicker-inner']"
)


# CurrencyExchangeRates\elements\Fields\__init__.py



# CurrencyExchangeRates\elements\Footer\element.py

# elements/Footer/element.py
import time
from typing import Callable, Dict

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException, StaleElementReferenceException

from core.base import Element, fluent_wait
from services.ui import wait_ui5_idle
from ..Dialog.element import DialogWatcher
from ..Toast.element import ToastReader
from ..Messages.element import Ui5Messages
from ..Status.element import StatusProbe
from .selectors import (
    ACTIVATE_CREATE_BTN_XPATH,
    FORM_CREATE_OR_SAVE_BTN_XPATH,
    ACTIVATE_CREATE_BTN_CSS,
    HEADER_TITLE_ID_SUFFIX,
    EDIT_BTN_ID_SUFFIX,
    DISCARD_BTN_ID_SUFFIX,
    COPY_BTN_ID_CONTAINS,
)

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None


class FooterActions(Element):
    """
    Submit logic with:
      - first attempt click
      - loop clicking with DOM/MessageManager checks
      - uses StatusProbe for robust success detection
    """

    EXTRA_SETTLE_SEC = 0.2  # trimmed

    # ---------- finding & UI5 press helpers ----------

    def _query_visible_by_suffix(self, suffix: str) -> str | None:
        try:
            return self.driver.execute_script(
                """
                var suffix = arguments[0];
                var nodes = document.querySelectorAll("[id$='"+suffix.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                return null;
                """,
                suffix,
            )
        except Exception:
            return None

    def _header_aria_label(self) -> str:
        try:
            return self.driver.execute_script(
                """
                var suf = arguments[0];
                var nodes = document.querySelectorAll("[id$='"+suf.replace(/([.*+?^${}()|[\\]\\\\])/g,'\\\\$1')+"']");
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ var el=nodes[i]; if(!vis(el)) continue;
                  var a=(el.getAttribute('aria-label')||'').trim(); if(a) return a; }
                return '';
                """,
                HEADER_TITLE_ID_SUFFIX,
            ) or ""
        except Exception:
            return ""

    def _query_activate_id(self) -> str | None:
        try:
            return self.driver.execute_script(
                """
                var sel = arguments[0], nodes = document.querySelectorAll(sel);
                function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  var r=el.getBoundingClientRect(); return (r.width>0 && r.height>0); }
                for (var i=nodes.length-1;i>=0;i--){ if (vis(nodes[i])) return nodes[i].id||null; }
                return null;
                """,
                ACTIVATE_CREATE_BTN_CSS,
            )
        except Exception:
            return None

    def _really_clickable(self, dom_id: str) -> bool:
        try:
            return bool(self.driver.execute_script(
                """
                try {
                  var el=document.getElementById(arguments[0]); if(!el) return false;
                  var cs=getComputedStyle(el);
                  if(cs.display==='none'||cs.visibility==='hidden') return false;
                  if(el.disabled) return false;
                  if((' '+el.className+' ').indexOf(' sapMBtnDisabled ')>=0) return false;
                  var r=el.getBoundingClientRect();
                  if (r.width<=0 || r.height<=0) return false;
                  var cx=r.left+r.width/2, cy=r.top+r.height/2;
                  var at=document.elementFromPoint(Math.max(0,cx),Math.max(0,cy));
                  return !!(at && (at===el || el.contains(at)));
                }catch(e){ return false; }
                """,
                dom_id
            ))
        except Exception:
            return False

    def _ui5_press_by_id(self, dom_id: str) -> str:
        try:
            res = self.driver.execute_script(
                """
                try {
                  var id = arguments[0];
                  var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(id) : null;
                  if (ctrl && ctrl.firePress) { ctrl.firePress(); return 'ui5-firePress'; }
                  if (ctrl && ctrl.press)     { ctrl.press();     return 'ui5-press'; }
                  var el = document.getElementById(id);
                  if (el) { el.click(); return 'dom-click-fallback'; }
                  return 'ui5-miss';
                } catch(e){ return 'ui5-exc:'+String(e); }
                """,
                dom_id,
            )
            return str(res)
        except Exception as e:
            return f"ui5-exc:{type(e).__name__}"

    def _press_activate_best_effort(self) -> bool:
        act_id = self._query_activate_id()
        if act_id:
            try:
                def _get_el():
                    return self.driver.find_element(By.ID, act_id)
                el = _retry_stale(_get_el)

                try:
                    self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                except Exception:
                    pass

                if self._really_clickable(act_id):
                    try:
                        _retry_stale(lambda: el.click())
                        wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                        time.sleep(self.EXTRA_SETTLE_SEC)
                        return True
                    except Exception:
                        pass

                try:
                    self.driver.execute_script("arguments[0].click();", el)
                    wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                    time.sleep(self.EXTRA_SETTLE_SEC)
                    return True
                except Exception:
                    pass

                _ = self._ui5_press_by_id(act_id)
                wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)
                return True
            except Exception:
                pass

        # Fallback: generic Create/Save by text
        try:
            btn = fluent_wait(self.driver, 1.5, poll=0.15).until(
                EC.element_to_be_clickable((By.XPATH, FORM_CREATE_OR_SAVE_BTN_XPATH))
            )
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                _retry_stale(lambda: btn.click())
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", btn)
                except Exception:
                    pass
            wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)
            return True
        except Exception:
            pass

        # Final fallback: Ctrl+S
        try:
            ActionChains(self.driver).key_down(Keys.CONTROL).send_keys("s").key_up(Keys.CONTROL).perform()
            wait_ui5_idle(self.driver, timeout=min(4, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)
            return True
        except Exception:
            return False

    # Kept for backward compatibility as a last-resort fallback
    def _activated_dom(self) -> bool:
        try:
            has_edit    = bool(self._query_visible_by_suffix(EDIT_BTN_ID_SUFFIX))
            has_discard = bool(self._query_visible_by_suffix(DISCARD_BTN_ID_SUFFIX))
            aria        = (self._header_aria_label() or "")
            if has_edit and not has_discard:
                return True
            if aria and ("Header area" in aria) and ("New" not in aria):
                return True
            return False
        except Exception:
            return False

    def click_create(self, clicks: int = 1) -> dict:
        info = {"clicks": 0, "dialogs": [], "toasts": []}
        dlg = DialogWatcher(self.driver)
        reader = ToastReader(self.driver)

        for _ in range(max(1, clicks)):
            if dlg.is_open():
                info["dialogs"].append(dlg.text() or "")
                break

            pressed = self._press_activate_best_effort()
            if not pressed:
                continue

            info["clicks"] += 1
            wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
            time.sleep(self.EXTRA_SETTLE_SEC)

            try:
                t = reader.read_last()
                if t:
                    info["toasts"].append(t)
            except Exception:
                pass

            if dlg.is_open():
                info["dialogs"].append(dlg.text() or "")
                break

        return info

    def ensure_created_by_loop_clicking(
        self,
        object_header_ready: Callable[[], bool],
        at_list: Callable[[], bool],
        close_side: Callable[[], bool],
        max_clicks: int = 5,       # was 10
        total_timeout: int = 35,   # default; caller may override
    ) -> Dict:
        dlg   = DialogWatcher(self.driver)
        reader= ToastReader(self.driver)
        msgs  = Ui5Messages(self.driver)
        probe = StatusProbe(self.driver)

        end = time.time() + max(total_timeout, self._timeout)
        clicks = 0
        toasts = []
        msgs.clear()

        while clicks < max(max_clicks,1) and time.time() < end:
            if dlg.is_open():
                return {
                    "status": "dialog_open",
                    "dialog_open": True,
                    "dialog_text": dlg.text(),
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.read_all(),
                    "popover_text": msgs.popover_text(),
                }

            if msgs.has_errors():
                return {
                    "status": "activation_error",
                    "dialog_open": False,
                    "dialog_text": "",
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.errors(),
                    "popover_text": msgs.popover_text(),
                }

            if (
                probe.success()
                or probe.is_persisted_object_page()
                or object_header_ready()
                or at_list()
                or self._activated_dom()
            ):
                close_side()
                return {
                    "status": "created",
                    "dialog_open": False,
                    "dialog_text": "",
                    "footer_clicks": clicks,
                    "intermediate_toasts": toasts,
                    "messages": msgs.read_all(),
                    "popover_text": msgs.popover_text(),
                }

            if self._press_activate_best_effort():
                clicks += 1
                wait_ui5_idle(self.driver, timeout=min(6, self._timeout))
                time.sleep(self.EXTRA_SETTLE_SEC)

            try:
                t = reader.read_last()
                if t:
                    toasts.append(t)
                    lt = (t or "").lower()
                    if any(k in lt for k in ("created", "saved", "activated", "has been created", "successfully")):
                        if not (probe.success() or probe.is_persisted_object_page()):
                            wait_ui5_idle(self.driver, timeout=min(2, self._timeout))
                        close_side()
                        return {
                            "status": "created",
                            "dialog_open": False,
                            "dialog_text": "",
                            "footer_clicks": clicks,
                            "intermediate_toasts": toasts,
                            "messages": msgs.read_all(),
                            "popover_text": msgs.popover_text(),
                        }
            except Exception:
                pass

            time.sleep(0.2)

        if not at_list():
            close_side()

        created = (
            probe.success()
            or probe.is_persisted_object_page()
            or at_list()
            or object_header_ready()
            or self._activated_dom()
        )
        return {
            "status": "created" if created else "unknown",
            "footer_clicks": clicks,
            "intermediate_toasts": toasts,
            "dialog_open": False if not dlg.is_open() else True,
            "dialog_text": dlg.text() if dlg.is_open() else "",
            "messages": msgs.read_all(),
            "popover_text": msgs.popover_text(),
        }


# CurrencyExchangeRates\elements\Footer\selectors.py

# Prefer the specific Activate/Create button on the Object Page footer
ACTIVATE_CREATE_BTN_XPATH = (
    "//*[self::button or self::a]"
    "[substring(@id,string-length(@id)-string-length('--activate')+1)='--activate']"
)

# Backup: Create/Save button by text (kept for safety)
FORM_CREATE_OR_SAVE_BTN_XPATH = (
    "("
    "//bdi[normalize-space()='Create']/ancestor::button[1] | "
    "//bdi[normalize-space()='Save']/ancestor::button[1]"
    ")[1]"
)

# CSS variants (used by JS helpers)
ACTIVATE_CREATE_BTN_CSS = "button[id$='--activate'],a[id$='--activate']"

# DOM success signals (from your snippet)
HEADER_TITLE_ID_SUFFIX = "--objectPage-headerTitle"   # aria-label like "* Header area"
EDIT_BTN_ID_SUFFIX     = "--edit"
DELETE_BTN_ID_SUFFIX   = "--delete"
DISCARD_BTN_ID_SUFFIX  = "--discard"
COPY_BTN_ID_CONTAINS   = "::Copy"


# CurrencyExchangeRates\elements\Footer\__init__.py



# CurrencyExchangeRates\elements\Header\element.py

import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from core.base import Element
from .selectors import OBJECT_HEADER_CONTENT_XPATH, OBJECT_HEADER_RATE_VALUE_XPATH

class ObjectHeaderVerifier(Element):
    def wait_ready(self, timeout: int) -> bool:
        t0 = time.time()
        try:
            WebDriverWait(self.driver, min(6, timeout), ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
            )
        except TimeoutException:
            return False
        while time.time() - t0 < min(timeout, 10):
            try:
                span = self.driver.find_element(By.XPATH, OBJECT_HEADER_RATE_VALUE_XPATH)
                txt = ""
                try:
                    txt = (span.text or "").strip()
                except StaleElementReferenceException:
                    continue
                if txt:
                    return True
            except Exception:
                pass
            time.sleep(0.15)
        return False


# CurrencyExchangeRates\elements\Header\selectors.py

OBJECT_HEADER_CONTENT_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
    "'--objectPage-OPHeaderContent']"
)
OBJECT_HEADER_RATE_VALUE_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--exchangeRate-text')+1)="
    "'--exchangeRate-text']"
)


# CurrencyExchangeRates\elements\Header\__init__.py



# CurrencyExchangeRates\elements\ListToolbar\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from core.base import Element, fluent_wait
from services.ui import wait_ui5_idle
from .selectors import CREATE_BUTTON_XPATH

class ListToolbar(Element):
    def wait_create_clickable(self, timeout: int):
        return fluent_wait(self.driver, timeout, poll=0.2).until(
            EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
        )

    def click_create(self, timeout: int):
        btn = self.wait_create_clickable(timeout)
        try:
            btn.click()
        except Exception:
            self.js_click(btn)
        wait_ui5_idle(self.driver, timeout=timeout)

    def is_at_list(self, quick: float = 0.8) -> bool:
        try:
            fluent_wait(self.driver, quick, poll=0.2).until(
                EC.element_to_be_clickable((By.XPATH, CREATE_BUTTON_XPATH))
            )
            return True
        except Exception:
            return False


# CurrencyExchangeRates\elements\ListToolbar\selectors.py

# Create button in the list report toolbar
CREATE_BUTTON_XPATH = "//bdi[normalize-space()='Create']/ancestor::button[1]"


# CurrencyExchangeRates\elements\ListToolbar\__init__.py



# CurrencyExchangeRates\elements\Messages\element.py

from core.base import Element

class Ui5Messages(Element):
    """
    Reads UI5 MessageManager; surfaces backend errors (why activation fails).
    Also knows how to read the Message Popover DOM (title/subtitle/description)
    which is what your HTML snippet shows.
    """

    def _get_data(self):
        try:
            return self.driver.execute_script(
                """
                try{
                  var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                  if(!core) return {ok:false, data:[]};
                  var mm = core.getMessageManager && core.getMessageManager();
                  if(!mm) return {ok:false, data:[]};
                  var model = mm.getMessageModel && mm.getMessageModel();
                  if(!model) return {ok:false, data:[]};
                  var data = (model.getData && model.getData()) || model.oData || [];
                  var out = [];
                  for (var i=0;i<data.length;i++){
                    var m=data[i]||{};
                    out.push({
                      type: String(m.type||''),
                      message: String(m.message||m.text||'').trim(),
                      description: String(m.description||'').trim(),
                      code: String(m.code||'').trim(),
                      target: String(m.target||'').trim(),
                      technical: !!m.technical
                    });
                  }
                  return {ok:true, data:out};
                }catch(e){ return {ok:false, data:[], err:String(e)}; }
                """
            ) or {"ok": False, "data": []}
        except Exception:
            return {"ok": False, "data": []}

    def read_all(self):
        res = self._get_data()
        return res.get("data", []) if isinstance(res, dict) else []

    def errors(self):
        return [m for m in self.read_all() if (m.get("type") or "").lower() in ("error","fatal","critical")]

    def has_errors(self) -> bool:
        return len(self.errors()) > 0

    def clear(self) -> bool:
        try:
            return bool(self.driver.execute_script(
                """
                try{
                  var core = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore() : null;
                  var mm = core && core.getMessageManager && core.getMessageManager();
                  if(!mm) return false;
                  if(mm.removeAllMessages) { mm.removeAllMessages(); return true; }
                  return false;
                }catch(e){ return false; }
                """
            ))
        except Exception:
            return False

    # ---------- NEW: Message Popover DOM reader ----------

    def popover_text(self) -> str:
        try:
            txt = self.driver.execute_script(
                """
                try{
                  function visible(el){
                    if(!el) return false;
                    var cs = getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r = el.getBoundingClientRect();
                    return r.width>0 && r.height>0;
                  }

                  var wrap = document.querySelector('.sapMPopoverWrapper');
                  if(!wrap || !visible(wrap)) return '';

                  var errIcon = wrap.querySelector('.sapMMsgViewDescIconError');
                  var errStrip = document.querySelector('.sapMMsgStrip.sapMMsgStripError');
                  var isErr = !!(errIcon || errStrip);

                  var titleEl = wrap.querySelector('.sapMMsgView .sapMMsgViewTitleText .sapMLnkText');
                  var subEl   = wrap.querySelector('.sapMMsgView .sapMMsgViewSubtitleText');
                  var descEl  = wrap.querySelector('.sapMMsgView .sapMMsgViewDescriptionText');

                  var title = titleEl ? (titleEl.innerText||titleEl.textContent||'').trim() : '';
                  var sub   = subEl   ? (subEl.innerText||subEl.textContent||'').trim() : '';
                  var desc  = descEl  ? (descEl.innerText||descEl.textContent||'').trim() : '';

                  if(!isErr && !title && !desc) return '';
                  var parts = [];
                  if(title) parts.push(title);
                  if(sub)   parts.push(sub);
                  if(desc)  parts.push(desc);
                  return parts.join(' | ');
                }catch(e){ return ''; }
            """
            )
            return (txt or "").strip()
        except Exception:
            return ""


# CurrencyExchangeRates\elements\Quotation\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import QUOTATION_INNER_INPUT_XPATH, QUOTATION_ARROW_BTN_XPATH, QUOTATION_OPTION_BY_TEXT_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class QuotationField(Element):
    def _hard_clear(self, inp):
        for fn in (
            lambda: inp.clear(),
            lambda: inp.send_keys(Keys.CONTROL, "a"),
            lambda: inp.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", inp),
        ):
            try: _retry_stale(fn)
            except Exception: pass

    def set_value(self, value: str):
        wait = WebDriverWait(self.driver, max(self._timeout, 20), ignored_exceptions=(StaleElementReferenceException,))
        inp = wait.until(EC.visibility_of_element_located((By.XPATH, QUOTATION_INNER_INPUT_XPATH)))

        try: _retry_stale(lambda: inp.click())
        except Exception: self.js_click(inp)

        self._hard_clear(inp)

        _retry_stale(lambda: inp.send_keys(value))
        _retry_stale(lambda: inp.send_keys(Keys.ENTER))
        _retry_stale(lambda: inp.send_keys(Keys.TAB))
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

        def _cur():
            return (inp.get_attribute("value") or "").strip()
        try:
            cur = _retry_stale(_cur)
        except Exception:
            cur = ""
        if cur.lower() != value.strip().lower():
            try:
                arrow = wait.until(EC.element_to_be_clickable((By.XPATH, QUOTATION_ARROW_BTN_XPATH)))
                try: _retry_stale(lambda: arrow.click())
                except Exception: self.js_click(arrow)
            except Exception:
                try: _retry_stale(lambda: inp.send_keys(Keys.ALT, Keys.DOWN))
                except Exception: pass
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
            opt_xpath = QUOTATION_OPTION_BY_TEXT_XPATH.format(TEXT=value.strip())
            option = wait.until(EC.element_to_be_clickable((By.XPATH, opt_xpath)))
            try: _retry_stale(lambda: option.click())
            except Exception: self.js_click(option)
            wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))


# CurrencyExchangeRates\elements\Quotation\selectors.py

QUOTATION_INNER_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-inner')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-inner']"
)
QUOTATION_ARROW_BTN_XPATH = (
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']/ancestor::button[1] | "
    "//span[substring(@id,string-length(@id)-string-length('ExchangeRateQuotation::Field-comboBoxEdit-arrow')+1)="
    "'ExchangeRateQuotation::Field-comboBoxEdit-arrow']"
)
QUOTATION_OPTION_BY_TEXT_XPATH = (
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//bdi[normalize-space()='{TEXT}']/ancestor::li[1] | "
    "//div[contains(@id,'ExchangeRateQuotation::Field-comboBoxEdit-popup')]"
    "//span[normalize-space()='{TEXT}']/ancestor::li[1]"
)


# CurrencyExchangeRates\elements\Quotation\__init__.py



# CurrencyExchangeRates\elements\Rate\element.py

from decimal import Decimal, ROUND_HALF_UP
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import EXCH_RATE_INPUT_XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class ExchangeRateField(Element):
    def _ui_lang_tag(self) -> str:
        try:
            return self.driver.execute_script(
                """
                try{
                  var c=sap && sap.ui && sap.ui.getCore && sap.ui.getCore().getConfiguration && sap.ui.getCore().getConfiguration();
                  if(!c) return (navigator.language || 'en-US');
                  if (c.getLanguageTag) return c.getLanguageTag();
                  if (c.getLanguage)    return c.getLanguage();
                  return (navigator.language || 'en-US');
                }catch(e){ return (navigator.language || 'en-US'); }
                """
            ) or "en-US"
        except Exception:
            return "en-US"

    def _format_rate_locale(self, num: Decimal) -> str:
        q = num.quantize(Decimal("0.00001"), rounding=ROUND_HALF_UP)
        lang = self._ui_lang_tag()
        try:
            from babel.numbers import format_decimal
            return format_decimal(q, format="0.00000", locale=(lang or "en-US").replace("-", "_"))
        except Exception:
            try:
                return self.driver.execute_script(
                    """
                    try{
                      var val = Number(arguments[0]);
                      var lang = arguments[1] || (navigator.language || 'en-US');
                      if (!isFinite(val)) return '';
                      return new Intl.NumberFormat(lang,
                               {minimumFractionDigits:5, maximumFractionDigits:5, useGrouping:false}
                              ).format(val);
                    }catch(e){ return String(arguments[0]); }
                    """,
                    float(q), lang
                )
            except Exception:
                return f"{q:.5f}"

    def _find_input(self):
        try:
            return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_XPATH)
            )
        except Exception:
            pass
        try:
            return WebDriverWait(self.driver, max(self._timeout, 10), ignored_exceptions=(StaleElementReferenceException,)).until(
                lambda d: d.find_element(By.XPATH, EXCH_RATE_INPUT_FALLBACK_XPATH)
            )
        except Exception:
            raise RuntimeError("Exchange Rate input not found (primary nor fallback).")

    def _hard_clear(self, el):
        for js in (
            lambda: el.clear(),
            lambda: el.send_keys(Keys.CONTROL, "a"),
            lambda: el.send_keys(Keys.DELETE),
            lambda: self.driver.execute_script(
                "arguments[0].value='';"
                "arguments[0].dispatchEvent(new Event('input',{bubbles:true}));"
                "arguments[0].dispatchEvent(new Event('change',{bubbles:true}));", el),
        ):
            try: _retry_stale(js)
            except Exception: pass

    def commit(self, times: int = 1):
        inp = self._find_input()
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", inp)
        except Exception:
            pass
        try:
            _retry_stale(lambda: inp.click())
        except Exception:
            self.js_click(inp)

        try:
            ac = ActionChains(self.driver)
            for _ in range(max(1, times)):
                ac.send_keys(Keys.ENTER).pause(0.03)
            ac.send_keys(Keys.TAB)
            ac.perform()
        except Exception:
            try:
                _retry_stale(lambda: inp.send_keys(Keys.ENTER))
                _retry_stale(lambda: inp.send_keys(Keys.TAB))
            except Exception: pass

        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

    def set_via_typing(self, rate_val: str | float | Decimal):
        num = Decimal(str(rate_val))
        if num <= 0:
            raise ValueError("rate_val must be > 0")
        s = self._format_rate_locale(num)
        inp = self._find_input()
        self._hard_clear(inp)
        _retry_stale(lambda: inp.send_keys(s))
        try: _retry_stale(lambda: inp.send_keys(Keys.TAB))
        except Exception: pass
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))

    def set_via_ui5(self, rate_val: str | float | Decimal):
        inp = self._find_input()
        inner_id = inp.get_attribute("id")
        if not inner_id:
            raise RuntimeError("Exchange Rate input has no DOM id")

        res = self.driver.execute_script(
            """
            try{
              var innerId=arguments[0], num=Number(String(arguments[1]).replace(',','.'));
              if(!isFinite(num) || num<=0){ return {ok:false, reason:'nonpositive'}; }
              var ctrlId = innerId.endsWith('-inner') ? innerId.slice(0,-6) : innerId;
              var ctrl = sap && sap.ui && sap.ui.getCore ? sap.ui.getCore().byId(ctrlId) : null;
              var fmt = (sap && sap.ui && sap.ui.core && sap.ui.core.format && sap.ui.core.format.NumberFormat)
                        ? sap.ui.core.format.NumberFormat.getFloatInstance({maxFractionDigits:5,minFractionDigits:5,groupingEnabled:false})
                        : null;
              var s = fmt ? fmt.format(num) : num.toFixed(5);

              if(ctrl && ctrl.setValue){
                  ctrl.setValue(s);
                  if (ctrl.fireLiveChange) ctrl.fireLiveChange({ value: s });
                  if (ctrl.fireChange)     ctrl.fireChange({ value: s });
              }
              var el = document.getElementById(innerId);
              if(el){
                  el.focus();
                  el.value = s;
                  el.dispatchEvent(new Event('input',{bubbles:true}));
                  el.dispatchEvent(new Event('change',{bubbles:true}));
              }
              var parsed = fmt ? fmt.parse(s) : Number(s.replace(',','.'));
              return {ok:(typeof parsed==='number' && parsed>0), shown:s, parsed:parsed};
            }catch(e){ return {ok:false, reason:String(e)}; }
            """,
            inner_id, str(rate_val)
        )
        wait_ui5_idle(self.driver, timeout=min(self._timeout, 4))
        if not res or not res.get("ok"):
            raise RuntimeError(f"Could not set Exchange Rate via UI5. Result={res}.")


# CurrencyExchangeRates\elements\Rate\selectors.py

EXCH_RATE_INPUT_XPATH = (
    "//input[substring(@id,string-length(@id)-string-length('AbsoluteExchangeRate::Field-input-inner')+1)="
    "'AbsoluteExchangeRate::Field-input-inner']"
)

EXCH_RATE_INPUT_FALLBACK_XPATH = (
    "("
    "//label[.//bdi[normalize-space()='Exchange Rate']]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//span[normalize-space()='Exchange Rate']/ancestor::label[1]"
    "/following::input[contains(@id,'-inner')][1] | "
    "//*[self::label or self::span][contains(normalize-space(.), 'Exchange Rate')]"
    "/following::input[contains(@id,'-inner')][1]"
    ")"
)


# CurrencyExchangeRates\elements\Rate\__init__.py



# CurrencyExchangeRates\elements\SideColumn\element.py

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
import time

from core.base import Element
from services.ui import wait_ui5_idle
from ..ListToolbar.element import ListToolbar
from .selectors import CLOSE_COLUMN_BTN_XPATH

def _retry_stale(fn, tries=3, pause=0.12):
    last = None
    for _ in range(max(1, tries)):
        try:
            return fn()
        except StaleElementReferenceException as e:
            last = e
            time.sleep(pause)
    if last:
        raise last
    return None

class SideColumnController(Element):
    def close_if_present(self, timeout: int | None = None) -> bool:
        t = timeout or max(self._timeout, 20)
        listbar = ListToolbar(self.driver)

        if listbar.is_at_list(quick=0.8):
            return True

        try:
            btn = WebDriverWait(self.driver, min(5, t), ignored_exceptions=(StaleElementReferenceException,)).until(
                EC.element_to_be_clickable((By.XPATH, CLOSE_COLUMN_BTN_XPATH))
            )
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", btn)
            except Exception:
                pass
            try:
                _retry_stale(lambda: btn.click())
            except Exception:
                self.js_click(btn)
            wait_ui5_idle(self.driver, timeout=min(6, t))
        except TimeoutException:
            try:
                did = self.driver.execute_script(
                    """
                    try{
                      var q = document.querySelectorAll(
                        "button[id$='--closeColumn'],button[id$='--closeColumnBtn'],button[id*='closeColumn']"
                      );
                      for (var i=q.length-1;i>=0;i--){
                        var b=q[i];
                        var cs=window.getComputedStyle(b);
                        if(b && b.offsetParent && cs.visibility!=='hidden' && cs.display!=='none'){ b.click(); return 'clicked-dom'; }
                      }
                      return 'none';
                    }catch(e){ return 'err:'+e; }
                    """
                )
            except Exception:
                did = "err"
            wait_ui5_idle(self.driver, timeout=2)

            if did != "clicked-dom":
                try:
                    _ = self.driver.execute_script(
                        """
                        try{
                          var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                          if(!core) return 'no-core';
                          var all = core && core.mElements ? Object.values(core.mElements) : [];
                          var fcl=null, name='';
                          for (var i=0;i<all.length;i++){
                            var c=all[i];
                            try{
                              name=c.getMetadata && c.getMetadata().getName && c.getMetadata().getName();
                              if(name==='sap.f.FlexibleColumnLayout'){ fcl=c; break; }
                            }catch(e){}
                          }
                          if(fcl && fcl.setLayout){
                            var LT = sap.f && sap.f.LayoutType;
                            var one = (LT && LT.OneColumn) || 'OneColumn';
                            fcl.setLayout(one);
                            return 'set-one-column';
                          }
                          return 'no-fcl';
                        }catch(e){ return 'err:'+e; }
                        """
                    )
                except Exception:
                    _ = "err"
                wait_ui5_idle(self.driver, timeout=2)

        if listbar.is_at_list(quick=1.0):
            return True
        return True


# CurrencyExchangeRates\elements\SideColumn\selectors.py

CLOSE_COLUMN_BTN_XPATH = (
    "("
    "  //button[substring(@id,string-length(@id)-string-length('--closeColumn')+1)='--closeColumn']"
    "  | //button[substring(@id,string-length(@id)-string-length('--closeColumnBtn')+1)='--closeColumnBtn']"
    "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-inner')+1)='--closeColumn-inner']/ancestor::button[1]"
    "  | //span[substring(@id,string-length(@id)-string-length('--closeColumn-img')+1)='--closeColumn-img']/ancestor::button[1]"
    "  | //button[@title='Close' or @aria-label='Close' or @aria-label='Close Column']"
    ")[1]"
)


# CurrencyExchangeRates\elements\SideColumn\__init__.py



# CurrencyExchangeRates\elements\Status\element.py

# elements/Status/element.py
import time
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By

from core.base import Element
from .selectors import (
    HEADER_EDIT_BTN_XPATH, HEADER_DELETE_BTN_XPATH, HEADER_COPY_BTN_XPATH,
    FOOTER_DISCARD_DRAFT_BTN_XPATH,
    CHANGE_LOG_SECTION_ANCHOR_XPATH, TREND_SECTION_ANCHOR_XPATH,
    OBJECT_HEADER_CONTENT_XPATH,
)

class StatusProbe(Element):
    def _exists(self, xp: str, t: float = 0.7) -> bool:
        try:
            WebDriverWait(self.driver, t).until(EC.presence_of_element_located((By.XPATH, xp)))
            return True
        except Exception:
            return False

    def is_active_entity(self):
        try:
            res = self.driver.execute_script(
                """
                try{
                  var core=sap && sap.ui && sap.ui.getCore && sap.ui.getCore();
                  if(!core) return {ok:false, why:'no-core'};
                  var els = core && core.mElements ? Object.values(core.mElements) : [];
                  for (var i=0;i<els.length;i++){
                    var c=els[i];
                    try{
                      var n=c.getMetadata&&c.getMetadata().getName&&c.getMetadata().getName();
                      if(n==='sap.uxap.ObjectPageLayout'){
                        var bc=c.getBindingContext&&c.getBindingContext();
                        if(bc){
                          var o=bc.getObject&&bc.getObject();
                          if(o && ('IsActiveEntity' in o)) return {ok:true, active: !!o.IsActiveEntity};
                          var p=bc.getProperty&&bc.getProperty('IsActiveEntity');
                          if(typeof p!=='undefined') return {ok:true, active: !!p};
                        }
                      }
                    }catch(e){}
                  }
                  for (var j=0;j<els.length;j++){
                    var c2=els[j];
                    try{
                      var bc2=c2.getBindingContext&&c2.getBindingContext();
                      if(bc2){
                        var p2=bc2.getProperty&&bc2.getProperty('IsActiveEntity');
                        if(typeof p2!=='undefined') return {ok:true, active: !!p2};
                      }
                    }catch(e){}
                  }
                  return {ok:false, why:'no-binding'};
                }catch(e){ return {ok:false, why:String(e)}; }
                """
            )
            if isinstance(res, dict) and res.get("ok"):
                return bool(res.get("active"))
        except Exception:
            pass
        return None

    def buttons_state(self) -> dict:
        return {
            "has_edit":   self._exists(HEADER_EDIT_BTN_XPATH),
            "has_delete": self._exists(HEADER_DELETE_BTN_XPATH),
            "has_copy":   self._exists(HEADER_COPY_BTN_XPATH),
            "has_discard_draft": self._exists(FOOTER_DISCARD_DRAFT_BTN_XPATH),
        }

    def sections_present(self) -> dict:
        return {
            "has_log":   self._exists(CHANGE_LOG_SECTION_ANCHOR_XPATH),
            "has_trend": self._exists(TREND_SECTION_ANCHOR_XPATH),
        }

    def header_aria_label(self) -> str:
        try:
            el = WebDriverWait(self.driver, 0.7).until(
                EC.presence_of_element_located((By.XPATH, OBJECT_HEADER_CONTENT_XPATH))
            )
            return (el.get_attribute("aria-label") or "").strip()
        except Exception:
            return ""

    def object_header_text(self) -> str:
        try:
            return self.driver.execute_script("""
                try{
                  var el = document.querySelector("[id*='ObjectPageDynamicHeaderTitle-inner']");
                  return (el && (el.innerText||el.textContent)||'').trim();
                }catch(e){return '';}
            """) or ""
        except Exception:
            return ""

    def is_create_mode(self) -> bool:
        try:
            return bool(self.driver.execute_script("""
                try{
                  function vis(el){ if(!el) return false; var cs=getComputedStyle(el);
                    if(cs.display==='none'||cs.visibility==='hidden') return false;
                    var r=el.getBoundingClientRect(); return r.width>0 && r.height>0;
                  }
                  var nodes=[...document.querySelectorAll('button,bdi')];
                  return nodes.some(n=>{
                    var t=(n.innerText||n.textContent||'').trim();
                    if(!/\bCreate\b/i.test(t)) return false;
                    var b=n.tagName==='BDI' ? n.closest('button') : n;
                    return vis(b);
                  });
                }catch(e){return false;}
            """))
        except Exception:
            return False

    def is_draft_url(self) -> bool:
        try:
            return bool(self.driver.execute_script("return location.href.includes('IsActiveEntity=false');"))
        except Exception:
            return False

    def is_persisted_object_page(self) -> bool:
        title = self.object_header_text()
        if not title:
            return False
        if self.is_create_mode():
            return False
        if not self.is_draft_url():
            return True
        btns = self.buttons_state()
        return (btns["has_edit"] and not btns["has_discard_draft"])

    def success(self) -> bool:
        active = self.is_active_entity()
        if active is True:
            return True

        btns = self.buttons_state()
        if btns["has_edit"] and not btns["has_discard_draft"]:# Discard Draft disappeared
            return True

        secs = self.sections_present()
        if secs["has_log"] or secs["has_trend"]:
            return True

        aria = self.header_aria_label()
        if aria and "Header area" in aria and "New" not in aria:
            return True

        if self.is_persisted_object_page():
            return True

        return False


# CurrencyExchangeRates\elements\Status\selectors.py

# elements/Status/selectors.py

# Action buttons that flip after activation
HEADER_EDIT_BTN_XPATH = (
    "//bdi[normalize-space()='Edit']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--edit')+1)='--edit']"
)
HEADER_DELETE_BTN_XPATH = (
    "//bdi[normalize-space()='Delete']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--delete')+1)='--delete']"
)
HEADER_COPY_BTN_XPATH = (
    "//bdi[normalize-space()='Copy']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--copy')+1)='--copy']"
)
FOOTER_DISCARD_DRAFT_BTN_XPATH = (
    "//bdi[normalize-space()='Discard Draft']/ancestor::button[1] | "
    "//button[substring(@id,string-length(@id)-string-length('--discard')+1)='--discard']"
)

# Sections that typically appear post-activation
CHANGE_LOG_SECTION_ANCHOR_XPATH = (
    "//a[contains(@id,'ExchangeRateLog') and contains(@id,'Section-anchor')] | "
    "//a[contains(normalize-space(.), 'Change Log') and contains(@id,'Section-anchor')]"
)
TREND_SECTION_ANCHOR_XPATH = (
    "//a[contains(@id,'CurrencyExchangeRateTrend') and contains(@id,'Section-anchor')] | "
    "//a[contains(normalize-space(.), 'Trend') and contains(@id,'Section-anchor')]"
)

# Object header root for reading aria-label
OBJECT_HEADER_CONTENT_XPATH = (
    "//*[substring(@id,string-length(@id)-string-length('--objectPage-OPHeaderContent')+1)="
    "'--objectPage-OPHeaderContent']"
)


# CurrencyExchangeRates\elements\Toast\element.py

from core.base import Element
from .selectors import MESSAGE_TOAST_CSS

class ToastReader(Element):
    def read_last(self) -> str:
        try:
            txt = self.driver.execute_script(
                "var nodes=document.querySelectorAll(arguments[0]);"
                "if(!nodes||nodes.length===0) return '';"
                "var t=nodes[nodes.length-1];"
                "return (t.innerText||t.textContent||'').trim();",
                MESSAGE_TOAST_CSS,
            )
            return (txt or "").strip()
        except Exception:
            return ""


# CurrencyExchangeRates\elements\Toast\selectors.py

MESSAGE_TOAST_CSS = ".sapMMessageToast"


# CurrencyExchangeRates\elements\Toast\__init__.py



# CurrencyExchangeRates\elements\Validation\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import ANY_INVALID_INPUT_XPATH, ANY_ERROR_WRAPPER_XPATH

class ValidationInspector(Element):
    def collect(self) -> str | None:
        try:
            bad_inputs = self.driver.find_elements(By.XPATH, ANY_INVALID_INPUT_XPATH)
            if bad_inputs:
                messages = []
                for el_ in bad_inputs:
                    try:
                        err_id = el_.get_attribute("aria-errormessage") or ""
                        msg = self.driver.execute_script(
                            "var id=arguments[0];"
                            "var n=id?document.getElementById(id):null;"
                            "return n? (n.innerText || n.textContent || '').trim():'';", err_id)
                        if msg: messages.append(msg)
                    except Exception:
                        continue
                if messages: return "; ".join(sorted(set(messages)))
                return f"{len(bad_inputs)} invalid field(s)."
            wrappers = self.driver.find_elements(By.XPATH, ANY_ERROR_WRAPPER_XPATH)
            if wrappers: return f"{len(wrappers)} field wrapper(s) in error state."
        except Exception:
            pass
        return None


# CurrencyExchangeRates\elements\Validation\selectors.py

ANY_INVALID_INPUT_XPATH = "//*[(@aria-invalid='true') and (self::input or self::textarea)]"
ANY_ERROR_WRAPPER_XPATH = "//*[contains(@class,'sapMInputBaseContentWrapperError')]"


# CurrencyExchangeRates\elements\Validation\__init__.py



# Index\ProcurementOverviewTile\element.py

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import GRID_READY_XPATH, BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH

class ProcurementOverviewTile(Element):
    def _find_tile_quick(self, timeout_s: float):
        wait = WebDriverWait(self.driver, timeout_s)
        # Ensure tiles grid exists
        wait.until(EC.presence_of_element_located((By.XPATH, GRID_READY_XPATH)))

        # Try a few reliable selectors with short caps
        for xp in (BY_HREF_XPATH, BY_TITLE_TEXT_XPATH, BY_ARIA_LABEL_XPATH):
            try:
                return WebDriverWait(self.driver, timeout_s).until(
                    EC.presence_of_element_located((By.XPATH, xp))
                )
            except Exception:
                continue
        return None

    def click(self):
        # Keep things brisk
        short = min(self._timeout, 6)
        wait_ui5_idle(self.driver, timeout=short)

        el = self._find_tile_quick(timeout_s=short)
        if el:
            href = (el.get_attribute("href") or "").strip()
            # Try normal click → JS click
            try:
                self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                WebDriverWait(self.driver, short).until(EC.element_to_be_clickable((By.XPATH, BY_TITLE_TEXT_XPATH)))
                el.click()
                wait_ui5_idle(self.driver, timeout=short)
                return
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].click();", el)
                    wait_ui5_idle(self.driver, timeout=short)
                    return
                except Exception:
                    if href:
                        self.driver.execute_script("window.location.href = arguments[0];", href)
                        wait_ui5_idle(self.driver, timeout=self._timeout)
                        return
                    raise RuntimeError("Found tile but could not activate it.")
        else:
            # Hard fallback: navigate directly by hash (fastest)
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Procurement-displayOverviewPage';"
            )
            wait_ui5_idle(self.driver, timeout=self._timeout)


# Index\ProcurementOverviewTile\selectors.py

# pages/Index/elements/ProcurementOverviewTile/selectors.py

# Grid container (ensures tiles were rendered)
GRID_READY_XPATH = ("//div[starts-with(@id,'__section') and "
                    "contains(@id,'-defaultArea-listUl') and @role='list']")

# Primary: match by the hash target in the href (most stable between tenants)
BY_HREF_XPATH = ("//a[contains(@class,'sapMGT') and "
                 "contains(@href, '#Procurement-displayOverviewPage')]")

# Secondary: visible title text (from your HTML)
BY_TITLE_TEXT_XPATH = ("//a[contains(@class,'sapMGT')]"
                       "[.//span[normalize-space()='Procurement Overview']]")

# Tertiary: aria-label starts with title
BY_ARIA_LABEL_XPATH = ("//a[contains(@class,'sapMGT') and "
                       "starts-with(normalize-space(@aria-label),'Procurement Overview')]")


# Index\ProcurementOverviewTile\__init__.py



# Index\PurchasingTab\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from services.ui import wait_ui5_idle
from .selectors import PURCHASING_TAB_XPATH

class PurchasingTab(Element):
    def click(self):
        wait_ui5_idle(self.driver, timeout=self._timeout)
        el = self.wait_clickable(By.XPATH, PURCHASING_TAB_XPATH)
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
            el.click()
        except Exception:
            self.js_click(el)


# Index\PurchasingTab\selectors.py

# pages/Index/elements/PurchasingTab/selectors.py
PURCHASING_TAB_XPATH = (
    "//div[contains(@class,'sapMITBFilterWrapper')]"
    "[.//span[normalize-space()='Purchasing']]"
)


# Index\PurchasingTab\__init__.py



# Login\elements\__init__.py



# Login\elements\Password\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import PASSWORD_INPUT

class Password(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, PASSWORD_INPUT)
        el.clear()
        el.send_keys(value)


# Login\elements\Password\selectors.py

PASSWORD_INPUT = "#j_password"


# Login\elements\Password\__init__.py



# Login\elements\Submit\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import SUBMIT_BTN

class Submit(Element):
    def click(self):
        el = self.wait_clickable(By.CSS_SELECTOR, SUBMIT_BTN)
        try:
            el.click()
        except Exception:
            self.js_click(el)


# Login\elements\Submit\selectors.py

SUBMIT_BTN = "#logOnFormSubmit"


# Login\elements\Submit\__init__.py



# Login\elements\Username\element.py

from selenium.webdriver.common.by import By
from core.base import Element
from .selectors import USERNAME_INPUT

class Username(Element):
    def set(self, value: str):
        el = self.wait_visible(By.CSS_SELECTOR, USERNAME_INPUT)
        el.clear()
        el.send_keys(value)


# Login\elements\Username\selectors.py

USERNAME_INPUT = "#j_username"


# Login\elements\Username\__init__.py



# Shell\Search\element.py

# pages/Shell/Search/element.py
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import InvalidElementStateException, TimeoutException

from core.base import Element
from services.ui import wait_ui5_idle, wait_shell_search_ready, open_shell_search_via_js
from .selectors import (
    SEARCH_TOGGLE_CSS_PRIMARY,
    SEARCH_TOGGLE_CSS_ALT_HELP,
    SEARCH_TOGGLE_CSS_ALT_ARIA,
    SEARCH_INPUT_INNER_CSS,
    SUGGEST_TABLE_XPATH,
    APP_ROW_BY_TEXT_XPATH,
    APP_ROW_BY_TEXT_ALT_XPATH,
)

class ShellSearch(Element):
    def _wait_input_interactable(self):
        """
        Wait until the shell search input is present, visible, and not disabled/readOnly.
        Also ensure it has non-zero size (animation finished).
        """
        wait = WebDriverWait(self.driver, max(self._timeout, 25))
        inp = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Visible
        inp = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, SEARCH_INPUT_INNER_CSS)))
        # Enabled + not readOnly + has size
        wait.until(lambda d: d.execute_script(
            "var el=arguments[0];"
            "if(!el) return false;"
            "var cs=window.getComputedStyle(el);"
            "var ok=!!(el.offsetParent) && cs.visibility!=='hidden' && cs.display!=='none' && "
            "!el.disabled && !el.readOnly && el.clientWidth>0 && el.clientHeight>0;"
            "return ok;", inp))
        # Focus it
        try:
            inp.click()
        except Exception:
            self.js_click(inp)
        try:
            self.driver.execute_script("arguments[0].focus();", inp)
        except Exception:
            pass
        return inp

    def open_search(self):
        # Give UI5/FLP time to render the header/search
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        wait_shell_search_ready(self.driver, timeout=max(self._timeout, 25))

        # Try clicking toggle; else JS renderer fallback
        candidates = (SEARCH_TOGGLE_CSS_PRIMARY, SEARCH_TOGGLE_CSS_ALT_HELP, SEARCH_TOGGLE_CSS_ALT_ARIA)
        clicked = False
        for css in candidates:
            try:
                el = WebDriverWait(self.driver, max(self._timeout, 25)).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, css))
                )
                try:
                    el.click()
                except Exception:
                    self.js_click(el)
                clicked = True
                break
            except Exception:
                continue

        if not clicked:
            if not open_shell_search_via_js(self.driver):
                raise TimeoutError("Shell search toggle not found and JS fallback failed.")

        # Wait until input is truly interactable (not just present)
        self._wait_input_interactable()
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        return self

    def type_and_choose_app(self, query_text: str):
        inp = self._wait_input_interactable()

        # Clear safely
        try:
            inp.clear()
        except InvalidElementStateException:
            # JS clear fallback
            self.driver.execute_script(
                "arguments[0].value=''; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp
            )

        # Type the query; if Selenium send_keys bounces, use JS then send ENTER to trigger suggestions
        try:
            inp.send_keys(query_text)
        except InvalidElementStateException:
            self.driver.execute_script(
                "arguments[0].value=arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true}));",
                inp, query_text
            )
            inp.send_keys(Keys.ENTER)

        # Wait for suggestions table to show up
        wait = WebDriverWait(self.driver, max(self._timeout, 25))
        try:
            wait.until(EC.presence_of_element_located((By.XPATH, SUGGEST_TABLE_XPATH)))
        except TimeoutException:
            # If suggestions didn't appear, fallback: open the app directly by intent hash
            self.driver.execute_script(
                "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
            )
            wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
            return self

        # Click the suggestion row (exact text), else fallback to contains()
        for xp in (APP_ROW_BY_TEXT_XPATH, APP_ROW_BY_TEXT_ALT_XPATH):
            try:
                row = wait.until(EC.element_to_be_clickable((By.XPATH, xp)))
                try:
                    row.click()
                except Exception:
                    self.js_click(row)
                wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
                return self
            except TimeoutException:
                continue

        # Last resort: deep-link by hash
        self.driver.execute_script(
            "location.href = location.origin + '/ui?sap-ushell-config=lean#Currency-maintainExchangeRates';"
        )
        wait_ui5_idle(self.driver, timeout=max(self._timeout, 25))
        return self


# Shell\Search\selectors.py

# pages/Shell/Search/selectors.py

# Shell search toggle (try a few stable variants)
SEARCH_TOGGLE_CSS_PRIMARY = "a#sf.sapUshellShellHeadItm"
SEARCH_TOGGLE_CSS_ALT_HELP = "a.sapUshellShellHeadItm[data-help-id='shellHeader-search']"
SEARCH_TOGGLE_CSS_ALT_ARIA = "a.sapUshellShellHeadItm[role='button'][aria-label*='Search']"

# The input that appears after opening search (robust id pattern)
SEARCH_INPUT_INNER_CSS = "input[id*='searchFieldInShell'][id$='-inner']"

# Suggestion table + target row
SUGGEST_TABLE_XPATH = "//table[contains(@id,'searchFieldInShell-input-popup-table-listUl')]"
# Prefer exact text; fall back to contains if localized slightly
APP_ROW_BY_TEXT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[normalize-space()='Currency Exchange Rates']/ancestor::*[self::tr or self::li][1]"
)
APP_ROW_BY_TEXT_ALT_XPATH = (
    SUGGEST_TABLE_XPATH +
    "//span[contains(normalize-space(),'Currency Exchange Rate')]/ancestor::*[self::tr or self::li][1]"
)


# Shell\Search\__init__.py



## .txt / .csv / .json files (names only)

snapshot.txt